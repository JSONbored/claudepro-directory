import { existsSync, readFileSync } from 'node:fs';
import fs from 'node:fs/promises';
import path, { resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

import { logger } from '../toolkit/logger.js';
import { createServiceRoleClient } from '../toolkit/supabase.js';

const SCRIPT_DIR = path.dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = path.resolve(SCRIPT_DIR, '../../../..');
const TARGET_CONFIG_PATH = path.resolve(
  REPO_ROOT,
  'packages/web-runtime/src/config/generated-config.ts'
);

/**
 * Load environment variables from .env.local if it exists
 * This ensures SUPABASE_SERVICE_ROLE_KEY is available during build
 */
function loadEnvFile(): void {
  const envPath = resolve(REPO_ROOT, '.env.local');
  if (!existsSync(envPath)) {
    return; // .env.local doesn't exist - that's okay, use system env vars
  }

  try {
    const envContent = readFileSync(envPath, 'utf8');
    const lines = envContent.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const match = trimmed.match(/^([^=]+)=(.*)$/);
      if (match) {
        const [, key, value] = match;
        if (key && value !== undefined) {
          const cleanValue = value.replaceAll(/^["']|["']$/g, ''); // Remove quotes
          if (!process.env[key]) {
            process.env[key] = cleanValue;
          }
        }
      }
    }
  } catch {
    // .env.local exists but can't be read - that's okay, use system env vars
  }
}

// Load .env.local if it exists
loadEnvFile();

async function generateConfig() {
  logger.info('Fetching build-time configuration from Supabase');

  try {
    // Use the shared service role client which handles fallbacks and standard env vars
    // like other generator scripts (e.g. generate-category-config.ts).
    // This uses SUPABASE_SERVICE_ROLE_KEY and falls back to DEFAULT_SUPABASE_URL if needed.
    const supabase = createServiceRoleClient();

    const { data, error } = await supabase.rpc('get_all_app_settings');

    if (error) {
      throw new Error(`Failed to fetch settings: ${error.message}`);
    }

    if (!data) {
      logger.warn('No settings returned from get_all_app_settings RPC');
      return;
    }

    const configContent = `// --------------------------------------------------------------------------
// ⚠️ THIS IS A GENERATED FILE. DO NOT EDIT MANUALLY.
// ⚠️ Generated by packages/generators/src/commands/generate-config.ts at build time.
// ⚠️ To update, change values in the 'app_settings' database table and rebuild.
// --------------------------------------------------------------------------

export const GENERATED_CONFIG = ${JSON.stringify(data, null, 2)} as const;

export type GeneratedConfig = typeof GENERATED_CONFIG;
`;

    await fs.writeFile(TARGET_CONFIG_PATH, configContent, 'utf8');
    logger.info('Configuration generated successfully', { path: TARGET_CONFIG_PATH });
  } catch (error) {
    logger.error('Error generating config', error, { path: TARGET_CONFIG_PATH });
    process.exit(1);
  }
}

generateConfig().catch((error) => {
  logger.error('Unhandled error in generateConfig', error);
  process.exit(1);
});
