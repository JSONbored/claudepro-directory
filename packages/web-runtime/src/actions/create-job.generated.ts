// -----------------------------------------------------------------------------
// ðŸ”’ AUTO-GENERATED - DO NOT EDIT
// Generated by packages/generators/src/commands/generate-server-actions.ts
// -----------------------------------------------------------------------------

import { z } from 'zod';
import { authedAction } from './safe-action';
import { runRpc } from './run-rpc-instance';
import { logActionFailure } from '../errors';
import type { Database } from '@heyclaude/database-types';
import { revalidatePath, revalidateTag } from 'next/cache';
import { nextInvalidateByKeys } from '../cache-tags';
import { getCacheConfigSnapshot } from '../cache-config';
import { onJobCreated } from './hooks/job-hooks.ts';

export const createJobSchema = z.object({
  company: z.string().nullable().optional(),
  company_id: z.string().uuid().nullable().optional(),
  title: z.string().nullable().optional(),
  description: z.string().nullable().optional(),
  type: z.enum(['full-time', 'part-time', 'contract', 'freelance', 'internship']).nullable().optional(),
  category: z.enum(['engineering', 'design', 'product', 'marketing', 'sales', 'support', 'research', 'data', 'operations', 'leadership', 'consulting', 'education', 'other']).nullable().optional(),
  link: z.string().nullable().optional(),
  location: z.string().nullable().optional(),
  salary: z.string().nullable().optional(),
  remote: z.boolean().nullable().optional(),
  workplace: z.enum(['Remote', 'On site', 'Hybrid']).nullable().optional(),
  experience: z.enum(['beginner', 'intermediate', 'advanced']).nullable().optional(),
  tags: z.array(z.string()).nullable().optional(),
  requirements: z.array(z.string()).nullable().optional(),
  benefits: z.array(z.string()).nullable().optional(),
  contact_email: z.string().nullable().optional(),
  company_logo: z.string().nullable().optional(),
  tier: z.enum(['standard', 'featured']),
  plan: z.enum(['one-time', 'subscription'])
});
export type CreateJobInput = z.infer<typeof createJobSchema>;

export const createJob = authedAction
  .metadata({ actionName: 'createJob', category: 'content' })
  .inputSchema(createJobSchema)
  .action(async ({ parsedInput, ctx }) => {
    try {
      const rawResult = await runRpc<Database['public']['Functions']['create_job_with_payment']['Returns']>(
        'create_job_with_payment',
        {
          'p_user_id': ctx.userId,
          'p_job_data': {
            'company': parsedInput.company,
            'company_id': parsedInput.company_id,
            'title': parsedInput.title,
            'description': parsedInput.description,
            'type': parsedInput.type,
            'category': parsedInput.category,
            'link': parsedInput.link,
            'location': parsedInput.location,
            'salary': parsedInput.salary,
            'remote': parsedInput.remote,
            'workplace': parsedInput.workplace,
            'experience': parsedInput.experience,
            'tags': parsedInput.tags,
            'requirements': parsedInput.requirements,
            'benefits': parsedInput.benefits,
            'contact_email': parsedInput.contact_email,
            'company_logo': parsedInput.company_logo
          },
          'p_tier': parsedInput.tier,
          'p_plan': parsedInput.plan
        },
        {
          action: 'createJob.rpc',
          userId: ctx.userId,
        }
      );

      
      const result = rawResult;
      

      // Simple success check?
      // Some RPCs return void, some return { success: boolean }?
      // We assume implicit success if no error thrown by runRpc.
      
      revalidatePath(`/jobs`);
      revalidatePath(`/account/jobs`);
      revalidateTag(`job-${result?.job_id}`, 'default');
      revalidateTag(`company-${result?.company_id}`, 'default');
      revalidateTag(`company-id-${result?.company_id}`, 'default');
      
      await nextInvalidateByKeys({
        cacheConfigPromise: getCacheConfigSnapshot(),
        invalidateKeys: ['cache.invalidate.job_create']
      });

      
      const hookResult = await onJobCreated(result, ctx, parsedInput);
      if (hookResult) {
        return hookResult;
      }
    

      return result;
    } catch (error) {
      throw logActionFailure('createJob', error, {
        userId: ctx.userId,
        input: parsedInput
      });
    }
  });
