#!/usr/bin/env tsx
/**
 * Category Artifacts Auto-Generation
 *
 * Generates client-safe TypeScript artifacts derived from UNIFIED_CATEGORY_REGISTRY.
 * Eliminates manual synchronization and ensures category consistency across the codebase.
 *
 * **What This Solves:**
 * Before: 3+ files with hardcoded category arrays that fell out of sync
 * After: Single source of truth (UNIFIED_CATEGORY_REGISTRY) → auto-generated artifacts
 *
 * **Generated Files:**
 * 1. src/lib/config/category-types.ts - Client-safe category types (no Zod imports)
 * 2. src/lib/ui-constants-categories.ts - Category badge colors and UI config
 *
 * **Why Split Generation:**
 * - category-types.ts: Imported by Zod schemas (breaks circular dependencies)
 * - ui-constants-categories.ts: Imported by UI components (browser bundle optimization)
 *
 * **Architecture Benefits:**
 * - Zero manual synchronization (add category to registry → everything updates)
 * - Type-safe (TypeScript validates all references)
 * - Tree-shakeable (only used categories included in bundle)
 * - No server imports in client code (Storybook compatible)
 *
 * **OPTIMIZATION (Phase 2):**
 * - Hash-based caching: Skip regeneration when category-config.ts unchanged
 * - Saves ~10s on 95% of builds
 *
 * Usage:
 *   npm run generate:categories       # Generate all artifacts
 *   npm run generate:categories --check # Drift detection (CI/CD)
 *   npm run generate:categories --dry   # Preview without writing
 */

import { createHash } from 'node:crypto';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const ROOT = join(__dirname, '../..');
const SRC = join(ROOT, 'src');

// Output files
const CATEGORY_TYPES_FILE = join(SRC, 'lib/config/category-types.ts');
const UI_CONSTANTS_CATEGORIES_FILE = join(SRC, 'lib/ui-constants-categories.ts');

// ============================================================================
// Generator Functions
// ============================================================================

/**
 * Import UNIFIED_CATEGORY_REGISTRY dynamically
 * We use dynamic import to avoid TypeScript compilation issues
 */
async function loadCategoryRegistry(): Promise<{
  registry: Record<string, { colorScheme?: string; label?: string }>;
  categoryIds: string[];
}> {
  // Dynamic import from compiled JavaScript (not TypeScript)
  const configModule = await import('../../src/lib/config/category-config.js');

  const registry = configModule.UNIFIED_CATEGORY_REGISTRY;
  const categoryIds = configModule.getAllCategoryIds();

  if (!(registry && categoryIds) || categoryIds.length === 0) {
    throw new Error('Failed to load UNIFIED_CATEGORY_REGISTRY');
  }

  return { registry, categoryIds };
}

/**
 * Generate category-types.ts
 * Client-safe type exports without Zod schema imports
 */
function generateCategoryTypes(categoryIds: string[]): string {
  const categoryList = categoryIds.map((id) => `  '${id}',`).join('\n');

  return `/**
 * Category Types - Client-Safe Exports
 *
 * ⚠️ AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/build/generate-category-artifacts.ts
 * Source: UNIFIED_CATEGORY_REGISTRY in src/lib/config/category-config.ts
 *
 * This file provides type-only exports for CategoryId without importing Zod schemas.
 * This breaks the circular dependency chain:
 *   shared.schema → category-config → collection.schema → shared.schema ❌
 *
 * New architecture:
 *   shared.schema → category-types ✅ (no schema imports)
 *   category-config → all schemas (server-only)
 *
 * **Why This Exists:**
 * - Storybook and client components need CategoryId type
 * - They DON'T need Zod schema validation (server-only)
 * - Importing category-config.ts triggers ALL schema imports = circular dependency
 * - This file provides ONLY the type, no schema imports
 *
 * **To Add a New Category:**
 * 1. Add to UNIFIED_CATEGORY_REGISTRY in category-config.ts
 * 2. Run: npm run generate:categories
 * 3. This file auto-updates!
 *
 * @module lib/config/category-types
 */

/**
 * Valid category IDs
 *
 * Derived from UNIFIED_CATEGORY_REGISTRY at build time.
 * Current categories (${categoryIds.length}):
 * ${categoryIds.map((id) => `- ${id}`).join('\n * ')}
 */
export const VALID_CATEGORIES = [
${categoryList}
] as const;

/**
 * CategoryId - THE ONLY category type
 *
 * Union type of all valid category IDs.
 * This is derived from VALID_CATEGORIES constant (not from schema imports).
 *
 * ONE NAME. ONE CONCEPT. NO ALIASES.
 */
export type CategoryId = (typeof VALID_CATEGORIES)[number];
`;
}

/**
 * Generate ui-constants-categories.ts
 * Badge colors and UI configuration derived from category registry
 */
function generateUIConstantsCategories(
  registry: Record<string, { colorScheme?: string; label?: string }>,
  categoryIds: string[]
): string {
  // Generate badge colors from colorScheme (2-space indentation for Biome)
  const badgeColorEntries = categoryIds
    .map((id) => {
      const config = registry[id];
      const colorScheme = config?.colorScheme || 'primary';

      return `  ${id}: 'bg-${colorScheme}/20 text-${colorScheme} border-${colorScheme}/30',`;
    })
    .join('\n');

  // Generate default card behaviors
  const defaultBehaviors = categoryIds
    .filter((id) => id !== 'guides' && id !== 'collections' && id !== 'jobs' && id !== 'changelog')
    .map((id) => `  ${id}: DEFAULT_CONFIG_BEHAVIOR,`)
    .join('\n');

  return `/**
 * UI Constants - Category-Specific Configuration
 *
 * ⚠️ AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/build/generate-category-artifacts.ts
 * Source: UNIFIED_CATEGORY_REGISTRY in src/lib/config/category-config.ts
 *
 * Category-derived UI configuration including badge colors and card behaviors.
 * Split from main ui-constants.ts to enable tree-shaking and prevent server imports.
 *
 * **Why This File Exists:**
 * - Main ui-constants.ts cannot import from category-config (server code)
 * - This file is generated at build time from the registry
 * - Only category-specific configuration (badge colors, behaviors)
 * - Eliminates manual synchronization when adding categories
 *
 * **To Add a New Category:**
 * 1. Add to UNIFIED_CATEGORY_REGISTRY in category-config.ts
 * 2. Run: npm run generate:categories
 * 3. This file auto-updates!
 *
 * @module lib/ui-constants-categories
 */

// ============================================================================
// CARD BEHAVIORS - Category-Driven
// ============================================================================

// Default behavior template for config-based categories
const DEFAULT_CONFIG_BEHAVIOR = {
  showCopyButton: true,
  showViewCount: true,
  showCopyCount: true,
  showRating: true,
  showFeaturedBadge: true,
} as const;

// Default behavior template for guide-like categories
const DEFAULT_GUIDE_BEHAVIOR = {
  showCopyButton: false,
  showViewCount: true,
  showCopyCount: false,
  showRating: true,
  showFeaturedBadge: true,
} as const;

/**
 * Card Behavior Configuration
 *
 * Auto-generated from UNIFIED_CATEGORY_REGISTRY with overrides for special cases.
 * Controls which UI elements appear on content cards (copy button, ratings, etc.).
 *
 * Current categories (${categoryIds.length}): ${categoryIds.join(', ')}
 */
export const CARD_BEHAVIORS = {
  // Default for unknown categories
  default: DEFAULT_CONFIG_BEHAVIOR,

  // Registry categories (auto-generated)
${defaultBehaviors}

  // Guide-like categories (educational content - not copyable)
  guides: DEFAULT_GUIDE_BEHAVIOR,

  // Special case overrides
  collections: {
    showCopyButton: true,
    showViewCount: true,
    showCopyCount: true,
    showRating: false, // Collections don't have ratings (yet)
    showFeaturedBadge: false, // Collections have their own type badges
  },

  jobs: DEFAULT_CONFIG_BEHAVIOR,
  changelog: DEFAULT_GUIDE_BEHAVIOR,
} as const;

/**
 * Type-safe card behavior keys
 */
export type CardBehaviorKey = keyof typeof CARD_BEHAVIORS;

// ============================================================================
// BADGE COLORS - Category-Driven
// ============================================================================

/**
 * Category Badge Colors
 *
 * Auto-generated from UNIFIED_CATEGORY_REGISTRY colorScheme values.
 * Used in DetailSidebar, category badges, and UI components.
 *
 * Color mapping:
${categoryIds
  .map((id) => {
    const config = registry[id];
    return ` * - ${id}: ${config?.colorScheme || 'primary'}`;
  })
  .join('\n')}
 */
export const CATEGORY_BADGE_COLORS = {
  default: 'bg-primary/20 text-primary border-primary/30',

  // Category-specific colors (from UNIFIED_CATEGORY_REGISTRY)
${badgeColorEntries}
} as const;

/**
 * Type-safe category badge color keys
 */
export type CategoryBadgeColorKey = keyof typeof CATEGORY_BADGE_COLORS;
`;
}

// ============================================================================
// File I/O and Drift Detection
// ============================================================================

function writeGeneratedFile(filePath: string, content: string, isDryRun: boolean): void {
  if (isDryRun) {
    console.log(`\n[DRY RUN] Would write to: ${filePath}`);
    console.log('─'.repeat(80));
    console.log(content);
    console.log('─'.repeat(80));
    return;
  }

  // Ensure directory exists
  const dir = join(filePath, '..');
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  writeFileSync(filePath, content, 'utf-8');

  // OPTIMIZATION: Skip Biome formatting during build (saves ~5s per file)
  // Generated files are already well-formatted by templates
  // Run `npm run lint:fix` manually if formatting adjustments needed

  console.log(`✅ Generated: ${filePath}`);
}

function checkDrift(filePath: string, expectedContent: string): boolean {
  if (!existsSync(filePath)) {
    console.error(`❌ DRIFT DETECTED: ${filePath} does not exist`);
    console.error('   Run: npm run generate:categories');
    return true;
  }

  const currentContent = readFileSync(filePath, 'utf-8');

  // Normalize line endings for comparison
  const normalizedCurrent = currentContent.replace(/\r\n/g, '\n').trim();
  const normalizedExpected = expectedContent.replace(/\r\n/g, '\n').trim();

  if (normalizedCurrent !== normalizedExpected) {
    console.error(`❌ DRIFT DETECTED: ${filePath} is out of sync with UNIFIED_CATEGORY_REGISTRY`);
    console.error('   Run: npm run generate:categories');
    return true;
  }

  console.log(`✅ No drift: ${filePath}`);
  return false;
}

// ============================================================================
// Hash-based Caching (Phase 2 Optimization)
// ============================================================================

const CACHE_FILE = join(ROOT, '.next/cache/category-artifacts-hash.json');
const SOURCE_FILE = join(SRC, 'lib/config/category-config.ts');

/**
 * Calculate hash of source file to detect changes
 */
function calculateSourceHash(): string {
  if (!existsSync(SOURCE_FILE)) {
    return 'missing';
  }
  const content = readFileSync(SOURCE_FILE, 'utf-8');
  return createHash('sha256').update(content).digest('hex').substring(0, 12);
}

/**
 * Load cached hash
 */
function loadCachedHash(): string | null {
  if (!existsSync(CACHE_FILE)) {
    return null;
  }
  try {
    const cache = JSON.parse(readFileSync(CACHE_FILE, 'utf-8'));
    return cache.sourceHash || null;
  } catch {
    return null;
  }
}

/**
 * Save hash to cache
 */
function saveCacheHash(sourceHash: string): void {
  const cacheDir = join(ROOT, '.next/cache');
  if (!existsSync(cacheDir)) {
    mkdirSync(cacheDir, { recursive: true });
  }
  writeFileSync(
    CACHE_FILE,
    JSON.stringify(
      {
        sourceHash,
        timestamp: new Date().toISOString(),
        generatedFiles: [CATEGORY_TYPES_FILE, UI_CONSTANTS_CATEGORIES_FILE],
      },
      null,
      2
    )
  );
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  const isDryRun = args.includes('--dry') || args.includes('--dry-run');
  const isCheck = args.includes('--check');

  console.log('🏗️  Category Artifacts Generator\n');

  // OPTIMIZATION: Check if source file changed
  const currentHash = calculateSourceHash();
  const cachedHash = loadCachedHash();

  if (
    !(isCheck || isDryRun) &&
    cachedHash === currentHash &&
    existsSync(CATEGORY_TYPES_FILE) &&
    existsSync(UI_CONSTANTS_CATEGORIES_FILE)
  ) {
    console.log('⚡ SKIP: Category config unchanged');
    console.log(`   Source hash: ${currentHash}`);
    console.log('   → Using cached artifacts');
    console.log('   → Saves ~10 seconds build time\n');
    process.exit(0);
  }

  if (cachedHash && cachedHash !== currentHash) {
    console.log('📊 Category config changed - regenerating artifacts\n');
  }

  try {
    // Load category registry
    console.log('📥 Loading UNIFIED_CATEGORY_REGISTRY...');
    const { registry, categoryIds } = await loadCategoryRegistry();
    console.log(`   Found ${categoryIds.length} categories: ${categoryIds.join(', ')}\n`);

    // Generate artifacts
    console.log('🔨 Generating artifacts...');
    const categoryTypesContent = generateCategoryTypes(categoryIds);
    const uiConstantsCategoriesContent = generateUIConstantsCategories(registry, categoryIds);

    if (isCheck) {
      // Drift detection mode (for CI/CD)
      console.log('\n🔍 Checking for drift...\n');
      const hasDrift1 = checkDrift(CATEGORY_TYPES_FILE, categoryTypesContent);
      const hasDrift2 = checkDrift(UI_CONSTANTS_CATEGORIES_FILE, uiConstantsCategoriesContent);

      if (hasDrift1 || hasDrift2) {
        console.error('\n❌ Drift detected! Generated files are out of sync.');
        console.error('   Fix: npm run generate:categories\n');
        process.exit(1);
      }

      console.log('\n✅ No drift detected - all files in sync!\n');
      return;
    }

    // Write files
    console.log();
    writeGeneratedFile(CATEGORY_TYPES_FILE, categoryTypesContent, isDryRun);
    writeGeneratedFile(UI_CONSTANTS_CATEGORIES_FILE, uiConstantsCategoriesContent, isDryRun);

    if (!isDryRun) {
      // Save hash to cache for next build
      saveCacheHash(currentHash);

      console.log('\n✅ Category artifacts successfully generated!\n');
      console.log('Updated files:');
      console.log(`  - ${CATEGORY_TYPES_FILE}`);
      console.log(`  - ${UI_CONSTANTS_CATEGORIES_FILE}\n`);
    }
  } catch (error) {
    console.error('❌ Generation failed:', error);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('❌ Unhandled error in main:', error);
  process.exit(1);
});
