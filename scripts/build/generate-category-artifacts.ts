#!/usr/bin/env tsx
/**
 * Category Artifacts Auto-Generation
 *
 * Generates client-safe TypeScript artifacts derived from UNIFIED_CATEGORY_REGISTRY.
 * Eliminates manual synchronization and ensures category consistency across the codebase.
 *
 * **What This Solves:**
 * Before: 3+ files with hardcoded category arrays that fell out of sync
 * After: Single source of truth (UNIFIED_CATEGORY_REGISTRY) ‚Üí auto-generated artifacts
 *
 * **Generated Files:**
 * 1. src/lib/config/category-types.ts - Client-safe category types (no Zod imports)
 * 2. src/lib/ui-constants-categories.ts - Category badge colors and UI config
 *
 * **Why Split Generation:**
 * - category-types.ts: Imported by Zod schemas (breaks circular dependencies)
 * - ui-constants-categories.ts: Imported by UI components (browser bundle optimization)
 *
 * **Architecture Benefits:**
 * - Zero manual synchronization (add category to registry ‚Üí everything updates)
 * - Type-safe (TypeScript validates all references)
 * - Tree-shakeable (only used categories included in bundle)
 * - No server imports in client code (Storybook compatible)
 *
 * Usage:
 *   npm run generate:categories       # Generate all artifacts
 *   npm run generate:categories --check # Drift detection (CI/CD)
 *   npm run generate:categories --dry   # Preview without writing
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = fileURLToPath(new URL('.', import.meta.url));
const ROOT = join(__dirname, '../..');
const SRC = join(ROOT, 'src');

// Output files
const CATEGORY_TYPES_FILE = join(SRC, 'lib/config/category-types.ts');
const UI_CONSTANTS_CATEGORIES_FILE = join(SRC, 'lib/ui-constants-categories.ts');

// ============================================================================
// Generator Functions
// ============================================================================

/**
 * Import UNIFIED_CATEGORY_REGISTRY dynamically
 * We use dynamic import to avoid TypeScript compilation issues
 */
async function loadCategoryRegistry(): Promise<{
  registry: Record<string, any>;
  categoryIds: string[];
}> {
  // Dynamic import from compiled JavaScript (not TypeScript)
  const configModule = await import('../../src/lib/config/category-config.js');

  const registry = configModule.UNIFIED_CATEGORY_REGISTRY;
  const categoryIds = configModule.getAllCategoryIds();

  if (!(registry && categoryIds) || categoryIds.length === 0) {
    throw new Error('Failed to load UNIFIED_CATEGORY_REGISTRY');
  }

  return { registry, categoryIds };
}

/**
 * Generate category-types.ts
 * Client-safe type exports without Zod schema imports
 */
function generateCategoryTypes(categoryIds: string[]): string {
  const categoryList = categoryIds.map((id) => `  '${id}',`).join('\n');

  return `/**
 * Category Types - Client-Safe Exports
 *
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/build/generate-category-artifacts.ts
 * Source: UNIFIED_CATEGORY_REGISTRY in src/lib/config/category-config.ts
 *
 * This file provides type-only exports for CategoryId without importing Zod schemas.
 * This breaks the circular dependency chain:
 *   shared.schema ‚Üí category-config ‚Üí collection.schema ‚Üí shared.schema ‚ùå
 *
 * New architecture:
 *   shared.schema ‚Üí category-types ‚úÖ (no schema imports)
 *   category-config ‚Üí all schemas (server-only)
 *
 * **Why This Exists:**
 * - Storybook and client components need CategoryId type
 * - They DON'T need Zod schema validation (server-only)
 * - Importing category-config.ts triggers ALL schema imports = circular dependency
 * - This file provides ONLY the type, no schema imports
 *
 * **To Add a New Category:**
 * 1. Add to UNIFIED_CATEGORY_REGISTRY in category-config.ts
 * 2. Run: npm run generate:categories
 * 3. This file auto-updates!
 *
 * @module lib/config/category-types
 */

/**
 * Valid category IDs
 *
 * Derived from UNIFIED_CATEGORY_REGISTRY at build time.
 * Current categories (${categoryIds.length}):
 * ${categoryIds.map((id) => `- ${id}`).join('\n * ')}
 */
export const VALID_CATEGORIES = [
${categoryList}
] as const;

/**
 * CategoryId - THE ONLY category type
 *
 * Union type of all valid category IDs.
 * This is derived from VALID_CATEGORIES constant (not from schema imports).
 *
 * ONE NAME. ONE CONCEPT. NO ALIASES.
 */
export type CategoryId = (typeof VALID_CATEGORIES)[number];
`;
}

/**
 * Generate ui-constants-categories.ts
 * Badge colors and UI configuration derived from category registry
 */
function generateUIConstantsCategories(
  registry: Record<string, any>,
  categoryIds: string[]
): string {
  // Generate badge colors from colorScheme
  const badgeColorEntries = categoryIds
    .map((id) => {
      const config = registry[id];
      const colorScheme = config?.colorScheme || 'primary';

      // Extract color name from scheme (e.g., 'purple-500' ‚Üí 'purple')
      const colorName = colorScheme.split('-')[0];

      return `    ${id}: 'bg-${colorScheme}/20 text-${colorScheme} border-${colorScheme}/30',`;
    })
    .join('\n');

  // Generate default card behaviors
  const defaultBehaviors = categoryIds
    .filter((id) => id !== 'guides' && id !== 'collections' && id !== 'jobs' && id !== 'changelog')
    .map((id) => `  ${id}: DEFAULT_CONFIG_BEHAVIOR,`)
    .join('\n');

  return `/**
 * UI Constants - Category-Specific Configuration
 *
 * ‚ö†Ô∏è AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/build/generate-category-artifacts.ts
 * Source: UNIFIED_CATEGORY_REGISTRY in src/lib/config/category-config.ts
 *
 * Category-derived UI configuration including badge colors and card behaviors.
 * Split from main ui-constants.ts to enable tree-shaking and prevent server imports.
 *
 * **Why This File Exists:**
 * - Main ui-constants.ts cannot import from category-config (server code)
 * - This file is generated at build time from the registry
 * - Only category-specific configuration (badge colors, behaviors)
 * - Eliminates manual synchronization when adding categories
 *
 * **To Add a New Category:**
 * 1. Add to UNIFIED_CATEGORY_REGISTRY in category-config.ts
 * 2. Run: npm run generate:categories
 * 3. This file auto-updates!
 *
 * @module lib/ui-constants-categories
 */

// ============================================================================
// CARD BEHAVIORS - Category-Driven
// ============================================================================

// Default behavior template for config-based categories
const DEFAULT_CONFIG_BEHAVIOR = {
  showCopyButton: true,
  showViewCount: true,
  showCopyCount: true,
  showRating: true,
  showFeaturedBadge: true,
} as const;

// Default behavior template for guide-like categories
const DEFAULT_GUIDE_BEHAVIOR = {
  showCopyButton: false,
  showViewCount: true,
  showCopyCount: false,
  showRating: true,
  showFeaturedBadge: true,
} as const;

/**
 * Card Behavior Configuration
 *
 * Auto-generated from UNIFIED_CATEGORY_REGISTRY with overrides for special cases.
 * Controls which UI elements appear on content cards (copy button, ratings, etc.).
 *
 * Current categories (${categoryIds.length}): ${categoryIds.join(', ')}
 */
export const CARD_BEHAVIORS = {
  // Default for unknown categories
  default: DEFAULT_CONFIG_BEHAVIOR,

  // Registry categories (auto-generated)
${defaultBehaviors}

  // Guide-like categories (educational content - not copyable)
  guides: DEFAULT_GUIDE_BEHAVIOR,

  // Special case overrides
  collections: {
    showCopyButton: true,
    showViewCount: true,
    showCopyCount: true,
    showRating: false, // Collections don't have ratings (yet)
    showFeaturedBadge: false, // Collections have their own type badges
  },

  jobs: DEFAULT_CONFIG_BEHAVIOR,
  changelog: DEFAULT_GUIDE_BEHAVIOR,
} as const;

/**
 * Type-safe card behavior keys
 */
export type CardBehaviorKey = keyof typeof CARD_BEHAVIORS;

// ============================================================================
// BADGE COLORS - Category-Driven
// ============================================================================

/**
 * Category Badge Colors
 *
 * Auto-generated from UNIFIED_CATEGORY_REGISTRY colorScheme values.
 * Used in DetailSidebar, category badges, and UI components.
 *
 * Color mapping:
${categoryIds
  .map((id) => {
    const config = registry[id];
    return ` * - ${id}: ${config?.colorScheme || 'primary'}`;
  })
  .join('\n')}
 */
export const CATEGORY_BADGE_COLORS = {
  default: 'bg-primary/20 text-primary border-primary/30',

  // Category-specific colors (from UNIFIED_CATEGORY_REGISTRY)
${badgeColorEntries}
} as const;

/**
 * Type-safe category badge color keys
 */
export type CategoryBadgeColorKey = keyof typeof CATEGORY_BADGE_COLORS;
`;
}

// ============================================================================
// File I/O and Drift Detection
// ============================================================================

function writeGeneratedFile(filePath: string, content: string, isDryRun: boolean): void {
  if (isDryRun) {
    console.log(`\n[DRY RUN] Would write to: ${filePath}`);
    console.log('‚îÄ'.repeat(80));
    console.log(content);
    console.log('‚îÄ'.repeat(80));
    return;
  }

  // Ensure directory exists
  const dir = join(filePath, '..');
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  writeFileSync(filePath, content, 'utf-8');
  console.log(`‚úÖ Generated: ${filePath}`);
}

function checkDrift(filePath: string, expectedContent: string): boolean {
  if (!existsSync(filePath)) {
    console.error(`‚ùå DRIFT DETECTED: ${filePath} does not exist`);
    console.error('   Run: npm run generate:categories');
    return true;
  }

  const currentContent = readFileSync(filePath, 'utf-8');

  // Normalize line endings for comparison
  const normalizedCurrent = currentContent.replace(/\r\n/g, '\n').trim();
  const normalizedExpected = expectedContent.replace(/\r\n/g, '\n').trim();

  if (normalizedCurrent !== normalizedExpected) {
    console.error(`‚ùå DRIFT DETECTED: ${filePath} is out of sync with UNIFIED_CATEGORY_REGISTRY`);
    console.error('   Run: npm run generate:categories');
    return true;
  }

  console.log(`‚úÖ No drift: ${filePath}`);
  return false;
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  const isDryRun = args.includes('--dry') || args.includes('--dry-run');
  const isCheck = args.includes('--check');

  console.log('üèóÔ∏è  Category Artifacts Generator\n');

  try {
    // Load category registry
    console.log('üì• Loading UNIFIED_CATEGORY_REGISTRY...');
    const { registry, categoryIds } = await loadCategoryRegistry();
    console.log(`   Found ${categoryIds.length} categories: ${categoryIds.join(', ')}\n`);

    // Generate artifacts
    console.log('üî® Generating artifacts...');
    const categoryTypesContent = generateCategoryTypes(categoryIds);
    const uiConstantsCategoriesContent = generateUIConstantsCategories(registry, categoryIds);

    if (isCheck) {
      // Drift detection mode (for CI/CD)
      console.log('\nüîç Checking for drift...\n');
      const hasDrift1 = checkDrift(CATEGORY_TYPES_FILE, categoryTypesContent);
      const hasDrift2 = checkDrift(UI_CONSTANTS_CATEGORIES_FILE, uiConstantsCategoriesContent);

      if (hasDrift1 || hasDrift2) {
        console.error('\n‚ùå Drift detected! Generated files are out of sync.');
        console.error('   Fix: npm run generate:categories\n');
        process.exit(1);
      }

      console.log('\n‚úÖ No drift detected - all files in sync!\n');
      return;
    }

    // Write files
    console.log();
    writeGeneratedFile(CATEGORY_TYPES_FILE, categoryTypesContent, isDryRun);
    writeGeneratedFile(UI_CONSTANTS_CATEGORIES_FILE, uiConstantsCategoriesContent, isDryRun);

    if (!isDryRun) {
      console.log('\n‚úÖ Category artifacts successfully generated!\n');
      console.log('Updated files:');
      console.log(`  - ${CATEGORY_TYPES_FILE}`);
      console.log(`  - ${UI_CONSTANTS_CATEGORIES_FILE}\n`);
    }
  } catch (error) {
    console.error('‚ùå Generation failed:', error);
    process.exit(1);
  }
}

main();
