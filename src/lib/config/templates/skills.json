[
  {
    "type": "skill",
    "id": "react-testing-library",
    "name": "React Testing Library Best Practices",
    "description": "Comprehensive guide for writing maintainable tests with React Testing Library",
    "category": "Testing",
    "tags": "react, testing, best-practices, frontend",
    "skillContent": "# React Testing Library Best Practices\n\n## Overview\nReact Testing Library (RTL) encourages writing tests that closely resemble how users interact with your application. This guide covers best practices for writing maintainable, user-centric tests.\n\n## Core Principles\n\n1. **Query by accessibility attributes first**\n   - Prefer `getByRole`, `getByLabelText`, `getByPlaceholderText`\n   - Avoid `getByTestId` unless absolutely necessary\n\n2. **Test user behavior, not implementation details**\n   - Focus on what the user sees and does\n   - Don't test component state directly\n\n3. **Use user-event over fireEvent**\n   - `userEvent` simulates real user interactions more accurately\n   - Includes keyboard navigation, focus management, etc.\n\n## Example: Testing a Form\n\n```typescript\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { LoginForm } from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits form with user credentials', async () => {\n    const user = userEvent.setup();\n    const onSubmit = vi.fn();\n    \n    render(<LoginForm onSubmit={onSubmit} />);\n    \n    // Query by label text (accessibility)\n    const emailInput = screen.getByLabelText(/email/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    const submitButton = screen.getByRole('button', { name: /sign in/i });\n    \n    // Simulate user interaction\n    await user.type(emailInput, 'user@example.com');\n    await user.type(passwordInput, 'password123');\n    await user.click(submitButton);\n    \n    // Assert on behavior\n    expect(onSubmit).toHaveBeenCalledWith({\n      email: 'user@example.com',\n      password: 'password123',\n    });\n  });\n});\n```\n\n## Common Pitfalls\n\n1. **Avoid querying by class names or IDs**\n   ```typescript\n   // ❌ Bad\n   const button = container.querySelector('.submit-button');\n   \n   // ✅ Good\n   const button = screen.getByRole('button', { name: /submit/i });\n   ```\n\n2. **Don't use waitFor for everything**\n   ```typescript\n   // ❌ Bad\n   await waitFor(() => expect(screen.getByText('Success')).toBeInTheDocument());\n   \n   // ✅ Good\n   expect(await screen.findByText('Success')).toBeInTheDocument();\n   ```\n\n3. **Test loading and error states**\n   ```typescript\n   it('displays loading state', () => {\n     render(<DataComponent isLoading />);\n     expect(screen.getByRole('status')).toHaveTextContent('Loading...');\n   });\n   \n   it('displays error message', () => {\n     render(<DataComponent error=\"Failed to load\" />);\n     expect(screen.getByRole('alert')).toHaveTextContent('Failed to load');\n   });\n   ```\n\n## Advanced Patterns\n\n### Custom Render Function\n```typescript\nfunction renderWithProviders(ui: React.ReactElement, options = {}) {\n  return render(ui, {\n    wrapper: ({ children }) => (\n      <QueryClientProvider client={queryClient}>\n        <ThemeProvider>\n          {children}\n        </ThemeProvider>\n      </QueryClientProvider>\n    ),\n    ...options,\n  });\n}\n```\n\n### Testing Async Components\n```typescript\nit('loads and displays user data', async () => {\n  render(<UserProfile userId=\"123\" />);\n  \n  // Wait for loading to finish\n  expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  \n  // Find elements that appear after async operation\n  const userName = await screen.findByText('John Doe');\n  expect(userName).toBeInTheDocument();\n});\n```\n\n## Resources\n- [Testing Library Docs](https://testing-library.com/react)\n- [Common Mistakes](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)\n- [Query Priority Guide](https://testing-library.com/docs/queries/about#priority)",
    "requirements": "React 18+, @testing-library/react, @testing-library/user-event, vitest or jest",
    "installation": "npm install --save-dev @testing-library/react @testing-library/user-event @testing-library/jest-dom\n\n# Add to your test setup file:\nimport '@testing-library/jest-dom';\n\n# Configure vitest.config.ts:\nexport default defineConfig({\n  test: {\n    environment: 'jsdom',\n    setupFiles: ['./tests/setup.ts'],\n  },\n});"
  },
  {
    "type": "skill",
    "id": "next-server-actions",
    "name": "Next.js Server Actions Patterns",
    "description": "Production-ready patterns for Next.js Server Actions with validation and error handling",
    "category": "Next.js",
    "tags": "nextjs, server-actions, forms, validation",
    "skillContent": "# Next.js Server Actions - Production Patterns\n\n## Overview\nServer Actions in Next.js 15 provide a powerful way to handle mutations directly from React components. This guide covers production-ready patterns with proper validation, error handling, and type safety.\n\n## Basic Server Action\n\n```typescript\n'use server';\n\nimport { z } from 'zod';\nimport { revalidatePath } from 'next/cache';\n\n// Define validation schema\nconst createUserSchema = z.object({\n  name: z.string().min(2).max(100),\n  email: z.string().email(),\n  age: z.number().int().min(18).max(120),\n});\n\nexport async function createUser(formData: FormData) {\n  // 1. Extract and validate data\n  const rawData = {\n    name: formData.get('name'),\n    email: formData.get('email'),\n    age: Number(formData.get('age')),\n  };\n  \n  const result = createUserSchema.safeParse(rawData);\n  \n  if (!result.success) {\n    return {\n      success: false,\n      errors: result.error.flatten().fieldErrors,\n    };\n  }\n  \n  // 2. Perform database operation\n  try {\n    await db.user.create({\n      data: result.data,\n    });\n    \n    // 3. Revalidate relevant paths\n    revalidatePath('/users');\n    \n    return { success: true };\n  } catch (error) {\n    return {\n      success: false,\n      errors: { _form: ['Failed to create user'] },\n    };\n  }\n}\n```\n\n## Client Component Usage\n\n```typescript\n'use client';\n\nimport { useActionState } from 'react';\nimport { createUser } from './actions';\n\nexport function UserForm() {\n  const [state, formAction, isPending] = useActionState(\n    createUser,\n    { success: false }\n  );\n  \n  return (\n    <form action={formAction}>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input\n          id=\"name\"\n          name=\"name\"\n          required\n          aria-invalid={!!state.errors?.name}\n        />\n        {state.errors?.name && (\n          <p className=\"error\">{state.errors.name[0]}</p>\n        )}\n      </div>\n      \n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          name=\"email\"\n          type=\"email\"\n          required\n          aria-invalid={!!state.errors?.email}\n        />\n        {state.errors?.email && (\n          <p className=\"error\">{state.errors.email[0]}</p>\n        )}\n      </div>\n      \n      <button type=\"submit\" disabled={isPending}>\n        {isPending ? 'Creating...' : 'Create User'}\n      </button>\n      \n      {state.errors?._form && (\n        <p className=\"error\">{state.errors._form[0]}</p>\n      )}\n      \n      {state.success && <p className=\"success\">User created!</p>}\n    </form>\n  );\n}\n```\n\n## Advanced Patterns\n\n### Optimistic Updates\n```typescript\n'use client';\n\nimport { useOptimistic } from 'react';\nimport { toggleTodo } from './actions';\n\nexport function TodoList({ todos }: { todos: Todo[] }) {\n  const [optimisticTodos, addOptimisticTodo] = useOptimistic(\n    todos,\n    (state, newTodo: Todo) => [...state, newTodo]\n  );\n  \n  async function handleToggle(id: string) {\n    // Update UI immediately\n    addOptimisticTodo({ id, completed: true });\n    \n    // Perform server action\n    await toggleTodo(id);\n  }\n  \n  return (\n    <ul>\n      {optimisticTodos.map((todo) => (\n        <li key={todo.id}>\n          <input\n            type=\"checkbox\"\n            checked={todo.completed}\n            onChange={() => handleToggle(todo.id)}\n          />\n          {todo.title}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### Type-Safe Actions with Discriminated Unions\n```typescript\ntype ActionResult<T> =\n  | { success: true; data: T }\n  | { success: false; errors: Record<string, string[]> };\n\nexport async function createUser(\n  formData: FormData\n): Promise<ActionResult<User>> {\n  // Implementation...\n}\n```\n\n## Best Practices\n\n1. **Always validate input** - Never trust client data\n2. **Use Zod or similar** - Type-safe runtime validation\n3. **Handle errors gracefully** - Return structured error objects\n4. **Revalidate cache** - Use `revalidatePath()` or `revalidateTag()`\n5. **Consider rate limiting** - Protect against abuse\n6. **Add loading states** - Use `isPending` from useActionState\n7. **Use optimistic updates** - For better UX on slow networks\n\n## Common Pitfalls\n\n1. **Don't forget 'use server'** - Must be at top of file or function\n2. **Don't return non-serializable data** - Functions, Dates, etc.\n3. **Don't perform redirects in try/catch** - Will throw an error\n4. **Always handle FormData correctly** - Use .get() not bracket notation",
    "requirements": "Next.js 15+, React 19+, Zod, TypeScript",
    "installation": "# Ensure you're using Next.js 15+\nnpm install next@latest react@latest react-dom@latest\n\n# Install Zod for validation\nnpm install zod\n\n# Configure next.config.js (if needed):\nmodule.exports = {\n  experimental: {\n    serverActions: {\n      bodySizeLimit: '2mb',\n    },\n  },\n};"
  }
]
