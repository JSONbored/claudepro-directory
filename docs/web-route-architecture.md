# Next.js Route Architecture Assessment — 2025-11-24

This document summarizes the current rendering/runtime characteristics of the major routes in `apps/web`, recommends an updated strategy for balancing performance and maintainability, and outlines the follow-up work required to implement the plan.

## 1. Route Inventory

| Route group | Example paths | Current runtime & config | Data sources & personalization | Cache behavior | Blockers for SSG/ISR |
| --- | --- | --- | --- | --- | --- |
| **Home** | `/` | Node runtime (default). No `dynamic` flag. `HomeContentSection` is a server component, `RecentlyViewedRail` is client-only. | `getHomepageData`, `getSearchFacets`, `getHomepageCategoryIds`, featured jobs/contributors (all anonymous, Supabase RPCs). No cookies or request-only state. | `fetchCached` uses `cache.homepage.ttl_seconds = 3600` and `cache.search_facets.ttl_seconds = 3600`. Page itself lacks `revalidate`, so HTML is rebuilt only on deploy. | None. Data is deterministic and already cached. Only heavy animation components are dynamically imported. |
| **Search** | `/search` | Node runtime, `export const dynamic = 'force-dynamic';`. Pure server component shell + `RecentlyViewedSidebar` in Suspense. | `searchContent` (per-query RPC), `getSearchFacets`, `getHomepageData` for zero-state suggestions. No cookies or user-specific branching; depends on `searchParams`. | `searchContent` leverages `fetchCached` with `cache.content_list.ttl_seconds = 1800` per query. Facets/homepage data share the same caches as the home route. The page itself is uncached because of `force-dynamic`. | Query permutations require request-time data for results, but the static hero + zero-state UI could use PPR/ISR. The `feature-flags` concern noted in the file is a false positive—this page never imports `featureFlags`. |
| **Category list** | `/agents`, `/mcp`, `/commands`, etc. | Node runtime, `dynamic = 'force-dynamic'`. | `getCategoryConfig` (React `cache`), `getContentByCategory` (`fetchCached` RPC). No personalization. | Data cached for 30 min via `cache.content_list.ttl_seconds = 1800`. HTML is always recomputed because of `force-dynamic`. | Only 8 categories exist, so `generateStaticParams` + ISR would work. `featureFlags` are not referenced; the current `dynamic` flag is defensive rather than required. |
| **Detail** | `/[category]/[slug]` (e.g. `/agents/autonomous-researcher`) | Dynamic segment without `generateStaticParams`, so Next.js renders per-request on Node. Core content fetched synchronously; analytics/related data fetched via Suspense for pseudo-PPR. | `getContentDetailCore`, `getContentAnalytics`, `getRelatedContent`, optional lazy import of `featureFlags.contentDetailTabs`. No cookies. Client personalization limited to recently viewed tracker (localStorage). | `fetchCached` TTL is 7200 s for both core and analytics. Route HTML is not cached (`revalidate` unset) even though `api/revalidate` invalidates paths. | High slug cardinality makes fully static generation impractical, but ISR per slug is viable if `revalidate` is defined. Need to ensure `featureFlags` stays lazily imported. |
| **Account area** | `/account`, `/account/library`, `/account/settings`, `/account/jobs/**` | Node runtime, `dynamic = 'force-dynamic'`. Nested routes reuse the same pattern. | Requires `getAuthenticatedUser` (cookies), `getAccountDashboard`, `getUserLibrary`, `getUserCompanies`, etc. All flagged with `useAuth` Supabase clients. | User-scoped caches rely on `cache.account.ttl_seconds = 300` with tags (`user-${id}`), but HTML is never cached. | Legitimate need for SSR: cookie-based auth, user-specific hydration, server actions assumed to run on Node (Supabase SSR client is not Edge compatible). |
| **Jobs** | `/jobs` | Node runtime, `dynamic = 'force-dynamic'`, `revalidate = false` (explicitly disables ISR). | `getFilteredJobs` (SearchService RPC) keyed by query/filter params; newsletter CTA + promos are client-side. | RPC output cached for 30 min via `cache.jobs.ttl_seconds`, including filtered variants. Route HTML is re-rendered every hit. | Needs request-time data for arbitrary filter combinations, but the hero and default feed can be statically prerendered. `force-dynamic` blocks Partial Prerendering of the static shell. |
| **Marketing/Content hubs** | `/community`, `/companies`, `/partner`, `/contact`, `/commands`, `/collections`, `/consulting`, etc. | Almost every page sets `dynamic = 'force-dynamic'` despite only using deterministic data. | Mix of `getCommunityDirectory`, `getCompaniesList`, `getHomepageData`, `getContactChannels`, static copy. No cookies or personalization. | RPCs cached for 30–60 min (`cache.company_list`, `cache.community`, `cache.homepage`). Pages themselves are never cached. | The only cited blocker is the fear of importing `feature-flags/flags.ts`. These routes never touch flags, so ISR/SSG is safe once the redundant `dynamic` flags are removed. |
| **API routes** | `/api/templates`, `/api/stats/social-proof`, `/api/og`, `/api/revalidate` | `/api/og` sets `runtime = 'edge'`; the others implicitly run on Node. `stats/social-proof` sets `revalidate = 300`. | All handlers call Supabase RPCs or Next cache APIs; `/api/revalidate` checks `REVALIDATE_SECRET`. No per-user personalization. | `/api/templates` and `/api/stats/social-proof` emit `Cache-Control: public, s-maxage=300, stale-while-revalidate=600`. `/api/og` is uncached; `/api/revalidate` is always uncached. | Supabase server client usage forces Node runtime except for the OG image generator. Lacking explicit `runtime = 'nodejs'` can lead to accidental Edge deployment. |

## 2. Recommended Rendering Strategy

| Route group | Suggested mode | `revalidate` / cache tags | Required refactors & notes | Trade-offs |
| --- | --- | --- | --- | --- |
| **Home** | Keep static HTML but adopt Partial Prerendering for heavy sections. | Add `export const revalidate = 1800` and ensure `getHomepageData` tags (`homepage`, `content`) match `api/revalidate`. | Lift hero copy + CTA into the static portion, wrap `HomeContentSection` and newsletter CTA in `Suspense` to enable streaming when Next 15 PPR graduates. | Slightly longer build if Supabase becomes unavailable during CI; mitigated by falling back to cached data in `fetchCached`. |
| **Search** | SSR + streaming (`dynamic = 'force-dynamic'`) but split zero-state data into cached segments. | Annotate the `searchContent` call with `cache: 'no-store'` and reuse `fetchCached` only for zero-state suggestions. Continue tagging facets with `search-facets`. | Only load `getHomepageData` when `!query && !hasFilters`; move fallback suggestions behind `Promise.allSettled`; stream the `RecentlyViewedSidebar` via `Suspense`. Document that `dynamic` is required for query permutations, not for feature flags. | Still incurs SSR cost per query, but streaming reduces FCP and avoids blocking on fallback suggestions. |
| **Category list** | Switch to ISR (static HTML per category). | Set `export const dynamicParams = false` and `export const revalidate = 1800`, add `generateStaticParams` from `getAllCategoryIds`. Tags already include `content`. | Remove the defensive `dynamic` flag after confirming no direct `featureFlags` imports. Ensure `api/revalidate` calls `revalidatePath('/agents')` etc after content changes. | Slightly slower redeploy when category configs change, but on-demand revalidate already exists. |
| **Detail** | ISR per slug + Partial Prerendering for analytics (already in place). | Add `export const revalidate = 7200` to align with `cache.content_detail`. Keep data fetches using cache tags `generateContentTags`. | Because slug count is high, rely on on-demand ISR: `api/revalidate` already calls `revalidatePath('/{category}/{slug}')`, which will now bust route cache as well as data cache. Consider `Segment config { dynamic = 'auto' }` plus `Suspense` for analytics. | Cache size grows with number of viewed slugs; monitor `Route Cache` storage and purge via `revalidateTag` if needed. |
| **Account area** | Continue SSR with Node runtime. | Keep `cache.account.ttl_seconds = 300`; expose `export const runtime = 'nodejs'` on each account route to prevent accidental Edge builds. | Consolidate shared dashboard queries into a single helper (`getAccountDashboardBundle`) that wraps `Promise.allSettled`, so account subroutes can reuse cached results without re-hitting Supabase. Add structured logging for cache hits/misses. | Still incur per-user SSR cost, but cached RPC responses will reduce Supabase load. |
| **Jobs** | Hybrid: static hero/filter shell (ISR 15 min) + streaming results. | Add `export const revalidate = 900` for the base route, move job result grid into a deferred server component that fetches with `cache: 'no-store'` when filters are applied. Keep zero-state list cached via `fetchCached`. | Introduce a `JobsResultSection` that accepts params and uses `Suspense` so the static hero renders immediately. Default `/jobs` path can be prebuilt; filtered queries stay SSR. | Requires wiring `searchParams` into the deferred component, but drastically cuts TTFB for first-time visitors hitting `/jobs`. |
| **Marketing/Content hubs** | Static/ISR (1 h) with optional client-side hydration for interactive pieces. | Add `export const revalidate = 3600` per page and remove unnecessary `dynamic` flags. Ensure data helpers keep tagging (`companies`, `community`). | If a page truly needs feature flags (e.g., `contact` terminal), isolate that section in a client component that calls a server action for flag evaluation instead of pulling flags at the page level. | Static HTML reduces Lambda invocations; just document the rare cases that still require SSR. |
| **API routes** | Explicit runtimes + aligned caching headers. | Add `export const runtime = 'nodejs'` to `/api/templates`, `/api/stats/social-proof`, `/api/revalidate`. Confirm their `Cache-Control` headers mirror the TTL from `fetchCached`. | For `/api/stats/social-proof`, return `ETag`/`Last-Modified` to improve CDN hit rate. `/api/revalidate` should log tag/path invalidations so we can correlate with ISR caches. | Explicit runtime settings prevent accidental Edge deployment failures and make observability clearer. |

## 3. Refactor Workplan (prioritized)

1. **Unblock ISR for category + marketing routes**
   - Remove the unnecessary `dynamic = 'force-dynamic'` lines and add `revalidate`/`generateStaticParams` where applicable (`apps/web/src/app/[category]/page.tsx`, `community/page.tsx`, `companies/page.tsx`, etc.).
   - Verify with `pnpm --filter web build` and `pnpm --filter web lint` to ensure the static analyzer no longer complains about `feature-flags`.
   - Monitoring: confirm Vercel “Prerendered Routes” list now includes these paths and that `api/revalidate` invalidates them.

2. **Align page-level caching with data-layer TTLs**
   - Home (`page.tsx`), detail (`[slug]/page.tsx`), jobs (`page.tsx`), and marketing pages should export the same `revalidate` interval as their corresponding `cache.*.ttl_seconds`.
   - Update `api/revalidate` to abort early if neither `revalidatePath` nor `revalidateTag` is applicable, and add logging for cache tag invalidations.
   - Tests: run `pnpm --filter web test` plus targeted integration (e.g., hit `/api/revalidate` in CI with a mock secret).

3. **Search page streaming + conditional data fetch**
   - Gate the expensive `getHomepageData` call (`apps/web/src/app/search/page.tsx`) behind `if (!query && !hasFilters)`.
   - Break the result grid into a separate async component rendered inside `Suspense` so zero-state UI streams immediately.
   - Add telemetry around cache hit rates for `searchContent` (existing `logger.info` payloads already include filter metadata; ensure they reach the analytics sink).

4. **Detail page ISR & PPR polish**
   - Introduce `export const revalidate = 7200` and ensure `getContentDetailCore`/`getContentAnalytics` continue to use shared cache tags.
   - Adopt the official Next.js Partial Prerendering API once the project moves to Next ≥15.1: render hero + metadata statically, stream analytics/related rails.
   - Monitoring: track Route Cache hit rate via `VERCEL_ANALYTICS_ID` or custom logs.

5. **Account + jobs runtime hardening**
   - Add `export const runtime = 'nodejs'` to every file in `apps/web/src/app/account/**` and `apps/web/src/app/jobs/**` to prevent accidental Edge deployment (Supabase SSR client depends on Node APIs).
   - Consolidate dashboard fetches into a shared helper and memoize by user ID so nested account pages can reuse cached responses during one request.
   - Tests: add smoke tests hitting `/account` with mocked auth cookies (existing integration harness) and `/jobs` filter permutations.

6. **API route observability**
   - Emit structured JSON logs for `/api/revalidate`, `/api/templates`, and `/api/stats/social-proof` including cache tags, TTL, and duration.
   - Add synthetic checks (e.g., `pnpm --filter edge test` or dedicated cron) to ensure these routes stay within expected latency and 2xx rates.

## 4. Future-proofing Guidelines

- **Default to SSG/ISR for anonymous pages.** Require an explicit reason (cookies, per-user feature flags, streaming search results) before setting `dynamic = 'force-dynamic'`. Document the reason inline so future reviewers know why SSR is unavoidable.
- **Isolate feature flag imports.** Keep `featureFlags` confined to dedicated helpers (e.g., `getLayoutFlags`) and access them via server actions or client-side calls when needed. This avoids accidental coupling between a marketing page and the `flags/next` SDK.
- **Match route `revalidate` values with data-layer TTLs.** When using `fetchCached`, pick cache tags and TTLs from `cache_configs` and mirror them in the Next.js route. This keeps `revalidatePath`/`revalidateTag` effective and prevents stale HTML even when data caches are fresh.
- **Adopt Partial Prerendering for mixed workloads.** Pages like home, detail, and jobs have heavy interactive sections that benefit from streaming; wrap non-critical data in `Suspense` and opt into PPR once the project upgrades to a Next.js version where it’s stable.
- **Prefer server actions or API routes for personalized widgets.** Instead of making whole pages dynamic for small personalized elements, lift those pieces into client components that call a server action (e.g., notifications, contact terminal). This keeps the outer route eligible for ISR.
- **Instrument cache hit rates.** Use existing `logger` metadata plus Vercel Analytics to monitor cache tags (`homepage`, `content`, `jobs-list`, etc.) so regressions in hit rate can be caught before they cause elevated Supabase load.
