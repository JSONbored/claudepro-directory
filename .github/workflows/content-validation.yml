name: Content Validation

on:
  pull_request:
    paths:
      - 'content/**/*.json'
      - 'content/guides/**/*.mdx'
      - 'scripts/validate-content.ts'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-and-label:
    name: Validate Content & Auto-label
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Setup Node.js with dependencies
      uses: ./.github/actions/setup-node-deps
      with:
        production-only: 'true'
        skip-build-content: 'true'

    - name: Get changed content files
      id: changed
      uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62 # v47 (pinned for security)
      with:
        files: |
          content/**/*.json
          content/guides/**/*.mdx

    - name: Validate content schema
      if: steps.changed.outputs.any_changed == 'true'
      run: |
        echo "Validating changed content files..."
        for file in ${{ steps.changed.outputs.all_changed_files }}; do
          echo "Validating $file"
          npx tsx scripts/validate-content.ts "$file"
        done

    - name: Check content metadata
      if: steps.changed.outputs.any_changed == 'true'
      run: |
        for file in ${{ steps.changed.outputs.all_changed_files }}; do
          # Skip non-JSON files
          [[ "$file" != *.json ]] && continue

          echo "Checking metadata for $file..."

          # Check required fields based on category
          category=$(jq -r '.category' "$file" 2>/dev/null || echo "")

          # For hooks, agents, rules, commands, statuslines, collections, skills, and mcp, check slug instead of title
          if [[ "$category" == "hooks" || "$category" == "agents" || "$category" == "rules" || "$category" == "commands" || "$category" == "statuslines" || "$category" == "collections" || "$category" == "mcp" || "$category" == "skills" ]]; then
            if ! jq -e '.slug' "$file" > /dev/null; then
              echo "ERROR: Missing slug in $category file $file"
              exit 1
            fi
          else
            # For other content types, check title OR name
            if ! jq -e '.title // .name' "$file" > /dev/null; then
              echo "ERROR: Missing title or name in $file"
              exit 1
            fi
          fi

          # Check common required fields
          required_fields=("description" "category" "author" "dateAdded")
          for field in "${required_fields[@]}"; do
            if ! jq -e ".$field" "$file" > /dev/null; then
              echo "ERROR: Missing $field in $file"
              exit 1
            fi
          done

          # Validate date format (YYYY-MM-DD)
          date=$(jq -r '.dateAdded' "$file")
          if ! echo "$date" | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' > /dev/null; then
            echo "ERROR: Invalid date format in $file (should be YYYY-MM-DD)"
            exit 1
          fi

          # Validate category is valid
          if [[ ! "$category" =~ ^(agents|mcp|rules|commands|hooks|statuslines|collections|skills|guides|tutorials|comparisons|workflows|use-cases|troubleshooting|categories)$ ]]; then
            echo "ERROR: Invalid category '$category' in $file"
            exit 1
          fi

          echo "✓ $file passed validation"
        done

    - name: Build content to verify generation
      if: steps.changed.outputs.any_changed == 'true'
      run: npm run build:content

    - name: Auto-label by content type
      if: steps.changed.outputs.any_changed == 'true'
      uses: actions/github-script@v8
      with:
        script: |
          const fs = require('fs');
          const changedFiles = '${{ steps.changed.outputs.all_changed_files }}'.split(' ').filter(f => f.trim());
          const labels = new Set(['content-submission', 'needs-review']);
          const contentTypes = new Set();

          for (const file of changedFiles) {
            // Detect content type from path
            if (file.includes('/agents/')) {
              labels.add('agent');
              contentTypes.add('agent');
            } else if (file.includes('/mcp/')) {
              labels.add('mcp');
              contentTypes.add('MCP server');
            } else if (file.includes('/hooks/')) {
              labels.add('hook');
              contentTypes.add('hook');
            } else if (file.includes('/commands/')) {
              labels.add('command');
              contentTypes.add('command');
            } else if (file.includes('/rules/')) {
              labels.add('rule');
              contentTypes.add('rule');
            } else if (file.includes('/statuslines/')) {
              labels.add('statusline');
              contentTypes.add('statusline');
            } else if (file.includes('/collections/')) {
              labels.add('collection');
              contentTypes.add('collection');
            } else if (file.includes('/guides/')) {
              labels.add('guide');
              contentTypes.add('guide');
            } else if (file.includes('/skills/')) {
              labels.add('skill');
              contentTypes.add('skill');
            }

            // Try to read JSON files for category validation
            if (file.endsWith('.json')) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                const data = JSON.parse(content);

                if (data.category) {
                  const categoryMap = {
                    'agents': 'agent',
                    'mcp': 'MCP server',
                    'hooks': 'hook',
                    'commands': 'command',
                    'rules': 'rule',
                    'statuslines': 'statusline',
                    'collections': 'collection',
                    'skills': 'skill',
                    'guides': 'guide'
                  };

                  labels.add(data.category);
                  if (categoryMap[data.category]) {
                    contentTypes.add(categoryMap[data.category]);
                  }
                }
              } catch (error) {
                console.log(`Could not parse ${file}:`, error.message);
              }
            }
          }

          // Apply labels
          if (labels.size > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: Array.from(labels)
            });
            console.log(`Applied labels: ${Array.from(labels).join(', ')}`);
          }

          // Add helpful comment for first-time contributors
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });

          const botComment = comments.find(c => c.user.type === 'Bot' && c.body.includes('Auto-validation'));

          if (!botComment && contentTypes.size > 0) {
            const typesList = Array.from(contentTypes).join(', ');
            const message = [
              '## 🤖 Auto-validation',
              '',
              `Thanks for your contribution! I've detected the following content type(s): **${typesList}**`,
              '',
              'The content validation workflow has checked your submission. Please make sure:',
              '- ✅ All required fields are present',
              '- ✅ No API keys or secrets are included',
              '- ✅ The JSON/YAML is valid',
              '- ✅ Dates are in YYYY-MM-DD format',
              '',
              `If you need help, check out the [contribution guide](https://github.com/${context.repo.owner}/${context.repo.repo}#contributing).`
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
          }

    - name: Summary
      if: always()
      run: |
        if [ "${{ steps.changed.outputs.any_changed }}" == "true" ]; then
          echo "### ✅ Content Validation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Validated files:" >> $GITHUB_STEP_SUMMARY
          for file in ${{ steps.changed.outputs.all_changed_files }}; do
            echo "- $file" >> $GITHUB_STEP_SUMMARY
          done
        else
          echo "### ℹ️ No Content Changes" >> $GITHUB_STEP_SUMMARY
          echo "No content files were modified in this PR." >> $GITHUB_STEP_SUMMARY
        fi
