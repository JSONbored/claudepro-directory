{
  "slug": "cache-efficiency-monitor",
  "description": "Claude Code prompt caching efficiency monitor tracking cache hits, write efficiency, and cost savings with visual hit rate indicators and optimization recommendations.",
  "category": "statuslines",
  "author": "JSONbored",
  "dateAdded": "2025-10-25",
  "tags": ["prompt-caching", "cache-efficiency", "cost-savings", "hit-rate", "cache-optimization"],
  "statuslineType": "custom",
  "content": "#!/usr/bin/env bash\n\n# Cache Efficiency Monitor for Claude Code\n# Tracks prompt caching performance and cost savings\n\n# Read JSON from stdin\nread -r input\n\n# Extract cache metrics (if available in JSON)\ncache_read_tokens=$(echo \"$input\" | jq -r '.cost.cache_read_input_tokens // 0')\ncache_create_tokens=$(echo \"$input\" | jq -r '.cost.cache_creation_input_tokens // 0')\nregular_input_tokens=$(echo \"$input\" | jq -r '.cost.input_tokens // 0')\n\n# Calculate total input tokens\ntotal_input=$((cache_read_tokens + cache_create_tokens + regular_input_tokens))\n\n# Avoid division by zero\nif [ $total_input -eq 0 ]; then\n  total_input=1\nfi\n\n# Calculate cache hit rate (percentage of tokens read from cache)\nif [ $cache_read_tokens -gt 0 ]; then\n  cache_hit_rate=$(( (cache_read_tokens * 100) / total_input ))\nelse\n  cache_hit_rate=0\nfi\n\n# Calculate write efficiency (cache creation vs regular input)\nif [ $cache_create_tokens -gt 0 ]; then\n  write_percentage=$(( (cache_create_tokens * 100) / total_input ))\nelse\n  write_percentage=0\nfi\n\n# Cache efficiency scoring\nif [ $cache_hit_rate -ge 50 ]; then\n  CACHE_COLOR=\"\\033[38;5;46m\"   # Green: Excellent caching (>50% hit rate)\n  CACHE_ICON=\"âœ“\"\n  CACHE_STATUS=\"EXCELLENT\"\nelif [ $cache_hit_rate -ge 25 ]; then\n  CACHE_COLOR=\"\\033[38;5;226m\"  # Yellow: Good caching (25-50% hit rate)\n  CACHE_ICON=\"â—\"\n  CACHE_STATUS=\"GOOD\"\nelif [ $cache_hit_rate -gt 0 ]; then\n  CACHE_COLOR=\"\\033[38;5;208m\"  # Orange: Low caching (1-25% hit rate)\n  CACHE_ICON=\"âš \"\n  CACHE_STATUS=\"LOW\"\nelse\n  CACHE_COLOR=\"\\033[38;5;250m\"  # Gray: No caching\n  CACHE_ICON=\"â—‹\"\n  CACHE_STATUS=\"NONE\"\nfi\n\n# Estimate cost savings (cache reads cost 90% less than regular input)\nif [ $cache_read_tokens -gt 0 ]; then\n  # Savings = cache_read_tokens * 0.9 (90% discount)\n  savings_tokens=$(echo \"scale=0; $cache_read_tokens * 0.9 / 1\" | bc)\n  savings_display=\"ðŸ’° ~${savings_tokens} tok saved\"\nelse\n  savings_display=\"\"\nfi\n\n# Build cache hit rate bar (20 characters wide)\nhit_bar_filled=$(( cache_hit_rate / 5 ))  # Each char = 5%\nhit_bar_empty=$(( 20 - hit_bar_filled ))\n\nif [ $hit_bar_filled -gt 0 ]; then\n  hit_bar=$(printf \"â–ˆ%.0s\" $(seq 1 $hit_bar_filled))$(printf \"â–‘%.0s\" $(seq 1 $hit_bar_empty))\nelse\n  hit_bar=\"â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘\"\nfi\n\n# Optimization recommendation\nif [ $cache_hit_rate -eq 0 ] && [ $cache_create_tokens -eq 0 ]; then\n  RECOMMENDATION=\"(Enable caching?)\"\nelif [ $cache_hit_rate -lt 25 ] && [ $write_percentage -gt 50 ]; then\n  RECOMMENDATION=\"(More reads needed)\"\nelse\n  RECOMMENDATION=\"\"\nfi\n\nRESET=\"\\033[0m\"\n\n# Output statusline\nif [ -n \"$savings_display\" ]; then\n  echo -e \"${CACHE_ICON} Cache: ${CACHE_COLOR}${hit_bar}${RESET} ${cache_hit_rate}% | ${savings_display} ${RECOMMENDATION}\"\nelse\n  echo -e \"${CACHE_ICON} Cache: ${CACHE_COLOR}${hit_bar}${RESET} ${cache_hit_rate}% ${RECOMMENDATION}\"\nfi\n",
  "features": [
    "Real-time prompt cache hit rate tracking (percentage of tokens read from cache)",
    "Cache write efficiency monitoring (cache creation vs regular input ratio)",
    "Cost savings estimation based on 90% cache read discount",
    "Visual hit rate bar (20-char progress indicator, each â–ˆ = 5%)",
    "Efficiency scoring (excellent >50%, good 25-50%, low 1-25%, none 0%)",
    "Optimization recommendations (enable caching, increase reuse patterns)",
    "Color-coded status (green excellent, yellow good, orange low, gray none)",
    "Lightweight bash with bc for percentage calculations"
  ],
  "configuration": {
    "format": "bash",
    "refreshInterval": 2000,
    "position": "left"
  },
  "useCases": [
    "Optimizing prompt caching strategy to reduce API costs",
    "Identifying inefficient cache usage patterns (high writes, low reads)",
    "Validating that prompt caching is properly enabled and working",
    "Tracking cost savings from cache utilization",
    "Debugging cache misses in long coding sessions",
    "Comparing caching efficiency across different projects/workflows"
  ],
  "requirements": [
    "Bash shell",
    "jq JSON processor",
    "bc calculator (for percentage calculations)"
  ],
  "preview": "âœ“ Cache: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 60% | ðŸ’° ~4,500 tok saved",
  "troubleshooting": [
    {
      "issue": "Cache hit rate always showing 0% despite caching enabled",
      "solution": "Verify cache fields exist in JSON: echo '$input' | jq '.cost | {cache_read: .cache_read_input_tokens, cache_create: .cache_creation_input_tokens}'. If fields missing, Claude Code version may not expose cache metrics. Check official docs for required version. Caching requires Claude 3.5 Sonnet or Opus with prompt caching feature enabled."
    },
    {
      "issue": "Cost savings calculation showing unrealistic numbers",
      "solution": "Script estimates savings using 90% discount formula (cache reads cost 10% of regular input). Verify cache_read_tokens value: echo '$input' | jq .cost.cache_read_input_tokens. Formula: savings = cache_read_tokens * 0.9. Adjust discount percentage in script if Claude pricing changes."
    },
    {
      "issue": "Recommendation showing 'Enable caching?' when caching is on",
      "solution": "Recommendation triggers when both cache_read_tokens and cache_create_tokens are 0. This means no cache activity detected. Verify prompt caching is configured in Claude Code settings. Check that prompts contain cacheable prefixes (system messages, long contexts). Short sessions may not benefit from caching."
    },
    {
      "issue": "Hit rate bar not displaying correctly or showing as empty",
      "solution": "Ensure terminal supports Unicode block characters (â–ˆ and â–‘). Test with: echo -e 'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘'. Bar uses hit_rate / 5 for scaling (each char = 5%). If hit_rate is 0, shows full empty bar (20x â–‘). Verify cache_hit_rate calculation: (cache_read_tokens * 100) / total_input."
    },
    {
      "issue": "Write efficiency showing 'More reads needed' incorrectly",
      "solution": "Recommendation appears when hit_rate <25% AND write_percentage >50% (creating more cache entries than using them). This indicates inefficient caching pattern. Solution: Reuse prompts more, reduce unique cache writes. Check if session involves many one-off queries vs repeated patterns."
    }
  ],
  "documentationUrl": "https://docs.claude.com/en/docs/claude-code/statusline",
  "source": "community",
  "discoveryMetadata": {
    "researchDate": "2025-10-25",
    "trendingSources": [
      {
        "source": "anthropic_official_docs",
        "evidence": "Official docs confirm prompt caching reduces costs by 90% for cache reads. JSON likely provides cache_read_input_tokens and cache_creation_input_tokens fields (verify with latest schema).",
        "url": "https://docs.claude.com/en/docs/claude-code/statusline",
        "relevanceScore": "high"
      },
      {
        "source": "anthropic_prompt_caching",
        "evidence": "Anthropic's prompt caching documentation: 'Cache reads cost 90% less than regular input tokens'. Caching enabled for Claude 3.5 Sonnet and Opus. Critical cost optimization feature.",
        "url": "https://docs.anthropic.com/claude/docs/prompt-caching",
        "relevanceScore": "high"
      },
      {
        "source": "dev_to_ai_optimization",
        "evidence": "2025 AI cost optimization guides emphasize prompt caching as primary cost reduction technique. Tracking cache hit rate is best practice for validating savings.",
        "url": "https://dev.to/",
        "relevanceScore": "high"
      },
      {
        "source": "hackernews",
        "evidence": "HackerNews discussions on Claude API costs highlight prompt caching: 'Properly configured caching can reduce bills by 50-70%'. Hit rate monitoring validates configuration.",
        "url": "https://news.ycombinator.com/",
        "relevanceScore": "medium"
      }
    ],
    "keywordResearch": {
      "primaryKeywords": [
        "prompt caching monitor",
        "cache hit rate tracker",
        "cache efficiency",
        "AI cost optimization"
      ],
      "searchVolume": "high",
      "competitionLevel": "low"
    },
    "gapAnalysis": {
      "existingContent": ["burn-rate-monitor"],
      "identifiedGap": "burn-rate-monitor tracks total cost but NOT cache efficiency (hit rate, write efficiency). Existing tracker doesn't show if prompt caching is working or calculate cache-driven savings. No visibility into whether caching strategy is optimal. Users need cache-level metrics separate from aggregate cost tracking.",
      "priority": "high"
    },
    "approvalRationale": "Official Anthropic docs confirm 90% cost savings from cache reads. Prompt caching is critical cost optimization feature for Claude 3.5+. High search volume for cache optimization, low competition. Clear gap vs cost-only tracking (no cache breakdown). Essential for validating caching configuration and ROI. User approved for cache efficiency monitoring."
  }
}
