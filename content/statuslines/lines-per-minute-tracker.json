{
  "slug": "lines-per-minute-tracker",
  "description": "Real-time coding velocity monitor tracking lines added/removed per minute with productivity scoring and daily output projection for Claude Code sessions.",
  "category": "statuslines",
  "author": "JSONbored",
  "dateAdded": "2025-10-25",
  "tags": ["productivity", "velocity", "coding-speed", "lines-per-minute", "output-tracking"],
  "statuslineType": "custom",
  "content": "#!/usr/bin/env bash\n\n# Lines Per Minute Productivity Tracker for Claude Code\n# Calculates coding velocity and productivity metrics\n\n# Read JSON from stdin\nread -r input\n\n# Extract values\nlines_added=$(echo \"$input\" | jq -r '.cost.total_lines_added // 0')\nlines_removed=$(echo \"$input\" | jq -r '.cost.total_lines_removed // 0')\ntotal_duration_ms=$(echo \"$input\" | jq -r '.cost.total_duration_ms // 1')\n\n# Calculate duration in minutes (avoid division by zero)\nif [ \"$total_duration_ms\" -gt 0 ]; then\n  duration_minutes=$(echo \"scale=2; $total_duration_ms / 60000\" | bc)\nelse\n  duration_minutes=0.01  # Prevent division by zero\nfi\n\n# Calculate net lines (added - removed)\nnet_lines=$((lines_added - lines_removed))\n\n# Calculate total changed lines (added + removed)\ntotal_changed=$((lines_added + lines_removed))\n\n# Calculate lines per minute\nif (( $(echo \"$duration_minutes > 0\" | bc -l) )); then\n  added_per_min=$(echo \"scale=1; $lines_added / $duration_minutes\" | bc)\n  removed_per_min=$(echo \"scale=1; $lines_removed / $duration_minutes\" | bc)\n  net_per_min=$(echo \"scale=1; $net_lines / $duration_minutes\" | bc)\n  total_per_min=$(echo \"scale=1; $total_changed / $duration_minutes\" | bc)\nelse\n  added_per_min=0\n  removed_per_min=0\n  net_per_min=0\n  total_per_min=0\nfi\n\n# Productivity scoring based on total changes per minute\nif (( $(echo \"$total_per_min > 50\" | bc -l) )); then\n  PROD_COLOR=\"\\033[38;5;46m\"   # Green: High productivity (>50 lines/min)\n  PROD_ICON=\"üöÄ\"\n  PROD_RATING=\"HIGH\"\nelif (( $(echo \"$total_per_min > 20\" | bc -l) )); then\n  PROD_COLOR=\"\\033[38;5;226m\"  # Yellow: Medium productivity (20-50 lines/min)\n  PROD_ICON=\"üìù\"\n  PROD_RATING=\"MED\"\nelse\n  PROD_COLOR=\"\\033[38;5;75m\"   # Blue: Low/steady productivity (<20 lines/min)\n  PROD_ICON=\"‚úèÔ∏è\"\n  PROD_RATING=\"LOW\"\nfi\n\n# Project daily output (assuming 8-hour workday = 480 minutes)\nif (( $(echo \"$net_per_min > 0\" | bc -l) )); then\n  daily_projection=$(echo \"scale=0; $net_per_min * 480\" | bc)\nelse\n  daily_projection=0\nfi\n\nRESET=\"\\033[0m\"\n\n# Format output with net lines indicator\nif [ $net_lines -lt 0 ]; then\n  net_display=\"${net_lines}\"\n  net_label=\"(refactoring)\"\nelse\n  net_display=\"+${net_lines}\"\n  net_label=\"(growth)\"\nfi\n\n# Output statusline\necho -e \"${PROD_ICON} ${PROD_RATING}: ${PROD_COLOR}${total_per_min} L/min${RESET} | +${added_per_min} -${removed_per_min} | Net: ${net_display} ${net_label} | üìÖ ${daily_projection} L/day\"\n",
  "features": [
    "Real-time lines per minute calculation for added, removed, and net changes",
    "Productivity scoring based on total change velocity (high >50 L/min, medium 20-50, low <20)",
    "Daily output projection assuming 8-hour workday (480 minutes)",
    "Refactoring detection (negative net lines indicates cleanup/deletion work)",
    "Separate tracking for additions vs removals for code quality insights",
    "Color-coded productivity ratings (green high, yellow medium, blue low)",
    "Lightweight bash with bc for floating-point calculations",
    "Zero external dependencies beyond jq and bc"
  ],
  "configuration": {
    "format": "bash",
    "refreshInterval": 1000,
    "position": "left"
  },
  "useCases": [
    "Tracking coding velocity during feature development sprints",
    "Measuring productivity impact of different coding sessions",
    "Identifying refactoring vs greenfield development patterns",
    "Comparing productivity across different time periods",
    "Setting personal velocity baselines and improvement goals",
    "Billing/time tracking for consulting work based on output metrics"
  ],
  "requirements": [
    "Bash shell",
    "jq JSON processor",
    "bc calculator (for floating-point arithmetic)"
  ],
  "preview": "üöÄ HIGH: 45.3 L/min | +38.2 -7.1 | Net: +150 (growth) | üìÖ 21,600 L/day",
  "troubleshooting": [
    {
      "issue": "Lines per minute showing 0 despite active coding",
      "solution": "Verify cost.total_lines_added and cost.total_lines_removed fields exist: echo '$input' | jq .cost. Ensure bc is installed: which bc. Check duration_minutes calculation: should be total_duration_ms / 60000. Very short sessions may show 0 until threshold reached."
    },
    {
      "issue": "Daily projection seems unrealistically high",
      "solution": "Daily projection assumes CONTINUOUS coding at current velocity for 8 hours (480 minutes). This is intentional for productivity goal-setting. Actual daily output will be lower with breaks, meetings, etc. Adjust multiplier from 480 to expected active coding minutes per day."
    },
    {
      "issue": "Net lines showing negative (refactoring) when expecting growth",
      "solution": "Negative net lines means total_lines_removed > total_lines_added. This is EXPECTED for refactoring/cleanup sessions. Script correctly labels as '(refactoring)'. If unexpected, verify you're looking at correct session - multi-file refactors often have more deletions than additions."
    },
    {
      "issue": "Productivity rating stuck at LOW despite high activity",
      "solution": "Productivity rating is based on TOTAL changes (added + removed), not net lines. Thresholds: <20 L/min = LOW, 20-50 = MED, >50 = HIGH. Check total_per_min calculation: (lines_added + lines_removed) / duration_minutes. Adjust thresholds if your baseline velocity differs."
    },
    {
      "issue": "bc: command not found when calculating velocity",
      "solution": "Install bc: brew install bc (macOS), apt install bc (Linux). Alternative: use integer math with awk: awk -v added=$lines_added -v dur=$duration_minutes 'BEGIN {print added/dur}' - loses decimal precision but works without bc."
    }
  ],
  "documentationUrl": "https://docs.claude.com/en/docs/claude-code/statusline",
  "source": "community",
  "discoveryMetadata": {
    "researchDate": "2025-10-25",
    "trendingSources": [
      {
        "source": "anthropic_official_docs",
        "evidence": "Official docs confirm JSON provides cost.total_lines_added and cost.total_lines_removed for productivity tracking. Statuslines can calculate derived metrics like velocity.",
        "url": "https://docs.claude.com/en/docs/claude-code/statusline",
        "relevanceScore": "high"
      },
      {
        "source": "github_trending",
        "evidence": "Productivity tracking tools like WakaTime emphasize lines-per-minute as key velocity metric. Developers use coding velocity for performance benchmarking.",
        "url": "https://github.com/wakatime/wakatime",
        "relevanceScore": "high"
      },
      {
        "source": "dev_to_productivity",
        "evidence": "2025 developer productivity guides cite output velocity (lines/commits per time) as quantifiable productivity metric. Lines-per-minute tracking helps identify peak productive hours.",
        "url": "https://dev.to/",
        "relevanceScore": "high"
      },
      {
        "source": "hackernews",
        "evidence": "HackerNews discussions on developer metrics highlight velocity tracking (lines changed, commits) as leading indicator of output. Controversial but widely tracked.",
        "url": "https://news.ycombinator.com/",
        "relevanceScore": "medium"
      }
    ],
    "keywordResearch": {
      "primaryKeywords": [
        "coding velocity tracker",
        "lines per minute",
        "productivity monitor",
        "developer output metrics"
      ],
      "searchVolume": "medium",
      "competitionLevel": "low"
    },
    "gapAnalysis": {
      "existingContent": ["burn-rate-monitor", "five-hour-window-tracker"],
      "identifiedGap": "burn-rate-monitor tracks COST velocity ($/min, tok/min) but NOT coding output velocity (lines/min). five-hour-window-tracker shows time remaining, not productivity. No existing statusline measures lines-per-minute or projects daily output. Developers need quantifiable productivity metrics separate from cost tracking.",
      "priority": "high"
    },
    "approvalRationale": "Official docs verified lines_added/lines_removed fields available. GitHub tools like WakaTime prove high demand for velocity tracking. Medium search volume, low competition. Clear gap vs cost/time trackers (no output velocity tracking). Critical for productivity benchmarking and goal-setting. User approved for velocity monitoring."
  }
}
