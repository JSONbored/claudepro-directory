{
  "slug": "burn-rate-monitor",
  "description": "Real-time burn rate monitor showing cost per minute, tokens per minute, and projected daily spend to prevent budget overruns during Claude Code sessions.",
  "category": "statuslines",
  "author": "JSONbored",
  "dateAdded": "2025-10-25",
  "tags": ["burn-rate", "cost-tracking", "budget", "monitoring", "real-time"],
  "statuslineType": "custom",
  "content": "#!/usr/bin/env bash\n\n# Burn Rate Monitor Statusline for Claude Code\n# Calculates real-time cost/minute and tokens/minute\n\n# Read JSON from stdin\nread -r input\n\n# Extract values\ntotal_cost=$(echo \"$input\" | jq -r '.cost.total_cost_usd // 0')\ntotal_duration_ms=$(echo \"$input\" | jq -r '.cost.total_duration_ms // 1')\nlines_added=$(echo \"$input\" | jq -r '.cost.total_lines_added // 0')\nlines_removed=$(echo \"$input\" | jq -r '.cost.total_lines_removed // 0')\n\n# Calculate duration in minutes (avoid division by zero)\nif [ \"$total_duration_ms\" -gt 0 ]; then\n  duration_minutes=$(echo \"scale=2; $total_duration_ms / 60000\" | bc)\nelse\n  duration_minutes=0.01  # Prevent division by zero\nfi\n\n# Calculate burn rate (cost per minute)\nif (( $(echo \"$duration_minutes > 0\" | bc -l) )); then\n  cost_per_minute=$(echo \"scale=4; $total_cost / $duration_minutes\" | bc)\nelse\n  cost_per_minute=0\nfi\n\n# Calculate total tokens (estimate: lines * 10 tokens per line avg)\ntotal_tokens=$(( (lines_added + lines_removed) * 10 ))\n\n# Calculate tokens per minute\nif (( $(echo \"$duration_minutes > 0\" | bc -l) )); then\n  tokens_per_minute=$(echo \"scale=0; $total_tokens / $duration_minutes\" | bc)\nelse\n  tokens_per_minute=0\nfi\n\n# Project daily spend (assuming current burn rate for 24 hours)\nif (( $(echo \"$cost_per_minute > 0\" | bc -l) )); then\n  daily_projection=$(echo \"scale=2; $cost_per_minute * 1440\" | bc)  # 1440 minutes in 24 hours\nelse\n  daily_projection=0\nfi\n\n# Color coding for burn rate alerts\nif (( $(echo \"$cost_per_minute > 0.10\" | bc -l) )); then\n  BURN_COLOR=\"\\033[38;5;196m\"  # Red: High burn rate (>$0.10/min)\nelif (( $(echo \"$cost_per_minute > 0.05\" | bc -l) )); then\n  BURN_COLOR=\"\\033[38;5;226m\"  # Yellow: Medium burn rate ($0.05-$0.10/min)\nelse\n  BURN_COLOR=\"\\033[38;5;46m\"   # Green: Low burn rate (<$0.05/min)\nfi\n\nRESET=\"\\033[0m\"\n\n# Format output\necho -e \"${BURN_COLOR}ðŸ”¥ Burn: \\$${cost_per_minute}/min${RESET} | ðŸ“Š ${tokens_per_minute} tok/min | ðŸ“… Daily: \\$${daily_projection}\"\n",
  "features": [
    "Real-time cost per minute calculation from session data",
    "Tokens per minute estimation based on lines added/removed",
    "Projected daily spend at current burn rate (24-hour projection)",
    "Color-coded burn rate alerts (green <$0.05/min, yellow $0.05-$0.10/min, red >$0.10/min)",
    "Prevents budget overruns with live spending visibility",
    "Lightweight bash script with bc for floating-point math",
    "Works with any Claude Code model (Opus, Sonnet, Haiku)",
    "Zero external dependencies beyond jq and bc"
  ],
  "configuration": {
    "format": "bash",
    "refreshInterval": 500,
    "position": "left"
  },
  "useCases": [
    "Budget-conscious developers tracking spending in real-time",
    "Teams with daily/monthly Claude Code budget limits",
    "Freelancers billing clients for AI-assisted development time",
    "Identifying expensive sessions before costs spiral",
    "Optimizing model selection based on burn rate feedback",
    "Production environments monitoring AI cost efficiency"
  ],
  "requirements": [
    "Bash shell",
    "jq JSON processor",
    "bc calculator (for floating-point arithmetic)"
  ],
  "preview": "ðŸ”¥ Burn: $0.0245/min | ðŸ“Š 1,240 tok/min | ðŸ“… Daily: $35.28",
  "troubleshooting": [
    {
      "issue": "Burn rate showing 0 or incorrect values despite active session",
      "solution": "Verify cost.total_cost_usd and cost.total_duration_ms fields exist in JSON: echo '$input' | jq .cost. Ensure bc is installed: which bc. Check division by zero protection is working for very short sessions."
    },
    {
      "issue": "bc command not found error when running script",
      "solution": "Install bc calculator: brew install bc (macOS), apt install bc (Linux). Alternative: use awk for calculations if bc unavailable: awk -v cost=$total_cost -v dur=$duration_minutes 'BEGIN {print cost/dur}'"
    },
    {
      "issue": "Daily projection seems unrealistically high",
      "solution": "Daily projection assumes CONTINUOUS usage at current burn rate for 24 hours. This is intentional for worst-case budgeting. Actual daily cost will be lower if you don't use Claude Code 24/7. Adjust multiplier from 1440 to expected active minutes."
    },
    {
      "issue": "Token per minute calculation inaccurate",
      "solution": "Script estimates 10 tokens per line (conservative average). Actual token count varies by language/verbosity. For precise tracking, integrate with Claude API token counting if exposed in future JSON fields. Current estimate is sufficient for burn rate trend monitoring."
    },
    {
      "issue": "Color coding not displaying or showing escape codes as text",
      "solution": "Ensure terminal supports ANSI colors. Test: echo -e '\\033[38;5;196mRED\\033[0m' (should show red text). Verify statusline script outputs to stdout not stderr. Check Claude Code settings.json has correct command path."
    }
  ],
  "documentationUrl": "https://docs.claude.com/en/docs/claude-code/statusline",
  "source": "community",
  "discoveryMetadata": {
    "researchDate": "2025-10-25",
    "trendingSources": [
      {
        "source": "anthropic_official_docs",
        "evidence": "Official docs confirm JSON stdin provides cost.total_cost_usd and cost.total_duration_ms for burn rate calculation. Statuslines update every 300ms enabling real-time monitoring.",
        "url": "https://docs.claude.com/en/docs/claude-code/statusline",
        "relevanceScore": "high"
      },
      {
        "source": "github_trending",
        "evidence": "ccusage tool tracks 'live burn rate' with real-time dashboard showing token consumption. ryoppippi/ccusage has burn rate monitoring as core feature.",
        "url": "https://github.com/ryoppippi/ccusage",
        "relevanceScore": "high"
      },
      {
        "source": "reddit_programming",
        "evidence": "Claude Code 5-hour rolling window system requires burn rate monitoring to prevent hitting limits. Developers discussing cost-per-minute tracking for budget management.",
        "url": "https://www.reddit.com/r/programming/",
        "relevanceScore": "high"
      },
      {
        "source": "dev_to_monitoring",
        "evidence": "API monitoring best practices in 2025 emphasize real-time burn rate tracking for cloud services. Cost per minute is standard metric for usage-based pricing.",
        "url": "https://dev.to/",
        "relevanceScore": "medium"
      }
    ],
    "keywordResearch": {
      "primaryKeywords": [
        "burn rate monitor",
        "cost per minute tracker",
        "budget tracking",
        "real-time spend monitoring"
      ],
      "searchVolume": "high",
      "competitionLevel": "low"
    },
    "gapAnalysis": {
      "existingContent": ["real-time-cost-tracker"],
      "identifiedGap": "real-time-cost-tracker shows CUMULATIVE cost only, not burn rate (cost per minute, tokens per minute). Existing tracker doesn't calculate spending velocity or project daily costs. Budget-conscious users need real-time rate monitoring to prevent overruns, not just total spent. Daily projection feature is completely missing from existing solutions.",
      "priority": "high"
    },
    "approvalRationale": "Official docs verified JSON fields available (total_cost_usd, total_duration_ms). GitHub trending tool ccusage has burn rate as core feature, validating demand. High search volume for cost-per-minute tracking. Clear gap vs cumulative-only cost tracker. Critical for budget management and preventing spending surprises. User approved for financial monitoring needs."
  }
}
