{
  "title": "Kubernetes Management MCP",
  "description": "Comprehensive Kubernetes cluster management, deployment automation, and container orchestration",
  "category": "mcp",
  "author": "claudepro",
  "dateAdded": "2025-09-16",
  "tags": [
    "kubernetes",
    "k8s",
    "container",
    "orchestration",
    "deployment",
    "devops"
  ],
  "content": "The Kubernetes Management MCP Server provides comprehensive cluster management capabilities, enabling deployment automation, resource monitoring, and container orchestration through Claude.\n\n## Core Capabilities\n\n### Cluster Management\n- Node status and resource monitoring\n- Namespace management and isolation\n- RBAC (Role-Based Access Control) configuration\n- Network policy management\n- Storage class and persistent volume operations\n\n### Workload Management\n- **Deployments**: Application lifecycle management\n- **StatefulSets**: Stateful application orchestration\n- **DaemonSets**: Node-level service deployment\n- **Jobs & CronJobs**: Batch processing and scheduled tasks\n- **Pods**: Direct container management\n\n### Service & Networking\n- Service discovery and load balancing\n- Ingress controller configuration\n- ConfigMap and Secret management\n- Network policy enforcement\n- Service mesh integration\n\n### Scaling & Resource Management\n- Horizontal Pod Autoscaling (HPA)\n- Vertical Pod Autoscaling (VPA)\n- Cluster autoscaling\n- Resource quotas and limits\n- Quality of Service (QoS) management\n\n### Monitoring & Observability\n- Pod and container metrics\n- Event tracking and alerting\n- Log aggregation and analysis\n- Health checks and readiness probes\n- Performance monitoring\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-kubernetes\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"kubernetes\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-kubernetes\"],\n      \"env\": {\n        \"KUBECONFIG\": \"/path/to/kubeconfig\",\n        \"K8S_CLUSTER_URL\": \"https://kubernetes.default.svc\",\n        \"K8S_NAMESPACE\": \"default\",\n        \"K8S_TOKEN\": \"your-service-account-token\"\n      }\n    }\n  }\n}\n```\n\n## Authentication Methods\n\n### Method 1: Kubeconfig File\n```json\n{\n  \"env\": {\n    \"KUBECONFIG\": \"/home/user/.kube/config\"\n  }\n}\n```\n\n### Method 2: Service Account Token\n```json\n{\n  \"env\": {\n    \"K8S_CLUSTER_URL\": \"https://my-cluster.example.com:6443\",\n    \"K8S_TOKEN\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjEyMyJ9...\",\n    \"K8S_CA_CERT\": \"/path/to/ca.crt\"\n  }\n}\n```\n\n### Method 3: In-Cluster Configuration\n```json\n{\n  \"env\": {\n    \"K8S_IN_CLUSTER\": \"true\"\n  }\n}\n```\n\n## Usage Examples\n\n### Deployment Management\n```yaml\n# Create deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-application\n  namespace: production\n  labels:\n    app: web-app\n    version: v1.2.0\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n        version: v1.2.0\n    spec:\n      containers:\n      - name: web-app\n        image: myregistry/web-app:1.2.0\n        ports:\n        - containerPort: 8080\n          name: http\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: redis-url\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n      imagePullSecrets:\n      - name: registry-secret\n```\n\n```javascript\n// Deploy application using JavaScript\nconst deployment = await k8s.createDeployment({\n  metadata: {\n    name: 'web-application',\n    namespace: 'production',\n    labels: {\n      app: 'web-app',\n      version: 'v1.2.0'\n    }\n  },\n  spec: {\n    replicas: 3,\n    selector: {\n      matchLabels: { app: 'web-app' }\n    },\n    template: {\n      metadata: {\n        labels: {\n          app: 'web-app',\n          version: 'v1.2.0'\n        }\n      },\n      spec: {\n        containers: [{\n          name: 'web-app',\n          image: 'myregistry/web-app:1.2.0',\n          ports: [{ containerPort: 8080, name: 'http' }],\n          env: [\n            {\n              name: 'DATABASE_URL',\n              valueFrom: {\n                secretKeyRef: {\n                  name: 'app-secrets',\n                  key: 'database-url'\n                }\n              }\n            }\n          ],\n          resources: {\n            requests: { memory: '256Mi', cpu: '250m' },\n            limits: { memory: '512Mi', cpu: '500m' }\n          },\n          livenessProbe: {\n            httpGet: { path: '/health', port: 8080 },\n            initialDelaySeconds: 30,\n            periodSeconds: 10\n          }\n        }]\n      }\n    }\n  }\n});\n\n// Update deployment (rolling update)\nconst updateDeployment = await k8s.patchDeployment('web-application', 'production', {\n  spec: {\n    template: {\n      spec: {\n        containers: [{\n          name: 'web-app',\n          image: 'myregistry/web-app:1.3.0' // New version\n        }]\n      }\n    }\n  }\n});\n\n// Scale deployment\nconst scaleDeployment = await k8s.scaleDeployment('web-application', 'production', 5);\n\n// Get deployment status\nconst deploymentStatus = await k8s.getDeployment('web-application', 'production');\nconsole.log('Ready replicas:', deploymentStatus.status.readyReplicas);\nconsole.log('Updated replicas:', deploymentStatus.status.updatedReplicas);\n```\n\n### Service and Networking\n```yaml\n# Service configuration\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-app-service\n  namespace: production\n  labels:\n    app: web-app\nspec:\n  selector:\n    app: web-app\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n  type: ClusterIP\n---\n# Ingress configuration\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-app-ingress\n  namespace: production\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/rate-limit: \"100\"\nspec:\n  tls:\n  - hosts:\n    - api.mycompany.com\n    secretName: web-app-tls\n  rules:\n  - host: api.mycompany.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n```\n\n```javascript\n// Create service\nconst service = await k8s.createService({\n  metadata: {\n    name: 'web-app-service',\n    namespace: 'production'\n  },\n  spec: {\n    selector: { app: 'web-app' },\n    ports: [{\n      name: 'http',\n      port: 80,\n      targetPort: 8080,\n      protocol: 'TCP'\n    }],\n    type: 'ClusterIP'\n  }\n});\n\n// Create ingress\nconst ingress = await k8s.createIngress({\n  metadata: {\n    name: 'web-app-ingress',\n    namespace: 'production',\n    annotations: {\n      'nginx.ingress.kubernetes.io/rewrite-target': '/',\n      'cert-manager.io/cluster-issuer': 'letsencrypt-prod'\n    }\n  },\n  spec: {\n    tls: [{\n      hosts: ['api.mycompany.com'],\n      secretName: 'web-app-tls'\n    }],\n    rules: [{\n      host: 'api.mycompany.com',\n      http: {\n        paths: [{\n          path: '/',\n          pathType: 'Prefix',\n          backend: {\n            service: {\n              name: 'web-app-service',\n              port: { number: 80 }\n            }\n          }\n        }]\n      }\n    }]\n  }\n});\n```\n\n### ConfigMaps and Secrets\n```javascript\n// Create ConfigMap\nconst configMap = await k8s.createConfigMap({\n  metadata: {\n    name: 'app-config',\n    namespace: 'production'\n  },\n  data: {\n    'redis-url': 'redis://redis-service:6379',\n    'log-level': 'info',\n    'max-connections': '100',\n    'config.json': JSON.stringify({\n      features: {\n        enableNewUI: true,\n        enableAnalytics: true,\n        enableCaching: true\n      },\n      limits: {\n        maxFileSize: '10MB',\n        requestTimeout: 30000\n      }\n    })\n  }\n});\n\n// Create Secret\nconst secret = await k8s.createSecret({\n  metadata: {\n    name: 'app-secrets',\n    namespace: 'production'\n  },\n  type: 'Opaque',\n  data: {\n    'database-url': Buffer.from('postgresql://user:pass@db:5432/myapp').toString('base64'),\n    'api-key': Buffer.from('sk-1234567890abcdef').toString('base64'),\n    'jwt-secret': Buffer.from('super-secret-jwt-key').toString('base64')\n  }\n});\n\n// Create TLS Secret\nconst tlsSecret = await k8s.createSecret({\n  metadata: {\n    name: 'web-app-tls',\n    namespace: 'production'\n  },\n  type: 'kubernetes.io/tls',\n  data: {\n    'tls.crt': certData, // Base64 encoded certificate\n    'tls.key': keyData   // Base64 encoded private key\n  }\n});\n```\n\n### Autoscaling Configuration\n```yaml\n# Horizontal Pod Autoscaler\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: web-app-hpa\n  namespace: production\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: web-application\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n      - type: Percent\n        value: 50\n        periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 60\n      policies:\n      - type: Percent\n        value: 100\n        periodSeconds: 15\n```\n\n```javascript\n// Create HPA\nconst hpa = await k8s.createHorizontalPodAutoscaler({\n  metadata: {\n    name: 'web-app-hpa',\n    namespace: 'production'\n  },\n  spec: {\n    scaleTargetRef: {\n      apiVersion: 'apps/v1',\n      kind: 'Deployment',\n      name: 'web-application'\n    },\n    minReplicas: 3,\n    maxReplicas: 20,\n    metrics: [\n      {\n        type: 'Resource',\n        resource: {\n          name: 'cpu',\n          target: {\n            type: 'Utilization',\n            averageUtilization: 70\n          }\n        }\n      },\n      {\n        type: 'Resource',\n        resource: {\n          name: 'memory',\n          target: {\n            type: 'Utilization',\n            averageUtilization: 80\n          }\n        }\n      }\n    ]\n  }\n});\n```\n\n### StatefulSet for Databases\n```yaml\n# Redis StatefulSet\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: redis-cluster\n  namespace: production\nspec:\n  serviceName: redis-headless\n  replicas: 3\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n      - name: redis\n        image: redis:7-alpine\n        ports:\n        - containerPort: 6379\n          name: redis\n        - containerPort: 16379\n          name: cluster\n        command:\n        - redis-server\n        args:\n        - /config/redis.conf\n        volumeMounts:\n        - name: redis-config\n          mountPath: /config\n        - name: redis-data\n          mountPath: /data\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n      volumes:\n      - name: redis-config\n        configMap:\n          name: redis-config\n  volumeClaimTemplates:\n  - metadata:\n      name: redis-data\n    spec:\n      accessModes: [\"ReadWriteOnce\"]\n      storageClassName: fast-ssd\n      resources:\n        requests:\n          storage: 10Gi\n```\n\n### Job and CronJob Examples\n```javascript\n// Database migration job\nconst migrationJob = await k8s.createJob({\n  metadata: {\n    name: 'db-migration-v120',\n    namespace: 'production'\n  },\n  spec: {\n    template: {\n      spec: {\n        restartPolicy: 'Never',\n        containers: [{\n          name: 'migration',\n          image: 'myregistry/migration-tool:1.2.0',\n          env: [\n            {\n              name: 'DATABASE_URL',\n              valueFrom: {\n                secretKeyRef: {\n                  name: 'app-secrets',\n                  key: 'database-url'\n                }\n              }\n            }\n          ],\n          command: ['./migrate.sh'],\n          args: ['--version', '1.2.0']\n        }]\n      }\n    },\n    backoffLimit: 3,\n    activeDeadlineSeconds: 3600\n  }\n});\n\n// Backup CronJob\nconst backupCronJob = await k8s.createCronJob({\n  metadata: {\n    name: 'database-backup',\n    namespace: 'production'\n  },\n  spec: {\n    schedule: '0 2 * * *', // Daily at 2 AM\n    jobTemplate: {\n      spec: {\n        template: {\n          spec: {\n            restartPolicy: 'OnFailure',\n            containers: [{\n              name: 'backup',\n              image: 'myregistry/backup-tool:latest',\n              env: [\n                {\n                  name: 'DATABASE_URL',\n                  valueFrom: {\n                    secretKeyRef: {\n                      name: 'app-secrets',\n                      key: 'database-url'\n                    }\n                  }\n                },\n                {\n                  name: 'S3_BUCKET',\n                  value: 'my-backups-bucket'\n                }\n              ],\n              command: ['./backup.sh']\n            }]\n          }\n        }\n      }\n    },\n    successfulJobsHistoryLimit: 3,\n    failedJobsHistoryLimit: 1\n  }\n});\n```\n\n### Monitoring and Observability\n```javascript\n// Get cluster metrics\nconst clusterMetrics = await k8s.getClusterMetrics();\nconsole.log('Cluster CPU usage:', clusterMetrics.cpu.percentage);\nconsole.log('Cluster memory usage:', clusterMetrics.memory.percentage);\n\n// Get pod metrics\nconst podMetrics = await k8s.getPodMetrics('production');\npodMetrics.forEach(pod => {\n  console.log(`Pod ${pod.name}: CPU ${pod.cpu}, Memory ${pod.memory}`);\n});\n\n// Get events\nconst events = await k8s.getEvents('production', {\n  fieldSelector: 'involvedObject.kind=Pod',\n  timeWindow: '1h'\n});\n\n// Watch pod status changes\nconst podWatcher = k8s.watchPods('production', (event) => {\n  const { type, object: pod } = event;\n  console.log(`Pod ${pod.metadata.name} ${type}: ${pod.status.phase}`);\n  \n  if (type === 'MODIFIED' && pod.status.phase === 'Failed') {\n    // Handle failed pod\n    handlePodFailure(pod);\n  }\n});\n\n// Get logs\nconst logs = await k8s.getPodLogs('web-application-abc123', 'production', {\n  container: 'web-app',\n  tailLines: 100,\n  since: '1h'\n});\n\n// Stream logs\nconst logStream = k8s.streamPodLogs('web-application-abc123', 'production', {\n  follow: true,\n  container: 'web-app'\n});\n\nlogStream.on('data', (chunk) => {\n  console.log('Log:', chunk.toString());\n});\n```\n\n### Resource Management\n```yaml\n# Namespace with resource quotas\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: development\n  labels:\n    environment: dev\n---\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: dev-quota\n  namespace: development\nspec:\n  hard:\n    requests.cpu: \"4\"\n    requests.memory: 8Gi\n    limits.cpu: \"8\"\n    limits.memory: 16Gi\n    persistentvolumeclaims: \"10\"\n    pods: \"20\"\n    services: \"10\"\n---\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: dev-limits\n  namespace: development\nspec:\n  limits:\n  - type: Container\n    default:\n      cpu: \"500m\"\n      memory: \"512Mi\"\n    defaultRequest:\n      cpu: \"100m\"\n      memory: \"128Mi\"\n    max:\n      cpu: \"2\"\n      memory: \"2Gi\"\n    min:\n      cpu: \"50m\"\n      memory: \"64Mi\"\n```\n\n## Best Practices\n\n### Security\n```yaml\n# Pod Security Context\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  runAsGroup: 1000\n  fsGroup: 1000\n  seccompProfile:\n    type: RuntimeDefault\ncontainers:\n- name: web-app\n  securityContext:\n    allowPrivilegeEscalation: false\n    readOnlyRootFilesystem: true\n    capabilities:\n      drop:\n      - ALL\n```\n\n### Resource Optimization\n```javascript\n// Resource recommendations\nconst getResourceRecommendations = async (deploymentName, namespace) => {\n  const metrics = await k8s.getPodMetrics(namespace, {\n    labelSelector: `app=${deploymentName}`\n  });\n  \n  const recommendations = {\n    cpu: {\n      request: Math.ceil(Math.max(...metrics.map(m => m.cpu.avg)) * 1.1) + 'm',\n      limit: Math.ceil(Math.max(...metrics.map(m => m.cpu.max)) * 1.2) + 'm'\n    },\n    memory: {\n      request: Math.ceil(Math.max(...metrics.map(m => m.memory.avg)) * 1.1) + 'Mi',\n      limit: Math.ceil(Math.max(...metrics.map(m => m.memory.max)) * 1.2) + 'Mi'\n    }\n  };\n  \n  return recommendations;\n};\n```\n\n### Deployment Strategies\n```javascript\n// Blue-Green Deployment\nconst blueGreenDeploy = async (appName, newVersion) => {\n  // Deploy green version\n  await k8s.createDeployment({\n    metadata: { name: `${appName}-green` },\n    spec: {\n      template: {\n        spec: {\n          containers: [{ image: `${appName}:${newVersion}` }]\n        }\n      }\n    }\n  });\n  \n  // Wait for readiness\n  await k8s.waitForDeploymentReady(`${appName}-green`, 'production');\n  \n  // Switch traffic\n  await k8s.patchService(`${appName}-service`, 'production', {\n    spec: {\n      selector: { app: `${appName}-green` }\n    }\n  });\n  \n  // Cleanup old version after verification\n  setTimeout(async () => {\n    await k8s.deleteDeployment(`${appName}-blue`, 'production');\n  }, 300000); // 5 minutes\n};\n```",
  "configuration": {
    "requiresAuth": true,
    "authType": "kubeconfig",
    "permissions": [
      "cluster-admin",
      "view",
      "edit"
    ]
  },
  "githubUrl": "https://github.com/claudepro/mcp-kubernetes",
  "documentationUrl": "https://docs.claude.ai/mcp/kubernetes",
  "source": "community"
}
