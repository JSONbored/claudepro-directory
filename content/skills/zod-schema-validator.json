{
  "slug": "zod-schema-validator",
  "title": "Zod Schema Validator",
  "seoTitle": "Zod Schema Validation Skill",
  "description": "Build type-safe runtime validation with Zod for APIs, forms, and data pipelines with TypeScript 5.5+ integration and automatic type inference.",
  "category": "skills",
  "author": "JSONbored",
  "dateAdded": "2025-10-16",
  "tags": ["zod", "validation", "typescript", "type-safety", "schema"],
  "content": "# Zod Schema Validator Skill\n\n## What This Skill Enables\n\nClaude can build comprehensive validation schemas using Zod, the TypeScript-first validation library tested against TypeScript v5.5+. Zod provides runtime validation that matches compile-time types, enabling you to validate untrusted data (API inputs, user forms, external integrations) while maintaining end-to-end type safety. With zero dependencies and automatic type inference, Zod eliminates the gap between static types and runtime reality.\n\n## Prerequisites\n\n**Required:**\n- Claude Pro subscription or Claude Code CLI\n- TypeScript 5.0+ (5.5+ recommended)\n- Node.js 18+ or modern browser\n- Basic TypeScript knowledge\n\n**What Claude handles automatically:**\n- Writing Zod schemas with proper validators\n- Inferring TypeScript types from schemas\n- Adding custom validation logic with refinements\n- Generating error messages in multiple formats\n- Creating reusable schema compositions\n- Implementing async validation\n- Adding transforms for data coercion\n- Integrating with React Hook Form or tRPC\n\n## How to Use This Skill\n\n### Basic Schema Creation\n\n**Prompt:** \"Create Zod schemas for a user registration API that validates email, password (min 8 chars, requires number and special char), age (18-100), and optional phone number.\"\n\nClaude will:\n1. Write Zod schema with proper validators\n2. Add regex patterns for email and password\n3. Include range validation for age\n4. Make phone number optional\n5. Generate custom error messages\n6. Infer TypeScript type from schema\n7. Show validation usage examples\n\n### Form Validation with React Hook Form\n\n**Prompt:** \"Build a React form with Zod validation for: name, email, address (street, city, state, zip), and checkbox for terms acceptance. Integrate with React Hook Form and show field-level errors.\"\n\nClaude will:\n1. Create nested Zod schema for address\n2. Set up React Hook Form with zodResolver\n3. Add real-time validation on blur\n4. Display error messages per field\n5. Prevent submission until valid\n6. Include TypeScript types\n7. Add accessible error announcements\n\n### API Request/Response Validation\n\n**Prompt:** \"Create Zod schemas for a REST API with request validation and response parsing. Include pagination parameters, filters, and error handling.\"\n\nClaude will:\n1. Define request body schemas\n2. Create query parameter validators\n3. Add response schema with safeParse\n4. Handle validation errors gracefully\n5. Include pagination metadata\n6. Add discriminated unions for responses\n7. Generate OpenAPI types from schemas\n\n### Complex Business Logic Validation\n\n**Prompt:** \"Build a Zod schema for order validation where: if payment method is 'credit_card', require card details; if 'paypal', require email; shipping date must be after today; total must match items sum.\"\n\nClaude will:\n1. Use discriminated unions for payment methods\n2. Add conditional validation with refine()\n3. Implement cross-field validation\n4. Calculate and validate totals\n5. Add date comparison logic\n6. Provide clear error paths\n7. Include async validation for external checks\n\n## Tips for Best Results\n\n1. **Infer Types, Don't Duplicate**: Always use `z.infer<typeof schema>` instead of defining types manually. This ensures runtime validation matches compile-time types.\n\n2. **Use `.safeParse()` for Untrusted Data**: In API routes or external inputs, use `safeParse()` instead of `parse()` to avoid throwing exceptions. Handle validation errors gracefully.\n\n3. **Custom Error Messages**: Request custom error messages with `.min(8, { message: 'Password must be at least 8 characters' })` for better UX.\n\n4. **Refinements for Complex Logic**: Use `.refine()` or `.superRefine()` for validation that involves multiple fields or external calls.\n\n5. **Reusable Schemas**: Create base schemas and extend them with `.extend()` or compose with `.merge()` to avoid duplication.\n\n6. **Transforms for Coercion**: Use `.transform()` to normalize data (trim strings, parse numbers) before validation.\n\n## Common Workflows\n\n### E-Commerce Checkout Validation\n```\n\"Create complete Zod validation for checkout flow:\n1. Customer info: email, phone, billing address\n2. Shipping: address with validation (can't be PO box), preferred delivery date\n3. Payment: discriminated union for credit card, PayPal, crypto\n4. Items: array of products with quantity (min 1, max 10), size, color\n5. Promo code: optional, alphanumeric, validate against API\n6. Total must match cart calculation\n7. Accept terms and conditions (required)\"\n```\n\n### API Gateway Validation Layer\n```\n\"Build API validation middleware with Zod:\n1. Validate request headers (auth token, content-type)\n2. Parse and validate query parameters with coercion\n3. Validate request body based on endpoint\n4. Add rate limiting metadata validation\n5. Validate response format before sending to client\n6. Log validation errors with request context\n7. Return standardized error responses\"\n```\n\n### Database Input Sanitization\n```\n\"Create Zod schemas for database operations:\n1. User input sanitization before INSERT\n2. Strip dangerous characters from strings\n3. Validate foreign key relationships exist\n4. Ensure email uniqueness with async validator\n5. Transform dates to ISO format\n6. Validate JSON columns match expected structure\n7. Add database constraint validation\"\n```\n\n### File Upload Validation\n```\n\"Build file upload validator with Zod:\n1. Validate MIME types (images: PNG, JPG, WebP)\n2. Check file size (max 5MB)\n3. Validate image dimensions (min 800x600, max 4000x4000)\n4. Sanitize filename (alphanumeric, hyphens, underscores)\n5. Validate metadata (EXIF data)\n6. Check for malware signatures\n7. Transform to standard format\"\n```\n\n## Troubleshooting\n\n**Issue:** Type inference not working\n**Solution:** Ensure TypeScript version is 5.0+. Use `z.infer<typeof schema>` correctly. Check tsconfig.json has `strict: true`. Update Zod to latest version.\n\n**Issue:** Validation errors not showing custom messages\n**Solution:** Add message parameter to validators: `.min(8, { message: '...' })`. Use `error.format()` to get structured errors. Check error path matches form field names.\n\n**Issue:** Async validation not working\n**Solution:** Use `.refine()` with async function, not `.transform()`. Ensure you `await` the parse result. Consider using `.parseAsync()` or `.safeParseAsync()`.\n\n**Issue:** Performance slow with large arrays\n**Solution:** Use `.nonempty()` instead of `.min(1)` for faster validation. Implement pagination. Consider lazy validation with `.lazy()` for recursive structures.\n\n**Issue:** Optional fields not working correctly\n**Solution:** Use `.optional()` for truly optional fields, `.nullable()` for null values, `.default()` for default values. Don't mix `.optional()` with `.nullable()` unless you mean to accept both.\n\n**Issue:** Union types confusing in errors\n**Solution:** Use discriminated unions with `.discriminatedUnion()` for better error messages. Add explicit type checking before validation. Provide user-friendly labels.\n\n## Learn More\n\n- [Zod Official Documentation](https://zod.dev/)\n- [Zod GitHub Repository](https://github.com/colinhacks/zod)\n- [React Hook Form + Zod Integration](https://react-hook-form.com/get-started#SchemaValidation)\n- [tRPC + Zod Guide](https://trpc.io/docs/server/validators)\n- [Zod to JSON Schema](https://github.com/StefanTerdell/zod-to-json-schema)\n- [Zod Error Formatting](https://zod.dev/ERROR_HANDLING)\n",
  "features": [
    "TypeScript-first with automatic type inference",
    "Zero dependencies, 8kb minified",
    "Composable schemas with .extend() and .merge()",
    "Custom validation with .refine() and async support"
  ],
  "useCases": [
    "API request/response validation",
    "Form validation with error messages",
    "Database input sanitization"
  ],
  "requirements": ["TypeScript 5.0+", "zod ^3.22.0", "Node.js 18+ or modern browser"],
  "examples": [
    {
      "title": "User Registration Schema",
      "language": "typescript",
      "code": "import { z } from 'zod';\n\nconst passwordSchema = z\n  .string()\n  .min(8, 'Password must be at least 8 characters')\n  .regex(/[0-9]/, 'Password must contain a number')\n  .regex(/[^a-zA-Z0-9]/, 'Password must contain a special character');\n\nconst userRegistrationSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: passwordSchema,\n  confirmPassword: z.string(),\n  age: z.number().int().min(18, 'Must be 18 or older').max(100),\n  phone: z.string().regex(/^\\+?[1-9]\\d{1,14}$/).optional(),\n  acceptTerms: z.literal(true, {\n    errorMap: () => ({ message: 'You must accept the terms' }),\n  }),\n}).refine((data) => data.password === data.confirmPassword, {\n  message: 'Passwords do not match',\n  path: ['confirmPassword'],\n});\n\ntype UserRegistration = z.infer<typeof userRegistrationSchema>;\n\n// Usage\nconst result = userRegistrationSchema.safeParse({\n  email: 'user@example.com',\n  password: 'SecureP@ss1',\n  confirmPassword: 'SecureP@ss1',\n  age: 25,\n  acceptTerms: true,\n});\n\nif (!result.success) {\n  console.error(result.error.format());\n} else {\n  console.log('Valid user:', result.data);\n}"
    },
    {
      "title": "React Hook Form Integration",
      "language": "typescript",
      "code": "import { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst formSchema = z.object({\n  name: z.string().min(2, 'Name must be at least 2 characters'),\n  email: z.string().email(),\n  address: z.object({\n    street: z.string().min(5),\n    city: z.string().min(2),\n    state: z.string().length(2, 'Use 2-letter state code'),\n    zip: z.string().regex(/^\\d{5}(-\\d{4})?$/, 'Invalid ZIP code'),\n  }),\n});\n\ntype FormData = z.infer<typeof formSchema>;\n\nexport function RegistrationForm() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<FormData>({\n    resolver: zodResolver(formSchema),\n  });\n\n  const onSubmit = (data: FormData) => {\n    console.log('Valid form data:', data);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <input {...register('name')} />\n      {errors.name && <span>{errors.name.message}</span>}\n\n      <input {...register('email')} />\n      {errors.email && <span>{errors.email.message}</span>}\n\n      <input {...register('address.street')} placeholder=\"Street\" />\n      {errors.address?.street && <span>{errors.address.street.message}</span>}\n\n      {/* ... other fields ... */}\n\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}"
    },
    {
      "title": "API Validation Middleware",
      "language": "typescript",
      "code": "import { z } from 'zod';\nimport { Request, Response, NextFunction } from 'express';\n\nconst createUserSchema = z.object({\n  body: z.object({\n    name: z.string().min(2),\n    email: z.string().email(),\n    role: z.enum(['user', 'admin']).default('user'),\n  }),\n  query: z.object({\n    sendWelcomeEmail: z\n      .string()\n      .transform((val) => val === 'true')\n      .default('false'),\n  }),\n});\n\ntype CreateUserRequest = z.infer<typeof createUserSchema>;\n\nexport const validateRequest =\n  (schema: z.ZodSchema) =>\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const result = await schema.parseAsync({\n        body: req.body,\n        query: req.query,\n        params: req.params,\n      });\n\n      req.body = result.body;\n      req.query = result.query as any;\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({\n          error: 'Validation failed',\n          details: error.format(),\n        });\n      } else {\n        next(error);\n      }\n    }\n  };\n\n// Usage\napp.post('/users', validateRequest(createUserSchema), async (req, res) => {\n  const { name, email, role } = req.body;\n  // Data is validated and typed\n  const user = await createUser({ name, email, role });\n  res.json(user);\n});"
    },
    {
      "title": "Discriminated Union for Payments",
      "language": "typescript",
      "code": "import { z } from 'zod';\n\nconst creditCardPayment = z.object({\n  method: z.literal('credit_card'),\n  cardNumber: z.string().regex(/^\\d{16}$/),\n  expiryMonth: z.number().min(1).max(12),\n  expiryYear: z.number().min(2025),\n  cvv: z.string().regex(/^\\d{3,4}$/),\n});\n\nconst paypalPayment = z.object({\n  method: z.literal('paypal'),\n  email: z.string().email(),\n});\n\nconst cryptoPayment = z.object({\n  method: z.literal('crypto'),\n  walletAddress: z.string().regex(/^0x[a-fA-F0-9]{40}$/),\n  cryptocurrency: z.enum(['BTC', 'ETH', 'USDC']),\n});\n\nconst paymentSchema = z.discriminatedUnion('method', [\n  creditCardPayment,\n  paypalPayment,\n  cryptoPayment,\n]);\n\ntype Payment = z.infer<typeof paymentSchema>;\n\n// TypeScript knows the shape based on method\nfunction processPayment(payment: Payment) {\n  switch (payment.method) {\n    case 'credit_card':\n      return chargeCreditCard(payment.cardNumber, payment.cvv);\n    case 'paypal':\n      return chargePayPal(payment.email);\n    case 'crypto':\n      return chargeCrypto(payment.walletAddress);\n  }\n}"
    }
  ],
  "installation": {
    "claudeDesktop": {
      "steps": [
        "Install Zod: npm install zod",
        "Ask Claude: 'Create Zod validation schemas for [your use case]'",
        "Claude generates schemas with TypeScript types",
        "Integrate with forms or API routes"
      ]
    },
    "claudeCode": {
      "steps": [
        "npm install zod",
        "npm install @hookform/resolvers (for React Hook Form)",
        "Create schemas in src/schemas/",
        "Import and use with safeParse() or parse()"
      ]
    }
  },
  "troubleshooting": [
    {
      "issue": "Type inference returns 'any'",
      "solution": "Check TypeScript version is 5.0+. Ensure you're using 'z.infer<typeof schema>' correctly. Update tsconfig.json with strict: true."
    },
    {
      "issue": "Optional fields not working",
      "solution": "Use .optional() for optional, .nullable() for null, .default() for defaults. Don't chain .optional().nullable() unless you need both undefined and null."
    },
    {
      "issue": "Async validation failing",
      "solution": "Use .refine() with async callback, call .parseAsync() or .safeParseAsync(), ensure you await the result."
    }
  ],
  "documentationUrl": "https://zod.dev/",
  "source": "community"
}
