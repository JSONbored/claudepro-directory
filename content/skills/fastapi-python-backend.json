{
  "slug": "fastapi-python-backend",
  "title": "FastAPI Python Backend Expert",
  "seoTitle": "FastAPI Python API Development Skill",
  "description": "Build high-performance async REST APIs with FastAPI, Python's fastest-growing web framework. Automatic OpenAPI docs, type validation with Pydantic, and async/await support.",
  "category": "skills",
  "author": "JSONbored",
  "dateAdded": "2025-10-23",
  "tags": ["fastapi", "python", "api", "async", "pydantic"],
  "discoveryMetadata": {
    "researchDate": "2025-10-23",
    "trendingSources": [
      {
        "source": "reddit_programming",
        "evidence": "FastAPI +5 point increase in 2025 web framework survey - most significant shift in web framework space",
        "url": "https://www.reddit.com/r/programming",
        "relevanceScore": "high"
      },
      {
        "source": "stackoverflow_survey",
        "evidence": "Stack Overflow 2025 - FastAPI shows rapid growth for performant Python API development, strong trend toward Python backends",
        "url": "https://survey.stackoverflow.co/2025/technology/",
        "relevanceScore": "high"
      }
    ],
    "keywordResearch": {
      "primaryKeywords": [
        "fastapi tutorial",
        "fastapi python",
        "python async api",
        "fastapi development"
      ],
      "searchVolume": "high",
      "competitionLevel": "medium"
    },
    "gapAnalysis": {
      "existingContent": [
        "rest-api-client-harness",
        "postgresql-query-optimization",
        "supabase-realtime-database",
        "trpc-type-safe-api"
      ],
      "identifiedGap": "No Python-specific API framework skill exists. Existing skills focus on TypeScript (tRPC), testing (REST client), or databases. FastAPI is THE fastest-growing Python API framework in 2025 with +5 point increase making it most significant web framework trend. Python leads 2025 at 29.85% market share.",
      "priority": "high"
    },
    "approvalRationale": "FastAPI showed +5 point increase in 2025, the most significant shift in web framework space according to Reddit programming discussions and Stack Overflow survey. Python dominates at 29.85% market share (+7% YoY). No existing Python API framework skills despite high demand. User approved October 23, 2025."
  },
  "content": "# FastAPI Python Backend Expert Skill\n\n## What This Skill Enables\n\nClaude can build production-ready REST APIs using FastAPI, Python's fastest web framework with automatic OpenAPI documentation and async support. FastAPI combines Python 3.9+ type hints with Pydantic validation for type-safe APIs that rival Node.js performance. With automatic interactive docs, dependency injection, and async/await, FastAPI eliminates boilerplate while maintaining enterprise-grade reliability.\n\n## Prerequisites\n\n**Required:**\n- Claude Pro subscription or Claude Code CLI\n- Python 3.9+ (3.11+ recommended for best performance)\n- pip or poetry package manager\n- Basic Python knowledge\n\n**What Claude handles automatically:**\n- Writing FastAPI route handlers with type hints\n- Creating Pydantic models for request/response validation\n- Adding automatic OpenAPI/Swagger documentation\n- Implementing async endpoints for I/O-bound operations\n- Setting up dependency injection for auth/database\n- Handling errors with custom exception handlers\n- Adding middleware for CORS, logging, rate limiting\n- Structuring large applications with routers\n\n## How to Use This Skill\n\n### Basic CRUD API\n\n**Prompt:** \"Create a FastAPI CRUD API for blog posts with: GET /posts (list), POST /posts (create), GET /posts/{id} (get one), PUT /posts/{id} (update), DELETE /posts/{id} (delete). Use Pydantic for validation.\"\n\nClaude will:\n1. Create FastAPI app with routers\n2. Define Pydantic models for Post\n3. Implement all 5 CRUD endpoints\n4. Add automatic validation\n5. Include OpenAPI docs at /docs\n6. Add error handling for 404s\n7. Return proper HTTP status codes\n\n### Database Integration with SQLAlchemy\n\n**Prompt:** \"Build FastAPI app with PostgreSQL using SQLAlchemy ORM. Include: user authentication, database models for users/posts, async queries, connection pooling, and migrations with Alembic.\"\n\nClaude will:\n1. Set up async SQLAlchemy engine\n2. Create database models with relationships\n3. Implement dependency injection for sessions\n4. Add async CRUD operations\n5. Include connection pooling config\n6. Set up Alembic for migrations\n7. Add authentication dependencies\n\n### Authentication & Authorization\n\n**Prompt:** \"Create FastAPI auth system with JWT tokens. Include: user registration, login, password hashing with bcrypt, protected routes with dependencies, refresh tokens, and role-based access control.\"\n\nClaude will:\n1. Implement password hashing with passlib\n2. Create JWT token generation/validation\n3. Add OAuth2 password bearer scheme\n4. Build auth dependencies for routes\n5. Implement refresh token rotation\n6. Add role-based access decorators\n7. Include user registration/login endpoints\n\n### Async Background Tasks\n\n**Prompt:** \"Build FastAPI endpoint that processes uploaded CSV file in background. Include: file upload validation, background task with progress tracking, webhook notification on completion, and error handling.\"\n\nClaude will:\n1. Create file upload endpoint\n2. Validate CSV format with Pydantic\n3. Launch background task\n4. Add progress tracking with Redis\n5. Implement webhook callback\n6. Handle errors gracefully\n7. Return task ID for status checks\n\n## Tips for Best Results\n\n1. **Use Type Hints Everywhere**: FastAPI relies on Python type hints for automatic validation and docs. Always specify return types and use `Optional[T]` for nullable fields.\n\n2. **Async for I/O-Bound**: Use `async def` for endpoints that do database queries, API calls, or file operations. FastAPI handles concurrency automatically.\n\n3. **Pydantic for Validation**: Create Pydantic models for request bodies. Never parse JSON manually - let Pydantic handle validation and serialization.\n\n4. **Dependency Injection**: Use FastAPI's `Depends()` for auth, database sessions, pagination, etc. This keeps endpoints clean and testable.\n\n5. **Status Codes Matter**: Use proper HTTP status codes: 201 for created, 204 for deleted, 404 for not found, 422 for validation errors.\n\n6. **OpenAPI Customization**: Add descriptions, examples, and tags to endpoints for better automatic documentation.\n\n## Common Workflows\n\n### E-Commerce API\n```\n\"Build FastAPI e-commerce backend:\n1. Products: CRUD with search, filtering, pagination\n2. Cart: session-based with Redis, add/remove items, calculate totals\n3. Orders: create order, payment processing, order history\n4. Auth: JWT-based customer accounts with OAuth2\n5. Admin: protected endpoints for inventory management\n6. Webhooks: Stripe payment notifications\n7. Database: PostgreSQL with async SQLAlchemy\n8. Background tasks: order confirmation emails\"\n```\n\n### Real-Time Analytics API\n```\n\"Create FastAPI analytics dashboard backend:\n1. Ingest endpoint: accept events via POST with Pydantic validation\n2. Time-series storage: TimescaleDB for event data\n3. Aggregation endpoints: metrics by day/week/month\n4. WebSocket: real-time updates for live dashboard\n5. Caching: Redis for frequently-accessed metrics\n6. Rate limiting: per-API-key limits with middleware\n7. Export: CSV/JSON download of filtered data\n8. Admin API: user management, API key generation\"\n```\n\n### Multi-Tenant SaaS API\n```\n\"Build multi-tenant SaaS API with FastAPI:\n1. Tenant isolation: subdomain-based routing\n2. Database: separate schemas per tenant in PostgreSQL\n3. Auth: tenant-scoped JWT tokens\n4. Billing: usage tracking, quota enforcement\n5. API versioning: /v1/, /v2/ with deprecation notices\n6. Rate limiting: per-tenant quotas\n7. Webhooks: tenant-configurable event notifications\n8. Admin: tenant provisioning, feature flags\"\n```\n\n### GraphQL + REST Hybrid\n```\n\"Create FastAPI app with both REST and GraphQL:\n1. REST endpoints: CRUD operations with OpenAPI docs\n2. GraphQL: Strawberry integration for complex queries\n3. DataLoader: batching and caching for N+1 queries\n4. Auth: shared JWT validation across REST/GraphQL\n5. Subscriptions: WebSocket support for real-time data\n6. File uploads: multipart form data handling\n7. Error handling: unified error format\n8. Testing: pytest fixtures for both APIs\"\n```\n\n## Troubleshooting\n\n**Issue:** \"Pydantic validation errors not showing custom messages\"\n**Solution:** Add Field() with description: `email: str = Field(..., description='Valid email required')`. Use @validator decorator for complex rules. Check Pydantic V2 migration if using FastAPI 0.100+.\n\n**Issue:** \"Async endpoints slower than sync\"\n**Solution:** Only use async for I/O operations (database, HTTP calls). CPU-bound tasks should use sync functions. Ensure database driver supports async (asyncpg, aiomysql). Check connection pool settings.\n\n**Issue:** \"CORS errors in browser\"\n**Solution:** Add CORSMiddleware with correct origins: `app.add_middleware(CORSMiddleware, allow_origins=['http://localhost:3000'], allow_credentials=True)`. Don't use wildcard in production.\n\n**Issue:** \"Dependency injection not working\"\n**Solution:** Ensure dependencies return values, not None. Use `Depends()` in function signature, not inside function body. Check dependency order - dependencies can depend on other dependencies.\n\n**Issue:** \"File uploads failing with 413 error\"\n**Solution:** Increase max upload size in uvicorn: `uvicorn.run(app, limit_concurrency=100, limit_max_requests=1000, timeout_keep_alive=30)`. For large files, use streaming with `UploadFile`.\n\n## Learn More\n\n- [FastAPI Official Documentation](https://fastapi.tiangolo.com/)\n- [FastAPI GitHub Repository](https://github.com/fastapi/fastapi)\n- [Pydantic V2 Documentation](https://docs.pydantic.dev/)\n- [SQLAlchemy Async Tutorial](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)\n- [FastAPI Full Stack Template](https://github.com/fastapi/full-stack-fastapi-template)\n- [FastAPI Best Practices](https://github.com/zhanymkanov/fastapi-best-practices)\n",
  "features": [
    "Automatic OpenAPI/Swagger documentation generation",
    "Native async/await support for high concurrency",
    "Pydantic integration for request/response validation",
    "Dependency injection system for clean architecture"
  ],
  "useCases": [
    "REST API backends with automatic documentation",
    "Microservices with async database operations",
    "Real-time APIs with WebSocket support"
  ],
  "requirements": [
    "Python 3.9+",
    "fastapi ^0.104.0",
    "uvicorn[standard] ^0.24.0",
    "pydantic ^2.0.0"
  ],
  "examples": [
    {
      "title": "Basic FastAPI Application",
      "language": "python",
      "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nfrom typing import List\n\napp = FastAPI(title=\"Blog API\", version=\"1.0.0\")\n\n# Pydantic models\nclass PostCreate(BaseModel):\n    title: str = Field(..., min_length=1, max_length=200)\n    content: str = Field(..., min_length=1)\n    published: bool = False\n\nclass Post(PostCreate):\n    id: int\n    \n    class Config:\n        from_attributes = True\n\n# In-memory storage (use database in production)\nposts_db: List[Post] = []\npost_id_counter = 1\n\n@app.get(\"/posts\", response_model=List[Post], tags=[\"posts\"])\nasync def list_posts():\n    \"\"\"Get all blog posts\"\"\"\n    return posts_db\n\n@app.post(\"/posts\", response_model=Post, status_code=201, tags=[\"posts\"])\nasync def create_post(post: PostCreate):\n    \"\"\"Create a new blog post\"\"\"\n    global post_id_counter\n    new_post = Post(id=post_id_counter, **post.dict())\n    posts_db.append(new_post)\n    post_id_counter += 1\n    return new_post\n\n@app.get(\"/posts/{post_id}\", response_model=Post, tags=[\"posts\"])\nasync def get_post(post_id: int):\n    \"\"\"Get a single post by ID\"\"\"\n    for post in posts_db:\n        if post.id == post_id:\n            return post\n    raise HTTPException(status_code=404, detail=\"Post not found\")\n\n@app.delete(\"/posts/{post_id}\", status_code=204, tags=[\"posts\"])\nasync def delete_post(post_id: int):\n    \"\"\"Delete a post by ID\"\"\"\n    for i, post in enumerate(posts_db):\n        if post.id == post_id:\n            posts_db.pop(i)\n            return\n    raise HTTPException(status_code=404, detail=\"Post not found\")\n\n# Run with: uvicorn main:app --reload\n# Docs at: http://localhost:8000/docs"
    },
    {
      "title": "Database Integration with SQLAlchemy",
      "language": "python",
      "code": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\nfrom pydantic import BaseModel\n\n# Database setup\nDATABASE_URL = \"postgresql+asyncpg://user:pass@localhost/dbname\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nAsyncSessionLocal = async_sessionmaker(engine, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    email: Mapped[str] = mapped_column(unique=True, index=True)\n    name: Mapped[str]\n\n# Pydantic schemas\nclass UserCreate(BaseModel):\n    email: str\n    name: str\n\nclass UserResponse(BaseModel):\n    id: int\n    email: str\n    name: str\n    \n    class Config:\n        from_attributes = True\n\napp = FastAPI()\n\n# Dependency injection for database session\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\n@app.post(\"/users\", response_model=UserResponse, status_code=201)\nasync def create_user(\n    user: UserCreate,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Create a new user\"\"\"\n    db_user = User(email=user.email, name=user.name)\n    db.add(db_user)\n    await db.commit()\n    await db.refresh(db_user)\n    return db_user\n\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get user by ID\"\"\"\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user"
    },
    {
      "title": "JWT Authentication",
      "language": "python",
      "code": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nSECRET_KEY = \"your-secret-key-here\"  # Use environment variable in production\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\napp = FastAPI()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Pydantic models\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass User(BaseModel):\n    username: str\n    email: str\n    disabled: Optional[bool] = None\n\n# Fake user database (use real database in production)\nfake_users_db = {\n    \"johndoe\": {\n        \"username\": \"johndoe\",\n        \"email\": \"john@example.com\",\n        \"hashed_password\": pwd_context.hash(\"secret\"),\n        \"disabled\": False,\n    }\n}\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = fake_users_db.get(username)\n    if user is None:\n        raise credentials_exception\n    return User(**user)\n\n@app.post(\"/token\", response_model=Token)\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = fake_users_db.get(form_data.username)\n    if not user or not pwd_context.verify(form_data.password, user[\"hashed_password\"]):\n        raise HTTPException(status_code=400, detail=\"Incorrect username or password\")\n    \n    access_token = create_access_token(\n        data={\"sub\": user[\"username\"]},\n        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me\", response_model=User)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"Protected endpoint - requires authentication\"\"\"\n    return current_user"
    }
  ],
  "installation": {
    "claudeDesktop": {
      "steps": [
        "Install FastAPI: pip install fastapi uvicorn[standard]",
        "Ask Claude: 'Create a FastAPI application for [your use case]'",
        "Claude generates routes, models, and documentation",
        "Run with: uvicorn main:app --reload"
      ]
    },
    "claudeCode": {
      "steps": [
        "pip install fastapi uvicorn[standard] pydantic sqlalchemy",
        "Create project structure: app/main.py, app/models/, app/routes/",
        "Run development server: uvicorn app.main:app --reload --host 0.0.0.0",
        "Access docs at http://localhost:8000/docs"
      ]
    }
  },
  "troubleshooting": [
    {
      "issue": "Pydantic validation not showing custom messages",
      "solution": "Use Field() with description parameter. Check Pydantic V2 migration if using FastAPI 0.100+. Add @validator decorators for complex validation rules."
    },
    {
      "issue": "Async endpoints performing slower than sync",
      "solution": "Only use async for I/O-bound operations (database, API calls). Ensure async database driver (asyncpg, aiomysql). Check connection pool configuration. CPU-bound tasks should use sync."
    },
    {
      "issue": "CORS errors blocking frontend requests",
      "solution": "Add CORSMiddleware with correct allow_origins. Don't use wildcard ('*') in production. Include allow_credentials=True for cookies. Restart uvicorn after middleware changes."
    }
  ],
  "documentationUrl": "https://fastapi.tiangolo.com/",
  "source": "community"
}
