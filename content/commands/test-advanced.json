{
  "description": "Advanced test suite generator with property-based testing, mutation testing, and intelligent test case discovery",
  "category": "commands",
  "author": "claudepro",
  "dateAdded": "2025-09-16",
  "tags": ["testing", "unit-tests", "integration-tests", "property-based", "mutation-testing"],
  "content": "The `/test` command generates comprehensive test suites with advanced testing methodologies including property-based testing, mutation testing, snapshot testing, and intelligent edge case discovery.\n\n## Usage\n\n```\n/test [options] <file_or_function>\n```\n\n## Options\n\n### Test Types\n- `--unit` - Unit tests with mocking and isolation\n- `--integration` - Integration tests with real dependencies\n- `--e2e` - End-to-end tests with full system simulation\n- `--property` - Property-based testing with hypothesis generation\n- `--mutation` - Mutation testing for test quality assessment\n- `--snapshot` - Snapshot testing for UI and output consistency\n- `--performance` - Performance and load testing\n- `--security` - Security and penetration testing\n- `--all` - Comprehensive test suite (default)\n\n### Testing Frameworks\n- `--jest` - Jest testing framework (JavaScript/TypeScript)\n- `--vitest` - Vitest testing framework (faster Jest alternative)\n- `--pytest` - pytest framework (Python)\n- `--junit` - JUnit framework (Java)\n- `--rspec` - RSpec framework (Ruby)\n- `--go-test` - Go testing package\n- `--rust-test` - Rust testing framework\n\n### Advanced Features\n- `--coverage` - Generate code coverage reports with detailed metrics\n- `--baseline` - Generate performance baselines and regression detection\n- `--fuzz` - Fuzzing tests with random input generation\n- `--contract` - Contract testing for API compatibility\n- `--visual` - Visual regression testing for UI components\n\n### AI-Powered Features\n- `--smart-cases` - AI-generated edge cases and corner cases\n- `--behavior-discovery` - Automatic behavior pattern recognition\n- `--test-oracle` - AI-powered test oracle generation\n- `--failure-prediction` - Predict likely failure scenarios\n\n## Examples\n\n### Advanced React Component Testing\n\n```jsx\n// Component to test: UserProfileCard.jsx\nimport React, { useState, useEffect } from 'react';\nimport { fetchUserProfile, updateUserProfile } from '../api/users';\nimport { useAuth } from '../hooks/useAuth';\nimport { toast } from '../utils/toast';\n\nconst UserProfileCard = ({ userId, onProfileUpdate, editable = false }) => {\n  const [profile, setProfile] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [editing, setEditing] = useState(false);\n  const [formData, setFormData] = useState({});\n  const [errors, setErrors] = useState({});\n  \n  const { user: currentUser } = useAuth();\n  \n  useEffect(() => {\n    loadProfile();\n  }, [userId]);\n  \n  const loadProfile = async () => {\n    try {\n      setLoading(true);\n      const userProfile = await fetchUserProfile(userId);\n      setProfile(userProfile);\n      setFormData({\n        name: userProfile.name,\n        email: userProfile.email,\n        bio: userProfile.bio || ''\n      });\n    } catch (error) {\n      toast.error('Failed to load profile');\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const validateForm = () => {\n    const newErrors = {};\n    \n    if (!formData.name?.trim()) {\n      newErrors.name = 'Name is required';\n    } else if (formData.name.length < 2) {\n      newErrors.name = 'Name must be at least 2 characters';\n    } else if (formData.name.length > 100) {\n      newErrors.name = 'Name must be less than 100 characters';\n    }\n    \n    if (!formData.email?.trim()) {\n      newErrors.email = 'Email is required';\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(formData.email)) {\n      newErrors.email = 'Invalid email format';\n    }\n    \n    if (formData.bio && formData.bio.length > 500) {\n      newErrors.bio = 'Bio must be less than 500 characters';\n    }\n    \n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n  \n  const handleSave = async () => {\n    if (!validateForm()) return;\n    \n    try {\n      setLoading(true);\n      const updatedProfile = await updateUserProfile(userId, formData);\n      setProfile(updatedProfile);\n      setEditing(false);\n      toast.success('Profile updated successfully');\n      onProfileUpdate?.(updatedProfile);\n    } catch (error) {\n      if (error.status === 409) {\n        setErrors({ email: 'Email already exists' });\n      } else {\n        toast.error('Failed to update profile');\n      }\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const canEdit = editable && (currentUser?.id === userId || currentUser?.role === 'admin');\n  \n  if (loading && !profile) {\n    return <div data-testid=\"loading-spinner\">Loading...</div>;\n  }\n  \n  if (!profile) {\n    return <div data-testid=\"error-message\">Profile not found</div>;\n  }\n  \n  return (\n    <div data-testid=\"user-profile-card\" className=\"profile-card\">\n      <div className=\"profile-header\">\n        <img \n          src={profile.avatar || '/default-avatar.png'} \n          alt={`${profile.name}'s avatar`}\n          data-testid=\"profile-avatar\"\n        />\n        {editing ? (\n          <input\n            type=\"text\"\n            value={formData.name}\n            onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}\n            data-testid=\"name-input\"\n            className={errors.name ? 'error' : ''}\n            placeholder=\"Enter name\"\n          />\n        ) : (\n          <h2 data-testid=\"profile-name\">{profile.name}</h2>\n        )}\n        {errors.name && <span data-testid=\"name-error\" className=\"error\">{errors.name}</span>}\n      </div>\n      \n      <div className=\"profile-details\">\n        <div className=\"detail-item\">\n          <label>Email:</label>\n          {editing ? (\n            <input\n              type=\"email\"\n              value={formData.email}\n              onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}\n              data-testid=\"email-input\"\n              className={errors.email ? 'error' : ''}\n            />\n          ) : (\n            <span data-testid=\"profile-email\">{profile.email}</span>\n          )}\n          {errors.email && <span data-testid=\"email-error\" className=\"error\">{errors.email}</span>}\n        </div>\n        \n        <div className=\"detail-item\">\n          <label>Bio:</label>\n          {editing ? (\n            <textarea\n              value={formData.bio}\n              onChange={(e) => setFormData(prev => ({ ...prev, bio: e.target.value }))}\n              data-testid=\"bio-input\"\n              className={errors.bio ? 'error' : ''}\n              placeholder=\"Tell us about yourself...\"\n              maxLength={500}\n            />\n          ) : (\n            <p data-testid=\"profile-bio\">{profile.bio || 'No bio available'}</p>\n          )}\n          {errors.bio && <span data-testid=\"bio-error\" className=\"error\">{errors.bio}</span>}\n        </div>\n      </div>\n      \n      {canEdit && (\n        <div className=\"profile-actions\">\n          {editing ? (\n            <>\n              <button\n                onClick={handleSave}\n                disabled={loading}\n                data-testid=\"save-button\"\n                className=\"btn-primary\"\n              >\n                {loading ? 'Saving...' : 'Save Changes'}\n              </button>\n              <button\n                onClick={() => {\n                  setEditing(false);\n                  setFormData({\n                    name: profile.name,\n                    email: profile.email,\n                    bio: profile.bio || ''\n                  });\n                  setErrors({});\n                }}\n                disabled={loading}\n                data-testid=\"cancel-button\"\n                className=\"btn-secondary\"\n              >\n                Cancel\n              </button>\n            </>\n          ) : (\n            <button\n              onClick={() => setEditing(true)}\n              data-testid=\"edit-button\"\n              className=\"btn-primary\"\n            >\n              Edit Profile\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default UserProfileCard;\n```\n\n**Generated Advanced Test Suite:**\n\n```javascript\n// UserProfileCard.test.jsx - Comprehensive Test Suite\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { faker } from '@faker-js/faker';\nimport fc from 'fast-check';\nimport { axe, toHaveNoViolations } from 'jest-axe';\n\nimport UserProfileCard from '../UserProfileCard';\nimport { fetchUserProfile, updateUserProfile } from '../api/users';\nimport { useAuth } from '../hooks/useAuth';\nimport { toast } from '../utils/toast';\n\n// Extend Jest matchers\nexpect.extend(toHaveNoViolations);\n\n// Mock dependencies\nvi.mock('../api/users');\nvi.mock('../hooks/useAuth');\nvi.mock('../utils/toast');\n\nconst mockFetchUserProfile = vi.mocked(fetchUserProfile);\nconst mockUpdateUserProfile = vi.mocked(updateUserProfile);\nconst mockUseAuth = vi.mocked(useAuth);\nconst mockToast = vi.mocked(toast);\n\n// Test data generators\nconst generateValidUser = () => ({\n  id: faker.string.uuid(),\n  name: faker.person.fullName(),\n  email: faker.internet.email(),\n  bio: faker.lorem.paragraph(),\n  avatar: faker.image.avatar(),\n  createdAt: faker.date.past().toISOString(),\n  updatedAt: faker.date.recent().toISOString()\n});\n\nconst generateInvalidUser = () => ({\n  id: '',\n  name: '',\n  email: 'invalid-email',\n  bio: 'x'.repeat(600), // Exceeds 500 char limit\n  avatar: null\n});\n\n// Custom render function with providers\nconst renderUserProfileCard = (props = {}) => {\n  const defaultProps = {\n    userId: faker.string.uuid(),\n    editable: false,\n    onProfileUpdate: vi.fn(),\n    ...props\n  };\n  \n  return {\n    ...render(<UserProfileCard {...defaultProps} />),\n    props: defaultProps\n  };\n};\n\ndescribe('UserProfileCard', () => {\n  let mockCurrentUser;\n  \n  beforeEach(() => {\n    vi.clearAllMocks();\n    \n    // Default auth state\n    mockCurrentUser = generateValidUser();\n    mockUseAuth.mockReturnValue({ user: mockCurrentUser });\n    \n    // Default toast implementation\n    mockToast.success = vi.fn();\n    mockToast.error = vi.fn();\n  });\n  \n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n  \n  describe('Loading States', () => {\n    it('should show loading spinner while fetching profile', () => {\n      mockFetchUserProfile.mockImplementation(() => new Promise(() => {})); // Never resolves\n      \n      renderUserProfileCard();\n      \n      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n      expect(screen.getByText('Loading...')).toBeInTheDocument();\n    });\n    \n    it('should show loading button text while saving', async () => {\n      const user = userEvent.setup();\n      const mockProfile = generateValidUser();\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      mockUpdateUserProfile.mockImplementation(() => new Promise(() => {})); // Never resolves\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toHaveTextContent(mockProfile.name);\n      });\n      \n      await user.click(screen.getByTestId('edit-button'));\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('save-button')).toHaveTextContent('Saving...');\n      expect(screen.getByTestId('save-button')).toBeDisabled();\n      expect(screen.getByTestId('cancel-button')).toBeDisabled();\n    });\n  });\n  \n  describe('Profile Display', () => {\n    it('should display profile information correctly', async () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toHaveTextContent(mockProfile.name);\n      });\n      \n      expect(screen.getByTestId('profile-email')).toHaveTextContent(mockProfile.email);\n      expect(screen.getByTestId('profile-bio')).toHaveTextContent(mockProfile.bio);\n      expect(screen.getByTestId('profile-avatar')).toHaveAttribute('src', mockProfile.avatar);\n      expect(screen.getByTestId('profile-avatar')).toHaveAttribute('alt', `${mockProfile.name}'s avatar`);\n    });\n    \n    it('should display default avatar when user has no avatar', async () => {\n      const mockProfile = { ...generateValidUser(), avatar: null };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-avatar')).toHaveAttribute('src', '/default-avatar.png');\n      });\n    });\n    \n    it('should display \"No bio available\" when user has no bio', async () => {\n      const mockProfile = { ...generateValidUser(), bio: null };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-bio')).toHaveTextContent('No bio available');\n      });\n    });\n  });\n  \n  describe('Error Handling', () => {\n    it('should show error message when profile fetch fails', async () => {\n      const errorMessage = 'Network error';\n      mockFetchUserProfile.mockRejectedValue(new Error(errorMessage));\n      \n      renderUserProfileCard();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('error-message')).toBeInTheDocument();\n      });\n      \n      expect(mockToast.error).toHaveBeenCalledWith('Failed to load profile');\n    });\n    \n    it('should handle API errors during profile update', async () => {\n      const user = userEvent.setup();\n      const mockProfile = generateValidUser();\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      mockUpdateUserProfile.mockRejectedValue(new Error('Server error'));\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      await user.click(screen.getByTestId('edit-button'));\n      await user.clear(screen.getByTestId('name-input'));\n      await user.type(screen.getByTestId('name-input'), 'Updated Name');\n      await user.click(screen.getByTestId('save-button'));\n      \n      await waitFor(() => {\n        expect(mockToast.error).toHaveBeenCalledWith('Failed to update profile');\n      });\n    });\n    \n    it('should handle email conflict error specifically', async () => {\n      const user = userEvent.setup();\n      const mockProfile = generateValidUser();\n      const conflictError = new Error('Conflict');\n      conflictError.status = 409;\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      mockUpdateUserProfile.mockRejectedValue(conflictError);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      await user.click(screen.getByTestId('edit-button'));\n      await user.clear(screen.getByTestId('email-input'));\n      await user.type(screen.getByTestId('email-input'), 'existing@example.com');\n      await user.click(screen.getByTestId('save-button'));\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('email-error')).toHaveTextContent('Email already exists');\n      });\n    });\n  });\n  \n  describe('Permission System', () => {\n    it('should show edit button for profile owner', async () => {\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n    });\n    \n    it('should show edit button for admin users', async () => {\n      const mockProfile = generateValidUser();\n      const adminUser = { ...mockCurrentUser, role: 'admin' };\n      \n      mockUseAuth.mockReturnValue({ user: adminUser });\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n    });\n    \n    it('should not show edit button for other users', async () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toBeInTheDocument();\n      });\n      \n      expect(screen.queryByTestId('edit-button')).not.toBeInTheDocument();\n    });\n    \n    it('should not show edit button when editable is false', async () => {\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: false \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toBeInTheDocument();\n      });\n      \n      expect(screen.queryByTestId('edit-button')).not.toBeInTheDocument();\n    });\n  });\n  \n  describe('Form Validation', () => {\n    beforeEach(async () => {\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      await userEvent.setup().click(screen.getByTestId('edit-button'));\n    });\n    \n    it('should validate required name field', async () => {\n      const user = userEvent.setup();\n      \n      await user.clear(screen.getByTestId('name-input'));\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('name-error')).toHaveTextContent('Name is required');\n      expect(mockUpdateUserProfile).not.toHaveBeenCalled();\n    });\n    \n    it('should validate minimum name length', async () => {\n      const user = userEvent.setup();\n      \n      await user.clear(screen.getByTestId('name-input'));\n      await user.type(screen.getByTestId('name-input'), 'A');\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('name-error')).toHaveTextContent('Name must be at least 2 characters');\n    });\n    \n    it('should validate maximum name length', async () => {\n      const user = userEvent.setup();\n      const longName = 'A'.repeat(101);\n      \n      await user.clear(screen.getByTestId('name-input'));\n      await user.type(screen.getByTestId('name-input'), longName);\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('name-error')).toHaveTextContent('Name must be less than 100 characters');\n    });\n    \n    it('should validate required email field', async () => {\n      const user = userEvent.setup();\n      \n      await user.clear(screen.getByTestId('email-input'));\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('email-error')).toHaveTextContent('Email is required');\n    });\n    \n    it('should validate email format', async () => {\n      const user = userEvent.setup();\n      \n      await user.clear(screen.getByTestId('email-input'));\n      await user.type(screen.getByTestId('email-input'), 'invalid-email');\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('email-error')).toHaveTextContent('Invalid email format');\n    });\n    \n    it('should validate bio length', async () => {\n      const user = userEvent.setup();\n      const longBio = 'A'.repeat(501);\n      \n      await user.clear(screen.getByTestId('bio-input'));\n      await user.type(screen.getByTestId('bio-input'), longBio);\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.getByTestId('bio-error')).toHaveTextContent('Bio must be less than 500 characters');\n    });\n    \n    it('should allow empty bio', async () => {\n      const user = userEvent.setup();\n      const updatedProfile = generateValidUser();\n      \n      mockUpdateUserProfile.mockResolvedValue(updatedProfile);\n      \n      await user.clear(screen.getByTestId('bio-input'));\n      await user.click(screen.getByTestId('save-button'));\n      \n      expect(screen.queryByTestId('bio-error')).not.toBeInTheDocument();\n      expect(mockUpdateUserProfile).toHaveBeenCalled();\n    });\n  });\n  \n  describe('Edit Mode Functionality', () => {\n    let mockProfile;\n    \n    beforeEach(async () => {\n      mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n    });\n    \n    it('should switch to edit mode when edit button is clicked', async () => {\n      const user = userEvent.setup();\n      \n      await user.click(screen.getByTestId('edit-button'));\n      \n      expect(screen.getByTestId('name-input')).toHaveValue(mockProfile.name);\n      expect(screen.getByTestId('email-input')).toHaveValue(mockProfile.email);\n      expect(screen.getByTestId('bio-input')).toHaveValue(mockProfile.bio);\n      expect(screen.getByTestId('save-button')).toBeInTheDocument();\n      expect(screen.getByTestId('cancel-button')).toBeInTheDocument();\n      expect(screen.queryByTestId('edit-button')).not.toBeInTheDocument();\n    });\n    \n    it('should cancel edit mode and restore original values', async () => {\n      const user = userEvent.setup();\n      \n      await user.click(screen.getByTestId('edit-button'));\n      \n      // Make changes\n      await user.clear(screen.getByTestId('name-input'));\n      await user.type(screen.getByTestId('name-input'), 'Changed Name');\n      \n      // Cancel\n      await user.click(screen.getByTestId('cancel-button'));\n      \n      expect(screen.getByTestId('profile-name')).toHaveTextContent(mockProfile.name);\n      expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      expect(screen.queryByTestId('save-button')).not.toBeInTheDocument();\n    });\n    \n    it('should save changes and exit edit mode', async () => {\n      const user = userEvent.setup();\n      const updatedProfile = {\n        ...mockProfile,\n        name: 'Updated Name',\n        email: 'updated@example.com'\n      };\n      \n      mockUpdateUserProfile.mockResolvedValue(updatedProfile);\n      \n      await user.click(screen.getByTestId('edit-button'));\n      \n      await user.clear(screen.getByTestId('name-input'));\n      await user.type(screen.getByTestId('name-input'), updatedProfile.name);\n      \n      await user.clear(screen.getByTestId('email-input'));\n      await user.type(screen.getByTestId('email-input'), updatedProfile.email);\n      \n      await user.click(screen.getByTestId('save-button'));\n      \n      await waitFor(() => {\n        expect(mockUpdateUserProfile).toHaveBeenCalledWith(mockProfile.id, {\n          name: updatedProfile.name,\n          email: updatedProfile.email,\n          bio: mockProfile.bio\n        });\n      });\n      \n      expect(mockToast.success).toHaveBeenCalledWith('Profile updated successfully');\n      expect(screen.getByTestId('profile-name')).toHaveTextContent(updatedProfile.name);\n      expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n    });\n  });\n  \n  describe('Callback Functions', () => {\n    it('should call onProfileUpdate callback after successful save', async () => {\n      const user = userEvent.setup();\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      const updatedProfile = { ...mockProfile, name: 'Updated Name' };\n      const mockOnProfileUpdate = vi.fn();\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      mockUpdateUserProfile.mockResolvedValue(updatedProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true,\n        onProfileUpdate: mockOnProfileUpdate\n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      await user.click(screen.getByTestId('edit-button'));\n      await user.clear(screen.getByTestId('name-input'));\n      await user.type(screen.getByTestId('name-input'), updatedProfile.name);\n      await user.click(screen.getByTestId('save-button'));\n      \n      await waitFor(() => {\n        expect(mockOnProfileUpdate).toHaveBeenCalledWith(updatedProfile);\n      });\n    });\n    \n    it('should not call onProfileUpdate callback on save failure', async () => {\n      const user = userEvent.setup();\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      const mockOnProfileUpdate = vi.fn();\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      mockUpdateUserProfile.mockRejectedValue(new Error('Save failed'));\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true,\n        onProfileUpdate: mockOnProfileUpdate\n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      await user.click(screen.getByTestId('edit-button'));\n      await user.click(screen.getByTestId('save-button'));\n      \n      await waitFor(() => {\n        expect(mockToast.error).toHaveBeenCalled();\n      });\n      \n      expect(mockOnProfileUpdate).not.toHaveBeenCalled();\n    });\n  });\n  \n  describe('Accessibility', () => {\n    it('should have no accessibility violations', async () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      const { container } = renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toBeInTheDocument();\n      });\n      \n      const results = await axe(container);\n      expect(results).toHaveNoViolations();\n    });\n    \n    it('should have proper ARIA labels and roles', async () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ userId: mockProfile.id, editable: true });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      const avatar = screen.getByTestId('profile-avatar');\n      expect(avatar).toHaveAttribute('alt', `${mockProfile.name}'s avatar`);\n      \n      await userEvent.setup().click(screen.getByTestId('edit-button'));\n      \n      const nameInput = screen.getByTestId('name-input');\n      expect(nameInput).toHaveAttribute('placeholder', 'Enter name');\n      \n      const bioInput = screen.getByTestId('bio-input');\n      expect(bioInput).toHaveAttribute('placeholder', 'Tell us about yourself...');\n      expect(bioInput).toHaveAttribute('maxLength', '500');\n    });\n  });\n  \n  describe('Property-Based Testing', () => {\n    it('should handle any valid user profile data', () => {\n      fc.assert(\n        fc.property(\n          fc.record({\n            id: fc.string({ minLength: 1 }),\n            name: fc.string({ minLength: 2, maxLength: 100 }),\n            email: fc.emailAddress(),\n            bio: fc.option(fc.string({ maxLength: 500 }), { nil: undefined }),\n            avatar: fc.option(fc.webUrl(), { nil: undefined })\n          }),\n          (profile) => {\n            mockFetchUserProfile.mockResolvedValue(profile);\n            \n            const { unmount } = renderUserProfileCard({ userId: profile.id });\n            \n            // Should not throw any errors\n            expect(() => {\n              screen.getByTestId('user-profile-card');\n            }).not.toThrow();\n            \n            unmount();\n          }\n        ),\n        { numRuns: 100 }\n      );\n    });\n    \n    it('should validate form inputs with random invalid data', () => {\n      fc.assert(\n        fc.property(\n          fc.record({\n            name: fc.oneof(\n              fc.constant(''), // Empty string\n              fc.string({ minLength: 1, maxLength: 1 }), // Too short\n              fc.string({ minLength: 101, maxLength: 200 }), // Too long\n            ),\n            email: fc.oneof(\n              fc.constant(''), // Empty string\n              fc.string().filter(s => !s.includes('@')), // Invalid format\n              fc.string().map(s => s + '@'), // Incomplete email\n            ),\n            bio: fc.string({ minLength: 501, maxLength: 1000 }) // Too long\n          }),\n          async (invalidData) => {\n            const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n            mockFetchUserProfile.mockResolvedValue(mockProfile);\n            \n            const { unmount } = renderUserProfileCard({ \n              userId: mockProfile.id, \n              editable: true \n            });\n            \n            await waitFor(() => {\n              expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n            });\n            \n            const user = userEvent.setup();\n            await user.click(screen.getByTestId('edit-button'));\n            \n            // Fill form with invalid data\n            await user.clear(screen.getByTestId('name-input'));\n            await user.type(screen.getByTestId('name-input'), invalidData.name);\n            \n            await user.clear(screen.getByTestId('email-input'));\n            await user.type(screen.getByTestId('email-input'), invalidData.email);\n            \n            await user.clear(screen.getByTestId('bio-input'));\n            await user.type(screen.getByTestId('bio-input'), invalidData.bio);\n            \n            await user.click(screen.getByTestId('save-button'));\n            \n            // Should show validation errors\n            expect(\n              screen.queryByTestId('name-error') ||\n              screen.queryByTestId('email-error') ||\n              screen.queryByTestId('bio-error')\n            ).toBeInTheDocument();\n            \n            // Should not call update API\n            expect(mockUpdateUserProfile).not.toHaveBeenCalled();\n            \n            unmount();\n          }\n        ),\n        { numRuns: 50 }\n      );\n    });\n  });\n  \n  describe('Performance Testing', () => {\n    it('should render within performance budget', async () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      const startTime = performance.now();\n      \n      renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toBeInTheDocument();\n      });\n      \n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n      \n      // Should render within 100ms\n      expect(renderTime).toBeLessThan(100);\n    });\n    \n    it('should handle rapid state changes without performance degradation', async () => {\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      mockUpdateUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      const user = userEvent.setup();\n      const startTime = performance.now();\n      \n      // Rapid edit mode toggling\n      for (let i = 0; i < 10; i++) {\n        await user.click(screen.getByTestId('edit-button'));\n        await user.click(screen.getByTestId('cancel-button'));\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      // Should complete all operations within 500ms\n      expect(totalTime).toBeLessThan(500);\n    });\n  });\n  \n  describe('Visual Regression Testing', () => {\n    it('should match visual snapshot in display mode', async () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      const { container } = renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toBeInTheDocument();\n      });\n      \n      expect(container.firstChild).toMatchSnapshot('user-profile-display-mode');\n    });\n    \n    it('should match visual snapshot in edit mode', async () => {\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      const { container } = renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      await userEvent.setup().click(screen.getByTestId('edit-button'));\n      \n      expect(container.firstChild).toMatchSnapshot('user-profile-edit-mode');\n    });\n  });\n  \n  describe('Integration Testing', () => {\n    it('should integrate correctly with auth system', async () => {\n      const adminUser = { ...mockCurrentUser, role: 'admin' };\n      const regularUser = generateValidUser();\n      \n      // Test as admin\n      mockUseAuth.mockReturnValue({ user: adminUser });\n      mockFetchUserProfile.mockResolvedValue(regularUser);\n      \n      const { rerender } = renderUserProfileCard({ \n        userId: regularUser.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      // Switch to regular user\n      mockUseAuth.mockReturnValue({ user: regularUser });\n      \n      rerender(\n        <UserProfileCard \n          userId={regularUser.id} \n          editable={true}\n          onProfileUpdate={vi.fn()}\n        />\n      );\n      \n      expect(screen.queryByTestId('edit-button')).not.toBeInTheDocument();\n    });\n  });\n  \n  describe('Edge Cases', () => {\n    it('should handle extremely long profile data gracefully', async () => {\n      const mockProfile = {\n        ...generateValidUser(),\n        name: 'A'.repeat(1000),\n        bio: 'B'.repeat(10000)\n      };\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('user-profile-card')).toBeInTheDocument();\n      });\n      \n      // Should not break rendering\n      expect(screen.getByTestId('profile-name')).toBeInTheDocument();\n      expect(screen.getByTestId('profile-bio')).toBeInTheDocument();\n    });\n    \n    it('should handle special characters in profile data', async () => {\n      const mockProfile = {\n        ...generateValidUser(),\n        name: '测试用户 🚀 <script>alert(\"xss\")</script>',\n        bio: 'Bio with 🎉 emojis and <b>HTML</b> & special chars: @#$%^&*()'\n      };\n      \n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ userId: mockProfile.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toHaveTextContent(mockProfile.name);\n      });\n      \n      // Should display special characters safely\n      expect(screen.getByTestId('profile-bio')).toHaveTextContent(mockProfile.bio);\n    });\n    \n    it('should handle rapid prop changes', async () => {\n      const user1 = generateValidUser();\n      const user2 = generateValidUser();\n      \n      mockFetchUserProfile.mockImplementation((id) => {\n        if (id === user1.id) return Promise.resolve(user1);\n        if (id === user2.id) return Promise.resolve(user2);\n        return Promise.reject(new Error('User not found'));\n      });\n      \n      const { rerender } = renderUserProfileCard({ userId: user1.id });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toHaveTextContent(user1.name);\n      });\n      \n      // Rapidly change user ID\n      rerender(\n        <UserProfileCard \n          userId={user2.id}\n          editable={false}\n          onProfileUpdate={vi.fn()}\n        />\n      );\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('profile-name')).toHaveTextContent(user2.name);\n      });\n      \n      expect(mockFetchUserProfile).toHaveBeenCalledWith(user1.id);\n      expect(mockFetchUserProfile).toHaveBeenCalledWith(user2.id);\n    });\n  });\n});\n\n// Mutation Testing Configuration\nexport const mutationTestConfig = {\n  testMatch: ['**/*.test.{js,jsx}'],\n  mutators: [\n    'ArithmeticOperator',\n    'ArrayDeclaration',\n    'ArrowFunction',\n    'Block',\n    'BooleanLiteral',\n    'ConditionalExpression',\n    'EqualityOperator',\n    'LogicalOperator',\n    'MethodExpression',\n    'ObjectLiteral',\n    'StringLiteral',\n    'UnaryOperator',\n    'UpdateOperator'\n  ],\n  thresholds: {\n    high: 90,\n    low: 80\n  },\n  timeoutMS: 30000,\n  maxConcurrentTestRunners: 4\n};\n\n// Performance benchmarking\nexport const performanceBenchmarks = {\n  'UserProfileCard render time': {\n    threshold: 100, // milliseconds\n    setup: () => {\n      const mockProfile = generateValidUser();\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      return { userId: mockProfile.id };\n    },\n    test: (props) => {\n      const start = performance.now();\n      renderUserProfileCard(props);\n      return performance.now() - start;\n    }\n  },\n  'Edit mode transition': {\n    threshold: 50,\n    setup: async () => {\n      const mockProfile = { ...generateValidUser(), id: mockCurrentUser.id };\n      mockFetchUserProfile.mockResolvedValue(mockProfile);\n      \n      renderUserProfileCard({ \n        userId: mockProfile.id, \n        editable: true \n      });\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('edit-button')).toBeInTheDocument();\n      });\n      \n      return { editButton: screen.getByTestId('edit-button') };\n    },\n    test: async ({ editButton }) => {\n      const start = performance.now();\n      await userEvent.setup().click(editButton);\n      await waitFor(() => {\n        expect(screen.getByTestId('save-button')).toBeInTheDocument();\n      });\n      return performance.now() - start;\n    }\n  }\n};\n```\n\n## Advanced Testing Features\n\n### Mutation Testing\n- **Code Quality Assessment**: Measures test suite effectiveness\n- **Fault Detection**: Identifies weak test coverage areas\n- **Test Improvement**: Suggests additional test cases\n- **Quality Metrics**: Provides mutation score and coverage analytics\n\n### Property-Based Testing\n- **Hypothesis Generation**: AI-powered test case creation\n- **Edge Case Discovery**: Automatic boundary value testing\n- **Invariant Verification**: Ensures consistent behavior patterns\n- **Input Space Exploration**: Comprehensive input combination testing\n\n### Visual Regression Testing\n- **UI Consistency**: Detects unintended visual changes\n- **Cross-browser Testing**: Validates appearance across platforms\n- **Responsive Testing**: Ensures mobile/desktop compatibility\n- **Component Isolation**: Tests individual component rendering\n\n### Performance Testing\n- **Render Performance**: Measures component render times\n- **Memory Usage**: Tracks memory leaks and optimization opportunities\n- **User Interaction**: Benchmarks user interaction responsiveness\n- **Load Testing**: Simulates high-frequency usage patterns\n\nThis advanced test generator creates comprehensive, maintainable test suites that ensure code quality, performance, and reliability across all application layers.",
  "configuration": {
    "temperature": 0.2,
    "maxTokens": 16000,
    "systemPrompt": "You are a testing expert specializing in comprehensive test strategy, advanced testing methodologies, and test automation. Generate thorough, maintainable test suites with multiple testing approaches."
  },
  "githubUrl": "https://github.com/claudepro/advanced-test-generator",
  "documentationUrl": "https://docs.claude.ai/commands/test",
  "troubleshooting": [
    {
      "issue": "Generated tests fail with 'module not found' or import path errors",
      "solution": "Verify test framework installed: npm list jest vitest. Check tsconfig.json paths mapping. Update imports to match project structure. Run: npm test --verbose."
    },
    {
      "issue": "Property-based tests timeout or generate too many test cases",
      "solution": "Reduce fc.assert numRuns parameter to 50-100. Add timeout: jest.setTimeout(10000). Constrain input generators: fc.string({ maxLength: 100 })."
    },
    {
      "issue": "Mock setup complex or generated mocks don't match real implementation",
      "solution": "Use --integration for real dependencies. Verify mock return types match actual. Update mocks: vi.mocked(fn).mockImplementation(realFn). Check mock calls order."
    },
    {
      "issue": "Mutation testing score low despite high code coverage percentage",
      "solution": "Add boundary value tests for conditionals. Test error paths and edge cases. Use --mutation flag to identify weak assertions. Verify test quality not just coverage."
    },
    {
      "issue": "Visual regression tests failing due to rendering inconsistencies",
      "solution": "Use --visual with fixed viewport sizes. Disable animations in test environment. Update snapshots: npm test -- -u. Run in Docker for consistent rendering."
    },
    {
      "issue": "Snapshot tests break on every CI run with formatting differences",
      "solution": "Normalize snapshots with --no-inline-snapshots. Configure prettier consistently: npx prettier --write **/*.snap. Use toMatchInlineSnapshot for stability."
    },
    {
      "issue": "Fast-check property tests detect incompetent mutants or type errors",
      "solution": "Add type constraints to generators: fc.integer().filter(n => n > 0). Use fc.pre() for preconditions. Constrain infinite problem space with bounded generators."
    },
    {
      "issue": "Performance baseline tests fail with inconsistent timing measurements",
      "solution": "Run benchmarks with --baseline multiple times for average. Disable CPU throttling. Use performance.mark() API. Isolate tests: --runInBand for sequential execution."
    },
    {
      "issue": "Accessibility tests with jest-axe report too many violations to fix",
      "solution": "Start with critical issues: filter by impact level. Fix incrementally: test one component at a time. Configure axe rules: exclude low-priority ARIA violations."
    },
    {
      "issue": "Test suite memory leaks crash CI with out-of-memory errors",
      "solution": "Increase Node.js memory: NODE_OPTIONS=--max-old-space-size=4096. Use --detectLeaks flag. Clear timers in afterEach. Run tests in isolation: --maxWorkers=1."
    }
  ],
  "source": "community",
  "slug": "test-advanced"
}
