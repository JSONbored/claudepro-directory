{
  "description": "Implement test-driven development workflows with Claude Code using red-green-refactor cycles, automatic test generation, and AI-guided iteration until all tests pass",
  "category": "commands",
  "author": "JSONbored",
  "dateAdded": "2025-10-25",
  "tags": ["tdd", "testing", "red-green-refactor", "test-automation", "quality", "ai-testing"],
  "content": "The `/tdd-workflow` command implements test-driven development (TDD) in Claude Code with AI-assisted red-green-refactor cycles, preventing hallucination through test-anchored iteration.\n\n## Features\n\n- **Red-Green-Refactor Automation**: Full TDD cycle with failing tests → passing code → optimization\n- **Test-First Enforcement**: Claude writes tests BEFORE implementing features\n- **Iteration Until Pass**: AI refines code until all tests pass (no manual fixes)\n- **Anti-Hallucination**: Tests serve as ground truth preventing scope drift\n- **Coverage Tracking**: Automatic code coverage measurement (80%+ target)\n- **Test Templates**: Pre-built patterns for unit, integration, and E2E tests\n- **Framework Support**: Vitest, Jest, Playwright, Cypress\n- **Continuous Verification**: Run tests after each code change\n\n## Usage\n\n```bash\n/tdd-workflow [feature] [options]\n```\n\n### Workflow Modes\n\n- `--unit` - Unit test TDD workflow (default)\n- `--integration` - Integration test workflow\n- `--e2e` - End-to-end test workflow\n- `--full` - Complete test pyramid (unit + integration + e2e)\n\n### Test Frameworks\n\n- `--vitest` - Vitest (default for unit/integration)\n- `--jest` - Jest testing framework\n- `--playwright` - Playwright for E2E\n- `--cypress` - Cypress for E2E\n\n### Coverage Options\n\n- `--coverage` - Generate coverage report (default: true)\n- `--min-coverage=<percent>` - Minimum coverage threshold (default: 80)\n- `--strict` - Fail if coverage below threshold\n\n### Behavior Modifiers\n\n- `--watch` - Watch mode, re-run tests on file changes\n- `--debug` - Show detailed test execution logs\n- `--commit-on-green` - Auto-commit when all tests pass\n\n## Examples\n\n### Basic TDD Workflow - User Authentication\n\n**Command:**\n```bash\n/tdd-workflow \"user authentication service with email/password\" --unit\n```\n\n**TDD Cycle:**\n\n**Phase 1: RED (Write Failing Tests)**\n```typescript\n// Claude generates: tests/unit/auth.service.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { AuthService } from '@/services/auth.service';\n\ndescribe('AuthService', () => {\n  let authService: AuthService;\n\n  beforeEach(() => {\n    authService = new AuthService();\n  });\n\n  describe('login', () => {\n    it('should return user token for valid credentials', async () => {\n      const result = await authService.login({\n        email: 'user@example.com',\n        password: 'ValidPass123'\n      });\n\n      expect(result).toHaveProperty('token');\n      expect(result).toHaveProperty('user');\n      expect(result.user.email).toBe('user@example.com');\n    });\n\n    it('should throw error for invalid email', async () => {\n      await expect(\n        authService.login({ email: 'invalid', password: 'pass' })\n      ).rejects.toThrow('Invalid email format');\n    });\n\n    it('should throw error for incorrect password', async () => {\n      await expect(\n        authService.login({ email: 'user@example.com', password: 'wrong' })\n      ).rejects.toThrow('Invalid credentials');\n    });\n\n    it('should hash password before comparison', async () => {\n      const loginSpy = vi.spyOn(authService, 'comparePassword');\n      await authService.login({ email: 'user@example.com', password: 'pass' });\n      \n      expect(loginSpy).toHaveBeenCalledWith('pass', expect.any(String));\n    });\n  });\n\n  describe('register', () => {\n    it('should create new user and return token', async () => {\n      const result = await authService.register({\n        email: 'new@example.com',\n        password: 'ValidPass123',\n        name: 'New User'\n      });\n\n      expect(result).toHaveProperty('token');\n      expect(result.user.email).toBe('new@example.com');\n    });\n\n    it('should reject weak passwords', async () => {\n      await expect(\n        authService.register({ email: 'user@example.com', password: '123' })\n      ).rejects.toThrow('Password must be at least 8 characters');\n    });\n\n    it('should reject duplicate emails', async () => {\n      await authService.register({ email: 'dup@example.com', password: 'ValidPass123' });\n      \n      await expect(\n        authService.register({ email: 'dup@example.com', password: 'ValidPass123' })\n      ).rejects.toThrow('Email already exists');\n    });\n  });\n});\n```\n\n**Run Tests (Expect Failures):**\n```bash\npnpm test auth.service.test.ts\n\n❌ FAIL  tests/unit/auth.service.test.ts\n  AuthService\n    login\n      ✗ should return user token for valid credentials\n        → Cannot find module '@/services/auth.service'\n      ✗ should throw error for invalid email\n      ✗ should throw error for incorrect password\n      ✗ should hash password before comparison\n```\n\nClaude: \"Tests written and failing as expected. Proceeding to GREEN phase.\"\n\n**Phase 2: GREEN (Implement Minimum Code to Pass)**\n```typescript\n// Claude generates: src/services/auth.service.ts\nimport { hash, compare } from 'bcrypt';\nimport { sign } from 'jsonwebtoken';\nimport { z } from 'zod';\n\nconst loginSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string().min(1)\n});\n\nconst registerSchema = z.object({\n  email: z.string().email('Invalid email format'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  name: z.string().min(1)\n});\n\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n  passwordHash: string;\n}\n\nexport class AuthService {\n  private users: Map<string, User> = new Map();\n\n  async login(credentials: { email: string; password: string }) {\n    const validated = loginSchema.parse(credentials);\n    \n    const user = Array.from(this.users.values()).find(\n      u => u.email === validated.email\n    );\n\n    if (!user) {\n      throw new Error('Invalid credentials');\n    }\n\n    const passwordMatch = await this.comparePassword(\n      validated.password,\n      user.passwordHash\n    );\n\n    if (!passwordMatch) {\n      throw new Error('Invalid credentials');\n    }\n\n    const token = this.generateToken(user);\n\n    return {\n      token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  async register(data: { email: string; password: string; name: string }) {\n    const validated = registerSchema.parse(data);\n\n    if (Array.from(this.users.values()).some(u => u.email === validated.email)) {\n      throw new Error('Email already exists');\n    }\n\n    const passwordHash = await hash(validated.password, 10);\n    const user: User = {\n      id: crypto.randomUUID(),\n      email: validated.email,\n      name: validated.name,\n      passwordHash\n    };\n\n    this.users.set(user.id, user);\n\n    const token = this.generateToken(user);\n\n    return {\n      token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  async comparePassword(password: string, hash: string): Promise<boolean> {\n    return compare(password, hash);\n  }\n\n  private generateToken(user: User): string {\n    return sign({ userId: user.id }, process.env.JWT_SECRET || 'dev-secret', {\n      expiresIn: '7d'\n    });\n  }\n}\n```\n\n**Run Tests Again:**\n```bash\npnpm test auth.service.test.ts\n\n✓ PASS  tests/unit/auth.service.test.ts\n  AuthService\n    login\n      ✓ should return user token for valid credentials (45ms)\n      ✓ should throw error for invalid email (12ms)\n      ✓ should throw error for incorrect password (38ms)\n      ✓ should hash password before comparison (42ms)\n    register\n      ✓ should create new user and return token (48ms)\n      ✓ should reject weak passwords (8ms)\n      ✓ should reject duplicate emails (52ms)\n\nTest Coverage:\n  File: auth.service.ts\n  Statements: 95.2%\n  Branches: 100%\n  Functions: 100%\n  Lines: 94.7%\n```\n\nClaude: \"All tests passing! Coverage: 95.2%. Proceeding to REFACTOR phase.\"\n\n**Phase 3: REFACTOR (Optimize While Keeping Tests Green)**\n```typescript\n// Claude refactors for better organization\nexport class AuthService {\n  private users: Map<string, User> = new Map();\n  private readonly saltRounds = 10;\n  private readonly tokenExpiry = '7d';\n\n  async login(credentials: LoginCredentials): Promise<AuthResult> {\n    const validated = this.validateLoginCredentials(credentials);\n    const user = await this.findUserByEmail(validated.email);\n    await this.verifyPassword(validated.password, user.passwordHash);\n    \n    return this.createAuthResult(user);\n  }\n\n  async register(data: RegisterData): Promise<AuthResult> {\n    const validated = this.validateRegisterData(data);\n    await this.ensureEmailNotExists(validated.email);\n    \n    const user = await this.createUser(validated);\n    return this.createAuthResult(user);\n  }\n\n  private validateLoginCredentials(credentials: unknown): LoginCredentials {\n    return loginSchema.parse(credentials);\n  }\n\n  private async findUserByEmail(email: string): Promise<User> {\n    const user = Array.from(this.users.values()).find(u => u.email === email);\n    if (!user) {\n      throw new Error('Invalid credentials');\n    }\n    return user;\n  }\n\n  private async verifyPassword(password: string, hash: string): Promise<void> {\n    const match = await compare(password, hash);\n    if (!match) {\n      throw new Error('Invalid credentials');\n    }\n  }\n\n  private createAuthResult(user: User): AuthResult {\n    return {\n      token: this.generateToken(user),\n      user: this.sanitizeUser(user)\n    };\n  }\n\n  // ... more refactored methods\n}\n```\n\n**Run Tests After Refactor:**\n```bash\npnpm test auth.service.test.ts\n\n✓ All tests still passing\n✓ Coverage maintained: 95.2%\n```\n\nClaude: \"Refactoring complete. All tests green. Ready for commit.\"\n\n### Integration Testing Workflow\n\n**Command:**\n```bash\n/tdd-workflow \"user registration API endpoint\" --integration\n```\n\n**Generated Integration Tests:**\n```typescript\n// tests/integration/auth.api.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport request from 'supertest';\nimport { app } from '@/app';\nimport { db } from '@/lib/db';\n\ndescribe('POST /api/auth/register', () => {\n  beforeAll(async () => {\n    await db.migrate.latest();\n  });\n\n  afterAll(async () => {\n    await db.migrate.rollback();\n    await db.destroy();\n  });\n\n  it('should register new user and return 201', async () => {\n    const response = await request(app)\n      .post('/api/auth/register')\n      .send({\n        email: 'newuser@example.com',\n        password: 'ValidPass123',\n        name: 'New User'\n      });\n\n    expect(response.status).toBe(201);\n    expect(response.body).toHaveProperty('token');\n    expect(response.body.user.email).toBe('newuser@example.com');\n  });\n\n  it('should return 400 for invalid email format', async () => {\n    const response = await request(app)\n      .post('/api/auth/register')\n      .send({ email: 'invalid', password: 'pass', name: 'User' });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toContain('Invalid email');\n  });\n\n  it('should return 409 for duplicate email', async () => {\n    await request(app)\n      .post('/api/auth/register')\n      .send({ email: 'dup@example.com', password: 'ValidPass123', name: 'User' });\n\n    const response = await request(app)\n      .post('/api/auth/register')\n      .send({ email: 'dup@example.com', password: 'ValidPass123', name: 'User2' });\n\n    expect(response.status).toBe(409);\n    expect(response.body.error).toContain('already exists');\n  });\n\n  it('should store hashed password in database', async () => {\n    const password = 'PlainPassword123';\n    \n    await request(app)\n      .post('/api/auth/register')\n      .send({ email: 'hash@example.com', password, name: 'User' });\n\n    const user = await db('users').where({ email: 'hash@example.com' }).first();\n    \n    expect(user.password).not.toBe(password);\n    expect(user.password).toMatch(/^\\$2[aby]\\$/);\n  });\n});\n```\n\n### E2E Testing Workflow with Playwright\n\n**Command:**\n```bash\n/tdd-workflow \"complete user registration flow\" --e2e --playwright\n```\n\n**Generated E2E Tests:**\n```typescript\n// tests/e2e/auth.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest.describe('User Registration Flow', () => {\n  test('should complete full registration process', async ({ page }) => {\n    // Navigate to registration page\n    await page.goto('/register');\n\n    // Fill registration form\n    await page.fill('[name=\"email\"]', 'e2e@example.com');\n    await page.fill('[name=\"password\"]', 'ValidPass123');\n    await page.fill('[name=\"confirmPassword\"]', 'ValidPass123');\n    await page.fill('[name=\"name\"]', 'E2E User');\n\n    // Submit form\n    await page.click('[type=\"submit\"]');\n\n    // Verify redirect to dashboard\n    await expect(page).toHaveURL('/dashboard');\n\n    // Verify user name displayed\n    await expect(page.locator('[data-testid=\"user-name\"]')).toHaveText('E2E User');\n  });\n\n  test('should show validation errors for invalid inputs', async ({ page }) => {\n    await page.goto('/register');\n\n    // Submit empty form\n    await page.click('[type=\"submit\"]');\n\n    // Verify error messages\n    await expect(page.locator('[data-testid=\"email-error\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"password-error\"]')).toBeVisible();\n  });\n\n  test('should persist session after registration', async ({ page, context }) => {\n    await page.goto('/register');\n    \n    // Register user\n    await page.fill('[name=\"email\"]', 'session@example.com');\n    await page.fill('[name=\"password\"]', 'ValidPass123');\n    await page.fill('[name=\"confirmPassword\"]', 'ValidPass123');\n    await page.fill('[name=\"name\"]', 'Session User');\n    await page.click('[type=\"submit\"]');\n\n    // Verify cookies set\n    const cookies = await context.cookies();\n    expect(cookies.find(c => c.name === 'auth_token')).toBeDefined();\n\n    // Reload page - should stay authenticated\n    await page.reload();\n    await expect(page).toHaveURL('/dashboard');\n  });\n});\n```\n\n### Full Test Pyramid Workflow\n\n**Command:**\n```bash\n/tdd-workflow \"payment processing feature\" --full --min-coverage=90\n```\n\n**Claude Executes:**\n\n1. **Unit Tests** (70% of test suite)\n   - Service layer logic\n   - Utility functions\n   - Data validation\n   - Business rules\n\n2. **Integration Tests** (20% of test suite)\n   - API endpoints\n   - Database operations\n   - External service mocks\n\n3. **E2E Tests** (10% of test suite)\n   - Critical user flows\n   - Payment completion\n   - Error handling UX\n\n**Coverage Report:**\n```\nTest Results:\n  Unit: 45 tests passing\n  Integration: 12 tests passing\n  E2E: 3 tests passing\n\nCoverage:\n  Overall: 92.3% ✓\n  Statements: 93.1%\n  Branches: 89.7%\n  Functions: 95.2%\n  Lines: 92.8%\n\nTarget: 90% - PASSED ✓\n```\n\n## TDD Best Practices\n\n### 1. Write Tests First (Always)\n```bash\n# Claude will REFUSE to implement before tests exist\nUser: \"Implement user authentication\"\n\nClaude: \"I'll follow TDD workflow:\n1. First, I'll write comprehensive tests\n2. Run tests (expect failures)\n3. Implement minimal code to pass\n4. Refactor while keeping tests green\n\nStarting with test creation...\"\n```\n\n### 2. Test Behavior, Not Implementation\n```typescript\n// ❌ Bad: Testing implementation details\nit('should call bcrypt.hash with saltRounds=10', () => {\n  expect(bcrypt.hash).toHaveBeenCalledWith(password, 10);\n});\n\n// ✅ Good: Testing behavior\nit('should store hashed password', async () => {\n  await authService.register({ email, password });\n  const user = await db.users.findOne({ email });\n  \n  expect(user.password).not.toBe(password);\n  expect(await bcrypt.compare(password, user.password)).toBe(true);\n});\n```\n\n### 3. Descriptive Test Names\n```typescript\n// ✅ Clear test names following Given-When-Then\ndescribe('AuthService', () => {\n  describe('when user provides valid credentials', () => {\n    it('should return auth token and user data', async () => {\n      // test\n    });\n  });\n\n  describe('when password is incorrect', () => {\n    it('should throw InvalidCredentialsError', async () => {\n      // test\n    });\n  });\n});\n```\n\n### 4. Arrange-Act-Assert Pattern\n```typescript\nit('should update user email', async () => {\n  // Arrange: Set up test data\n  const user = await createTestUser({ email: 'old@example.com' });\n  \n  // Act: Perform action\n  await userService.updateEmail(user.id, 'new@example.com');\n  \n  // Assert: Verify outcome\n  const updated = await userService.findById(user.id);\n  expect(updated.email).toBe('new@example.com');\n});\n```\n\n## Anti-Hallucination Benefits\n\n### Problem: LLM Scope Drift\n```bash\nUser: \"Add user authentication\"\n\nClaude (without TDD):\n*Implements auth + session management + password reset + 2FA + OAuth*\n# Hallucinated features not requested\n```\n\n### Solution: Test-Anchored Iteration\n```bash\nClaude (with TDD):\n1. Writes tests ONLY for requested features\n2. Tests define exact scope and behavior\n3. Implementation guided by test requirements\n4. Iteration stops when tests pass\n5. No feature creep - tests are ground truth\n```\n\n## Watch Mode & Continuous Testing\n\n```bash\n/tdd-workflow \"shopping cart service\" --watch\n```\n\n**Behavior:**\n- Monitors file changes\n- Re-runs affected tests automatically\n- Shows real-time coverage updates\n- Alerts when tests fail\n\n**Terminal Output:**\n```\nWatching: src/**/*.ts, tests/**/*.test.ts\n\n✓ 24 tests passing\n✓ Coverage: 87.3%\n\nWaiting for changes... (press 'q' to quit)\n\n[File changed: src/services/cart.service.ts]\nRe-running tests...\n\n✗ 1 test failing\n  CartService > should remove item from cart\n    Expected: 1 item, Received: 2 items\n\nCoverage: 85.1% (↓ 2.2%)\n```\n\n## Configuration\n\n### Custom Test Runner\n```json\n// .claude/tdd.config.json\n{\n  \"framework\": \"vitest\",\n  \"coverage\": {\n    \"enabled\": true,\n    \"threshold\": 80,\n    \"reportDir\": \"coverage\"\n  },\n  \"testMatch\": [\"**/*.test.ts\", \"**/*.spec.ts\"],\n  \"autoCommit\": true,\n  \"commitMessage\": \"test: {{feature}} - all tests passing ✓\"\n}\n```\n\n## Best Practices Summary\n\n1. **Always Write Tests First**: No implementation before failing tests\n2. **Iterate Until Green**: Let AI refine until all tests pass\n3. **Minimum Code**: Implement only what's needed to pass tests\n4. **Refactor Fearlessly**: Tests protect against regressions\n5. **Descriptive Names**: Test names document expected behavior\n6. **High Coverage**: Target 80%+ for production code\n7. **Fast Feedback**: Use watch mode for continuous verification\n8. **Commit on Green**: Auto-commit when test suite passes",
  "configuration": {
    "temperature": 0.2,
    "maxTokens": 8000,
    "systemPrompt": "You are a test-driven development (TDD) expert specializing in AI-assisted red-green-refactor workflows. You MUST write tests before implementation and iterate until all tests pass. Tests are ground truth preventing hallucination."
  },
  "githubUrl": "https://github.com/tdd-examples/claude-code-tdd",
  "documentationUrl": "https://docs.claude.com/en/docs/claude-code/testing",
  "discoveryMetadata": {
    "researchDate": "2025-10-25",
    "trendingSources": [
      {
        "source": "the_new_stack",
        "evidence": "Article 'Claude Code and the Art of Test-Driven Development' (2025) highlighting TDD as optimal workflow for AI coding with structured iteration",
        "url": "https://thenewstack.io/claude-code-and-the-art-of-test-driven-development/",
        "relevanceScore": "high"
      },
      {
        "source": "kent_beck_interview",
        "evidence": "Kent Beck (TDD creator) calls TDD a 'superpower' with AI agents in Pragmatic Engineer newsletter, emphasizing tests as stable reference points for agent iteration",
        "url": "https://newsletter.pragmaticengineer.com/p/tdd-ai-agents-and-coding-with-kent",
        "relevanceScore": "high"
      },
      {
        "source": "talent500_guide",
        "evidence": "Comprehensive guide 'Claude Code & Test-Driven Development' showing TDD prevents hallucination and provides clear exit criteria for AI agents",
        "url": "https://talent500.com/blog/claude-code-test-driven-development-guide/",
        "relevanceScore": "high"
      },
      {
        "source": "shipyard_e2e",
        "evidence": "Shipyard Blog 'E2E Testing with Claude Code' demonstrating production workflows with Playwright integration and test-anchored development",
        "url": "https://shipyard.build/blog/e2e-testing-claude-code/",
        "relevanceScore": "high"
      }
    ],
    "keywordResearch": {
      "primaryKeywords": [
        "TDD Claude Code",
        "test-driven development AI",
        "red-green-refactor",
        "AI testing workflow",
        "Claude Code testing"
      ],
      "searchVolume": "high",
      "competitionLevel": "medium"
    },
    "gapAnalysis": {
      "existingContent": ["test-advanced", "generate-tests"],
      "identifiedGap": "Existing test commands focus on test generation but NOT TDD workflow. TDD requires specific red-green-refactor cycle: write failing tests FIRST, implement minimal code, refactor. Kent Beck endorsement + The New Stack article show TDD is THE recommended AI coding pattern, yet no command enforces this workflow. TDD prevents hallucination (tests = ground truth) and provides clear exit criteria.",
      "priority": "high"
    },
    "approvalRationale": "TDD experiencing major resurgence in AI era with endorsement from TDD creator Kent Beck calling it a 'superpower' for AI agents. The New Stack, Talent500, and Shipyard all published comprehensive TDD + Claude Code guides in 2025. This fills critical gap - existing test commands generate tests but don't enforce TDD workflow (test-first, iterate-until-pass). High search volume, medium competition, and proven anti-hallucination benefits make this essential for quality AI coding."
  },
  "troubleshooting": [
    {
      "issue": "Claude implements code before writing tests despite TDD workflow command",
      "solution": "Explicitly state in prompt: 'Write ONLY tests first, do NOT implement yet'. Use --strict flag to enforce test-first. Review systemPrompt in .claude/tdd.config.json ensures test-first mandate. Interrupt with ESC if implementation starts before tests."
    },
    {
      "issue": "Tests pass immediately without red phase, indicating mocked or trivial tests",
      "solution": "Verify tests use real implementations, not mocks. Check test assertions are meaningful (not just expect(true).toBe(true)). Run tests before implementation to confirm failures. Use --no-mocks flag to prevent mock generation."
    },
    {
      "issue": "Coverage report shows 100% but obvious code paths untested",
      "solution": "Coverage tools may miss edge cases. Manually review tests for boundary conditions, error paths, and negative cases. Use mutation testing: npx stryker run to verify test quality. Add --edge-cases flag to generate boundary tests."
    },
    {
      "issue": "Watch mode not detecting file changes or re-running tests",
      "solution": "Verify vitest/jest watch mode configured correctly. Check .gitignore not excluding test files. Use --watch --verbose for detailed file change logs. Some Docker environments need --watch.poll for file detection."
    },
    {
      "issue": "Integration tests fail with database connection errors in CI/CD",
      "solution": "Ensure test database configured in CI environment variables. Use --setup-db flag to auto-create test database. Check beforeAll hook runs migrations. Use @testcontainers for isolated database instances per test run."
    }
  ],
  "source": "claudepro",
  "slug": "tdd-workflow",
  "seoTitle": "TDD Workflow for Claude Code"
}
