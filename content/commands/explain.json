{
  "description": "Intelligent code explanation with visual diagrams, step-by-step breakdowns, and interactive examples",
  "category": "commands",
  "author": "claudepro",
  "dateAdded": "2025-09-16",
  "tags": ["explanation", "documentation", "learning", "analysis", "visualization"],
  "content": "The `/explain` command provides comprehensive code explanations with visual diagrams, step-by-step execution flow, complexity analysis, and interactive examples to help understand any codebase.\n\n## Usage\n\n```\n/explain [options] <code_or_file>\n```\n\n## Options\n\n### Explanation Depth\n- `--simple` - High-level overview for beginners\n- `--detailed` - Comprehensive explanation (default)\n- `--expert` - Technical deep-dive with optimizations\n- `--academic` - Theoretical analysis with algorithms\n\n### Visualization Options\n- `--flowchart` - Generate execution flow diagrams\n- `--architecture` - System architecture diagrams\n- `--sequence` - Sequence diagrams for interactions\n- `--uml` - UML class and relationship diagrams\n- `--mermaid` - Generate Mermaid.js diagrams\n\n### Analysis Focus\n- `--performance` - Performance characteristics and complexity\n- `--security` - Security implications and vulnerabilities\n- `--patterns` - Design patterns and architectural decisions\n- `--dependencies` - Dependency analysis and relationships\n\n### Output Formats\n- `--format=markdown` - Structured markdown (default)\n- `--format=interactive` - Interactive walkthrough\n- `--format=slides` - Presentation format\n- `--format=tutorial` - Step-by-step tutorial\n\n## Examples\n\n### React Component Explanation\n\n```jsx\n// UserProfile.jsx\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { debounce } from 'lodash';\nimport { fetchUserData, updateUserProfile } from '../api/users';\nimport { useAuth } from '../hooks/useAuth';\nimport { Avatar } from '../components/Avatar';\nimport { Modal } from '../components/Modal';\n\nconst UserProfile = ({ userId, onUserUpdate }) => {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [editing, setEditing] = useState(false);\n  const [formData, setFormData] = useState({});\n  const [errors, setErrors] = useState({});\n  \n  const { currentUser, hasPermission } = useAuth();\n  \n  // Debounced validation function\n  const validateField = useCallback(\n    debounce((field, value) => {\n      const newErrors = { ...errors };\n      \n      switch (field) {\n        case 'email':\n          if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n            newErrors.email = 'Invalid email format';\n          } else {\n            delete newErrors.email;\n          }\n          break;\n        case 'phone':\n          if (!/^\\+?[1-9]\\d{1,14}$/.test(value)) {\n            newErrors.phone = 'Invalid phone format';\n          } else {\n            delete newErrors.phone;\n          }\n          break;\n        default:\n          break;\n      }\n      \n      setErrors(newErrors);\n    }, 300),\n    [errors]\n  );\n  \n  // Load user data on mount and userId change\n  useEffect(() => {\n    const loadUserData = async () => {\n      try {\n        setLoading(true);\n        const userData = await fetchUserData(userId);\n        setUser(userData);\n        setFormData({\n          name: userData.name,\n          email: userData.email,\n          phone: userData.phone,\n          bio: userData.bio\n        });\n      } catch (error) {\n        console.error('Failed to load user data:', error);\n        setUser(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    if (userId) {\n      loadUserData();\n    }\n  }, [userId]);\n  \n  // Handle form input changes\n  const handleInputChange = (field, value) => {\n    setFormData(prev => ({ ...prev, [field]: value }));\n    validateField(field, value);\n  };\n  \n  // Save profile changes\n  const handleSave = async () => {\n    try {\n      if (Object.keys(errors).length > 0) {\n        return;\n      }\n      \n      setLoading(true);\n      const updatedUser = await updateUserProfile(userId, formData);\n      setUser(updatedUser);\n      setEditing(false);\n      onUserUpdate?.(updatedUser);\n    } catch (error) {\n      console.error('Failed to update profile:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  if (loading) {\n    return <div className=\"loading-spinner\">Loading...</div>;\n  }\n  \n  if (!user) {\n    return <div className=\"error-message\">User not found</div>;\n  }\n  \n  const canEdit = hasPermission('edit_profile') && \n    (currentUser.id === userId || hasPermission('admin'));\n  \n  return (\n    <div className=\"user-profile\">\n      <div className=\"profile-header\">\n        <Avatar src={user.avatar} size=\"large\" />\n        <div className=\"profile-info\">\n          <h1>{user.name}</h1>\n          <p className=\"user-title\">{user.title}</p>\n          {canEdit && (\n            <button \n              className=\"edit-button\"\n              onClick={() => setEditing(true)}\n            >\n              Edit Profile\n            </button>\n          )}\n        </div>\n      </div>\n      \n      <div className=\"profile-details\">\n        <div className=\"detail-item\">\n          <label>Email:</label>\n          <span>{user.email}</span>\n        </div>\n        <div className=\"detail-item\">\n          <label>Phone:</label>\n          <span>{user.phone}</span>\n        </div>\n        <div className=\"detail-item\">\n          <label>Bio:</label>\n          <p>{user.bio}</p>\n        </div>\n      </div>\n      \n      {editing && (\n        <Modal onClose={() => setEditing(false)}>\n          <form className=\"edit-form\">\n            <div className=\"form-group\">\n              <label>Name:</label>\n              <input\n                type=\"text\"\n                value={formData.name}\n                onChange={(e) => handleInputChange('name', e.target.value)}\n              />\n            </div>\n            \n            <div className=\"form-group\">\n              <label>Email:</label>\n              <input\n                type=\"email\"\n                value={formData.email}\n                onChange={(e) => handleInputChange('email', e.target.value)}\n              />\n              {errors.email && <span className=\"error\">{errors.email}</span>}\n            </div>\n            \n            <div className=\"form-group\">\n              <label>Phone:</label>\n              <input\n                type=\"tel\"\n                value={formData.phone}\n                onChange={(e) => handleInputChange('phone', e.target.value)}\n              />\n              {errors.phone && <span className=\"error\">{errors.phone}</span>}\n            </div>\n            \n            <div className=\"form-group\">\n              <label>Bio:</label>\n              <textarea\n                value={formData.bio}\n                onChange={(e) => handleInputChange('bio', e.target.value)}\n              />\n            </div>\n            \n            <div className=\"form-actions\">\n              <button type=\"button\" onClick={() => setEditing(false)}>\n                Cancel\n              </button>\n              <button \n                type=\"button\" \n                onClick={handleSave}\n                disabled={Object.keys(errors).length > 0}\n              >\n                Save Changes\n              </button>\n            </div>\n          </form>\n        </Modal>\n      )}\n    </div>\n  );\n};\n\nexport default UserProfile;\n```\n\n**Generated Explanation:**\n\n# ðŸ“‹ UserProfile Component Analysis\n\n## ðŸŽ¯ Component Overview\n\nThe `UserProfile` component is a **React functional component** that displays and manages user profile information with editing capabilities. It demonstrates several advanced React patterns and best practices.\n\n### Key Responsibilities\n1. **Data Fetching**: Loads user data from API\n2. **State Management**: Manages user data, form state, and UI state\n3. **Validation**: Real-time form validation with debouncing\n4. **Authorization**: Role-based access control for editing\n5. **Error Handling**: Graceful error states and user feedback\n\n## ðŸ—ï¸ Architecture Diagram\n\n```mermaid\ngraph TD\n    A[UserProfile Component] --> B[State Management]\n    A --> C[Data Fetching]\n    A --> D[Form Handling]\n    A --> E[Authorization]\n    \n    B --> B1[user: User data]\n    B --> B2[loading: Loading state]\n    B --> B3[editing: Edit mode]\n    B --> B4[formData: Form values]\n    B --> B5[errors: Validation errors]\n    \n    C --> C1[fetchUserData API]\n    C --> C2[updateUserProfile API]\n    \n    D --> D1[handleInputChange]\n    D --> D2[validateField]\n    D --> D3[handleSave]\n    \n    E --> E1[useAuth Hook]\n    E --> E2[Permission Checks]\n    \n    A --> F[Child Components]\n    F --> F1[Avatar]\n    F --> F2[Modal]\n```\n\n## ðŸ”„ Component Lifecycle\n\n### 1. **Initialization Phase**\n```javascript\n// Component mounts with userId prop\nUserProfile({ userId: \"123\", onUserUpdate })\n\n// Initial state setup\nconst [user, setUser] = useState(null);          // No user data yet\nconst [loading, setLoading] = useState(true);    // Show loading state\nconst [editing, setEditing] = useState(false);   // Not in edit mode\nconst [formData, setFormData] = useState({});    // Empty form\nconst [errors, setErrors] = useState({});        // No validation errors\n```\n\n### 2. **Data Loading Phase**\n```javascript\n// useEffect triggers when userId changes\nuseEffect(() => {\n  const loadUserData = async () => {\n    setLoading(true);                    // Show loading spinner\n    const userData = await fetchUserData(userId);  // API call\n    setUser(userData);                   // Store user data\n    setFormData({                        // Pre-populate form\n      name: userData.name,\n      email: userData.email,\n      // ... other fields\n    });\n    setLoading(false);                   // Hide loading spinner\n  };\n  \n  loadUserData();\n}, [userId]);  // Dependency: re-run when userId changes\n```\n\n### 3. **Rendering Decision Tree**\n```\nComponent Render Logic:\nâ”œâ”€ if (loading) â†’ Show Loading Spinner\nâ”œâ”€ else if (!user) â†’ Show \"User not found\"\nâ””â”€ else â†’ Show User Profile\n    â”œâ”€ Profile Header (Avatar + Info)\n    â”œâ”€ Profile Details (Email, Phone, Bio)\n    â””â”€ if (editing) â†’ Show Edit Modal\n```\n\n## ðŸŽ›ï¸ State Management Deep Dive\n\n### State Variables Analysis\n\n| State | Type | Purpose | Updates When |\n|-------|------|---------|-------------|\n| `user` | Object/null | Stores complete user data | API fetch completes |\n| `loading` | Boolean | Controls loading UI | Before/after async operations |\n| `editing` | Boolean | Controls edit modal visibility | Edit button clicked |\n| `formData` | Object | Stores form input values | User types in form fields |\n| `errors` | Object | Stores validation errors | Field validation runs |\n\n### State Update Flow\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant C as Component\n    participant A as API\n    participant V as Validator\n    \n    U->>C: Component mounts\n    C->>A: fetchUserData(userId)\n    A->>C: Returns user data\n    C->>C: setUser(userData)\n    C->>C: setFormData(userData)\n    \n    U->>C: Clicks \"Edit Profile\"\n    C->>C: setEditing(true)\n    \n    U->>C: Types in email field\n    C->>C: handleInputChange('email', value)\n    C->>V: validateField('email', value)\n    V->>C: Returns validation result\n    C->>C: setErrors(newErrors)\n    \n    U->>C: Clicks \"Save\"\n    C->>A: updateUserProfile(userId, formData)\n    A->>C: Returns updated user\n    C->>C: setUser(updatedUser)\n    C->>C: setEditing(false)\n```\n\n## âš¡ Performance Optimizations\n\n### 1. **Debounced Validation**\n```javascript\nconst validateField = useCallback(\n  debounce((field, value) => {\n    // Validation logic runs after 300ms of inactivity\n  }, 300),\n  [errors]  // Re-create when errors change\n);\n```\n\n**Benefits:**\n- Reduces API calls and computation\n- Improves user experience (no validation on every keystroke)\n- Prevents race conditions\n\n**How it works:**\n1. User types in field\n2. `handleInputChange` calls `validateField`\n3. Debounce waits 300ms\n4. If no new input, validation runs\n5. If new input arrives, timer resets\n\n### 2. **useCallback Optimization**\n```javascript\n// Memoizes function to prevent unnecessary re-renders\nconst validateField = useCallback(/* ... */, [errors]);\n```\n\n**Memory vs Performance Trade-off:**\n- **Memory**: Stores function reference\n- **Performance**: Prevents child component re-renders\n- **Best Practice**: Use when passing functions to child components\n\n### 3. **Conditional Rendering**\n```javascript\n// Only render edit modal when needed\n{editing && (\n  <Modal onClose={() => setEditing(false)}>\n    {/* Heavy form components only rendered in edit mode */}\n  </Modal>\n)}\n```\n\n## ðŸ”’ Security Analysis\n\n### 1. **Authorization Checks**\n```javascript\nconst canEdit = hasPermission('edit_profile') && \n  (currentUser.id === userId || hasPermission('admin'));\n```\n\n**Security Layers:**\n- **Permission-based**: `hasPermission('edit_profile')`\n- **Ownership-based**: `currentUser.id === userId`\n- **Role-based**: `hasPermission('admin')`\n\n### 2. **Input Validation**\n```javascript\ncase 'email':\n  if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n    newErrors.email = 'Invalid email format';\n  }\n```\n\n**Validation Patterns:**\n- **Email**: RFC-compliant regex pattern\n- **Phone**: International format with optional country code\n- **Client-side**: Immediate user feedback\n- **Server-side**: Additional validation required (not shown)\n\n### 3. **Error Handling**\n```javascript\ntry {\n  const userData = await fetchUserData(userId);\n  setUser(userData);\n} catch (error) {\n  console.error('Failed to load user data:', error);\n  setUser(null);  // Safe fallback state\n}\n```\n\n## ðŸŽ¨ Component Design Patterns\n\n### 1. **Container/Presentational Pattern**\n```\nUserProfile (Container)\nâ”œâ”€ Manages state and business logic\nâ”œâ”€ Handles API calls and data flow\nâ””â”€ Renders presentational components:\n    â”œâ”€ Avatar (Presentational)\n    â””â”€ Modal (Presentational)\n```\n\n### 2. **Controlled Components Pattern**\n```javascript\n<input\n  type=\"email\"\n  value={formData.email}  // Value controlled by React state\n  onChange={(e) => handleInputChange('email', e.target.value)}\n/>\n```\n\n**Benefits:**\n- Single source of truth\n- Predictable data flow\n- Easy validation and manipulation\n\n### 3. **Hook Composition Pattern**\n```javascript\nconst { currentUser, hasPermission } = useAuth();\n// Custom hook encapsulates authentication logic\n```\n\n## ðŸ”„ Data Flow Diagram\n\n```mermaid\nflowchart LR\n    A[Props: userId] --> B[useEffect]\n    B --> C[fetchUserData API]\n    C --> D[setUser]\n    D --> E[Component Re-render]\n    \n    F[User Input] --> G[handleInputChange]\n    G --> H[setFormData]\n    G --> I[validateField]\n    I --> J[setErrors]\n    H --> E\n    J --> E\n    \n    K[Save Button] --> L[handleSave]\n    L --> M[updateUserProfile API]\n    M --> N[setUser]\n    M --> O[onUserUpdate callback]\n    N --> E\n```\n\n## ðŸ§ª Testing Strategy\n\n### Unit Tests\n```javascript\ndescribe('UserProfile', () => {\n  it('should load user data on mount', async () => {\n    const mockUser = { id: '123', name: 'John Doe' };\n    jest.mocked(fetchUserData).mockResolvedValue(mockUser);\n    \n    render(<UserProfile userId=\"123\" />);\n    \n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n    \n    await waitFor(() => {\n      expect(screen.getByText('John Doe')).toBeInTheDocument();\n    });\n  });\n  \n  it('should validate email format', async () => {\n    render(<UserProfile userId=\"123\" />);\n    \n    const emailInput = screen.getByLabelText('Email:');\n    fireEvent.change(emailInput, { target: { value: 'invalid-email' } });\n    \n    await waitFor(() => {\n      expect(screen.getByText('Invalid email format')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n### Integration Tests\n```javascript\nit('should update profile successfully', async () => {\n  const mockUpdatedUser = { id: '123', name: 'Jane Doe' };\n  jest.mocked(updateUserProfile).mockResolvedValue(mockUpdatedUser);\n  \n  render(<UserProfile userId=\"123\" onUserUpdate={mockCallback} />);\n  \n  // Open edit modal\n  fireEvent.click(screen.getByText('Edit Profile'));\n  \n  // Update name\n  fireEvent.change(screen.getByLabelText('Name:'), {\n    target: { value: 'Jane Doe' }\n  });\n  \n  // Save changes\n  fireEvent.click(screen.getByText('Save Changes'));\n  \n  await waitFor(() => {\n    expect(mockCallback).toHaveBeenCalledWith(mockUpdatedUser);\n  });\n});\n```\n\n## ðŸš€ Performance Metrics\n\n### Complexity Analysis\n- **Time Complexity**: O(1) for most operations, O(n) for validation\n- **Space Complexity**: O(1) for component state\n- **Rendering Complexity**: O(1) - no loops in render\n\n### Bundle Impact\n```\nComponent Size: ~8KB (minified)\nDependencies:\nâ”œâ”€ React: ~42KB\nâ”œâ”€ lodash.debounce: ~2KB\nâ””â”€ Custom hooks: ~1KB\nTotal: ~53KB\n```\n\n### Performance Recommendations\n1. **Lazy Loading**: Load form components only when editing\n2. **Memoization**: Use React.memo for child components\n3. **Virtual Scrolling**: For large user lists\n4. **Code Splitting**: Separate edit functionality into async chunk\n\n## ðŸ”§ Customization Options\n\n### Configuration Props\n```typescript\ninterface UserProfileProps {\n  userId: string;\n  onUserUpdate?: (user: User) => void;\n  \n  // Customization options\n  editable?: boolean;\n  fields?: ('name' | 'email' | 'phone' | 'bio')[];\n  validationRules?: ValidationRules;\n  theme?: 'light' | 'dark' | 'auto';\n  layout?: 'vertical' | 'horizontal';\n}\n```\n\n### Extension Points\n```javascript\n// Custom validation rules\nconst customValidation = {\n  email: (value) => isValidCorporateEmail(value),\n  phone: (value) => isValidUSPhoneNumber(value)\n};\n\n// Custom field renderers\nconst fieldRenderers = {\n  bio: (value, onChange) => <RichTextEditor value={value} onChange={onChange} />,\n  avatar: (value, onChange) => <ImageUploader value={value} onChange={onChange} />\n};\n```\n\n## ðŸ“š Related Concepts\n\n### React Patterns Used\n- **Functional Components**: Modern React approach\n- **Hooks**: useState, useEffect, useCallback\n- **Custom Hooks**: useAuth for authentication\n- **Controlled Components**: Form input management\n- **Conditional Rendering**: Dynamic UI based on state\n\n### JavaScript Concepts\n- **Async/Await**: Promise handling\n- **Destructuring**: Props and state extraction\n- **Template Literals**: Dynamic class names\n- **Optional Chaining**: Safe property access\n- **Debouncing**: Performance optimization\n\n### Web Standards\n- **Accessibility**: Proper form labels and ARIA attributes\n- **Semantic HTML**: Meaningful element structure\n- **Progressive Enhancement**: Works without JavaScript\n- **Responsive Design**: Mobile-friendly layout\n\nThis component demonstrates enterprise-level React development with proper state management, security considerations, performance optimizations, and maintainable code structure.",
  "configuration": {
    "temperature": 0.3,
    "maxTokens": 16000,
    "systemPrompt": "You are an expert software engineer and educator who excels at breaking down complex code into understandable explanations with visual aids, practical examples, and clear technical insights."
  },
  "githubUrl": "https://github.com/claudepro/code-explainer",
  "documentationUrl": "https://docs.claude.ai/commands/explain",
  "source": "community",
  "slug": "explain"
}
