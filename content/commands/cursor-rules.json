{
  "description": "Generate .cursorrules files for AI-native development with project-specific patterns, coding standards, and intelligent context awareness",
  "category": "commands",
  "author": "JSONbored",
  "dateAdded": "2025-10-16",
  "tags": ["cursor", "ai-rules", "code-standards", "context", "ai-ide"],
  "content": "The `/cursor-rules` command generates comprehensive `.cursorrules` files tailored to your project's technology stack, coding standards, and architectural patterns for optimal AI-assisted development.\n\n## Usage\n\n```\n/cursor-rules [options] <project_type>\n```\n\n## Options\n\n### Project Types\n- `--nextjs` - Next.js application (default)\n- `--react` - React application\n- `--node` - Node.js backend\n- `--fullstack` - Full-stack application\n- `--python` - Python project\n- `--go` - Go project\n\n### Framework Integration\n- `--typescript` - TypeScript project (default: true)\n- `--tailwind` - TailwindCSS styling\n- `--prisma` - Prisma ORM\n- `--trpc` - tRPC for APIs\n- `--graphql` - GraphQL APIs\n\n### Code Standards\n- `--strict` - Strict mode with comprehensive checks\n- `--eslint-config=<config>` - ESLint configuration preset\n- `--prettier-config=<config>` - Prettier configuration\n- `--naming-convention=<style>` - Naming convention (camelCase, PascalCase)\n\n### Features\n- `--security-focused` - Include security best practices\n- `--performance-focused` - Include performance optimization rules\n- `--accessibility` - Include WCAG 2.2 guidelines\n- `--testing` - Include testing patterns\n\n## Examples\n\n### Next.js 15 + React 19 Full-Stack Application\n\n**Command:**\n```\n/cursor-rules --nextjs --typescript --tailwind --prisma --trpc --strict --security-focused --accessibility\n```\n\n**Generated `.cursorrules`:**\n```markdown\n# Next.js 15 + React 19 Project Rules\n\nYou are an expert full-stack developer specializing in Next.js 15, React 19, TypeScript, TailwindCSS v4, Prisma, and tRPC.\n\n## Technology Stack\n\n- **Frontend**: React 19.1.1, Next.js 15.5.2\n- **Styling**: TailwindCSS v4.1.13, shadcn/ui\n- **Type Safety**: TypeScript 5.x strict mode\n- **Database**: PostgreSQL with Prisma ORM\n- **API**: tRPC for end-to-end type safety\n- **Authentication**: better-auth v1.3.9\n- **State Management**: React Server Components, Zustand for client state\n- **Forms**: react-hook-form + Zod validation\n- **Testing**: Vitest, Playwright\n\n## Code Style & Conventions\n\n### TypeScript\n- Use TypeScript 5.x with strict mode enabled\n- Never use `any` type - use `unknown` instead\n- Prefer type inference when possible\n- Use discriminated unions for complex state\n- Define interfaces for public APIs, types for internal use\n\n```typescript\n// ❌ Bad\nfunction processData(data: any) {\n  return data.value;\n}\n\n// ✅ Good\ninterface DataInput {\n  value: string;\n  timestamp: number;\n}\n\nfunction processData(data: DataInput): string {\n  return data.value;\n}\n```\n\n### React Best Practices\n- Use React Server Components by default\n- Only use 'use client' when necessary (interactivity, hooks, browser APIs)\n- Prefer async Server Components for data fetching\n- Use Suspense boundaries for loading states\n- Implement error boundaries for error handling\n\n```typescript\n// ✅ Server Component (default)\nexport default async function UserProfile({ userId }: { userId: string }) {\n  const user = await db.user.findUnique({ where: { id: userId } });\n  \n  return <div>{user.name}</div>;\n}\n\n// ✅ Client Component (only when needed)\n'use client';\n\nimport { useState } from 'react';\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\n}\n```\n\n### File Organization\n```\napp/\n├── (auth)/\n│   ├── login/\n│   │   └── page.tsx\n│   └── layout.tsx\n├── (dashboard)/\n│   ├── dashboard/\n│   │   └── page.tsx\n│   └── layout.tsx\n└── api/\n    └── trpc/\n        └── [trpc]/\n            └── route.ts\n\ncomponents/\n├── ui/              # shadcn/ui components\n├── forms/           # Form components\n└── layout/          # Layout components\n\nlib/\n├── api/             # API clients\n├── auth/            # Authentication\n├── db/              # Database (Prisma)\n├── utils/           # Utilities\n└── validators/      # Zod schemas\n```\n\n### Naming Conventions\n- **Files**: kebab-case for files (`user-profile.tsx`)\n- **Components**: PascalCase (`UserProfile`)\n- **Functions**: camelCase (`getUserById`)\n- **Constants**: UPPER_SNAKE_CASE (`MAX_RETRY_COUNT`)\n- **Types/Interfaces**: PascalCase (`UserProfile`, `ApiResponse`)\n- **Private**: Prefix with underscore (`_internalHelper`)\n\n## Security Best Practices\n\n### Input Validation\n- Always validate user input with Zod\n- Sanitize HTML content with DOMPurify\n- Never trust client-side data\n\n```typescript\nimport { z } from 'zod';\n\nconst userSchema = z.object({\n  email: z.string().email().toLowerCase(),\n  password: z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/),\n});\n\nexport async function createUser(input: unknown) {\n  const validated = userSchema.parse(input);\n  // Safe to use validated data\n}\n```\n\n### Authentication\n- Use better-auth for authentication\n- Implement session management with JWT\n- Apply rate limiting to auth endpoints\n- Use httpOnly, secure cookies\n\n### API Security\n- Implement CSRF protection\n- Use Content Security Policy (CSP)\n- Apply rate limiting\n- Validate authorization on every request\n\n```typescript\n// app/api/users/[id]/route.ts\nimport { auth } from '@/lib/auth';\n\nexport async function GET(req: Request, { params }: { params: { id: string } }) {\n  const session = await auth();\n  \n  if (!session?.user) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n  \n  // Check authorization\n  if (session.user.id !== params.id && session.user.role !== 'admin') {\n    return new Response('Forbidden', { status: 403 });\n  }\n  \n  // Proceed with request\n}\n```\n\n## Performance Optimization\n\n### React Performance\n- Use React.memo() for expensive components\n- Implement useCallback and useMemo appropriately\n- Leverage useTransition for non-urgent updates\n- Use useDeferredValue for expensive renders\n\n```typescript\nimport { useTransition, useDeferredValue } from 'react';\n\nfunction SearchResults({ query }: { query: string }) {\n  const [isPending, startTransition] = useTransition();\n  const deferredQuery = useDeferredValue(query);\n  \n  // Expensive filtering uses deferred value\n  const results = filterResults(data, deferredQuery);\n  \n  return <div style={{ opacity: isPending ? 0.5 : 1 }}>{/* results */}</div>;\n}\n```\n\n### Next.js Optimization\n- Use Next.js Image component for images\n- Implement dynamic imports for large components\n- Use generateStaticParams for static pages\n- Leverage Partial Prerendering (PPR)\n\n```typescript\nimport Image from 'next/image';\nimport dynamic from 'next/dynamic';\n\n// ✅ Optimized images\n<Image src=\"/hero.jpg\" alt=\"Hero\" width={1200} height={600} priority />\n\n// ✅ Code splitting\nconst HeavyComponent = dynamic(() => import('./heavy-component'));\n```\n\n### Database Optimization\n- Use Prisma select to fetch only needed fields\n- Implement pagination for large datasets\n- Use database indexes appropriately\n- Batch queries when possible\n\n```typescript\n// ✅ Efficient query\nconst users = await db.user.findMany({\n  select: { id: true, name: true, email: true },\n  where: { active: true },\n  take: 20,\n  skip: page * 20,\n});\n```\n\n## Accessibility (WCAG 2.2 Level AA)\n\n### Semantic HTML\n- Use proper HTML5 semantic elements\n- Implement proper heading hierarchy\n- Use landmark roles appropriately\n\n```typescript\n// ✅ Semantic structure\n<header>\n  <nav aria-label=\"Main navigation\">\n    <ul>{/* nav items */}</ul>\n  </nav>\n</header>\n<main>\n  <article>\n    <h1>Page Title</h1>\n  </article>\n</main>\n<footer>{/* footer content */}</footer>\n```\n\n### ARIA and Keyboard Navigation\n- Add ARIA labels to interactive elements\n- Ensure keyboard navigation works\n- Implement focus management\n- Provide focus indicators\n\n```typescript\n<button\n  onClick={handleClick}\n  aria-label=\"Close dialog\"\n  aria-describedby=\"dialog-description\"\n>\n  <X className=\"h-4 w-4\" />\n  <span className=\"sr-only\">Close</span>\n</button>\n```\n\n### Color Contrast\n- Ensure 4.5:1 contrast ratio for text\n- Use TailwindCSS color utilities\n- Test with accessibility tools\n\n## Testing Strategy\n\n### Unit Tests (Vitest)\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { calculateDiscount } from './pricing';\n\ndescribe('calculateDiscount', () => {\n  it('should apply basic discount', () => {\n    expect(calculateDiscount(100, 10)).toBe(10);\n  });\n  \n  it('should cap discount at 50%', () => {\n    expect(calculateDiscount(100, 60)).toBe(50);\n  });\n});\n```\n\n### E2E Tests (Playwright)\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest('user can sign in', async ({ page }) => {\n  await page.goto('/login');\n  await page.fill('input[name=\"email\"]', 'user@example.com');\n  await page.fill('input[name=\"password\"]', 'password123');\n  await page.click('button[type=\"submit\"]');\n  \n  await expect(page).toHaveURL('/dashboard');\n});\n```\n\n## Error Handling\n\n### API Error Handling\n```typescript\nimport { TRPCError } from '@trpc/server';\n\nexport const userRouter = router({\n  getUser: publicProcedure\n    .input(z.object({ id: z.string() }))\n    .query(async ({ input }) => {\n      const user = await db.user.findUnique({ where: { id: input.id } });\n      \n      if (!user) {\n        throw new TRPCError({\n          code: 'NOT_FOUND',\n          message: 'User not found',\n        });\n      }\n      \n      return user;\n    }),\n});\n```\n\n### UI Error Boundaries\n```typescript\n'use client';\n\nimport { Component, type ReactNode } from 'react';\n\nexport class ErrorBoundary extends Component<\n  { children: ReactNode },\n  { hasError: boolean }\n> {\n  constructor(props: { children: ReactNode }) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>Something went wrong</div>;\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n## Git Commit Conventions\n\nFollow Conventional Commits:\n```\nfeat: Add user authentication\nfix: Resolve login redirect issue\nrefactor: Simplify database queries\ndocs: Update API documentation\ntest: Add user service tests\nchore: Update dependencies\n```\n\n## AI Assistant Instructions\n\nWhen generating code:\n1. Always use TypeScript with proper types\n2. Follow the file organization structure\n3. Implement proper error handling\n4. Add accessibility attributes\n5. Include security best practices\n6. Write self-documenting code with clear variable names\n7. Add JSDoc comments for complex functions\n8. Suggest tests for new functionality\n\nWhen reviewing code:\n1. Check for type safety violations\n2. Verify security best practices\n3. Ensure accessibility compliance\n4. Identify performance bottlenecks\n5. Suggest improvements for code quality\n```\n\n### Python + FastAPI Backend\n\n**Command:**\n```\n/cursor-rules --python --strict --security-focused --testing\n```\n\n**Generated `.cursorrules`:**\n```markdown\n# Python + FastAPI Backend Rules\n\nYou are an expert Python backend developer specializing in FastAPI, async programming, and RESTful API design.\n\n## Technology Stack\n\n- **Framework**: FastAPI 0.110+\n- **Async**: asyncio, aiohttp\n- **ORM**: SQLAlchemy 2.0 (async)\n- **Validation**: Pydantic v2\n- **Testing**: pytest, pytest-asyncio\n- **Linting**: Ruff, mypy\n\n## Code Style\n\n### Type Hints\n- Always use type hints for function signatures\n- Use `typing` module for complex types\n- Enable mypy strict mode\n\n```python\nfrom typing import Optional, List\nfrom datetime import datetime\n\ndef get_users(\n    limit: int = 10,\n    offset: int = 0,\n    active_only: bool = True\n) -> List[User]:\n    \"\"\"Retrieve users with pagination.\"\"\"\n    return db.query(User).limit(limit).offset(offset).all()\n```\n\n### Async/Await\n- Use async functions for I/O operations\n- Properly await all async calls\n- Use `asyncio.gather()` for parallel operations\n\n```python\nimport asyncio\n\nasync def fetch_user_data(user_id: str) -> UserData:\n    profile, settings, posts = await asyncio.gather(\n        fetch_profile(user_id),\n        fetch_settings(user_id),\n        fetch_posts(user_id)\n    )\n    return UserData(profile=profile, settings=settings, posts=posts)\n```\n\n### Error Handling\n```python\nfrom fastapi import HTTPException\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: str) -> User:\n    user = await db.get(User, user_id)\n    \n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"User not found\"\n        )\n    \n    return user\n```\n\n## Security Best Practices\n\n- Use environment variables for secrets\n- Implement OAuth2 with JWT\n- Apply rate limiting\n- Validate all input with Pydantic\n- Use parameterized queries\n\n```python\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)) -> User:\n    user = await verify_token(token)\n    if not user:\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n    return user\n```\n```\n\n## Best Practices\n\n1. **Project-Specific**: Tailor rules to your exact tech stack\n2. **Clear Examples**: Include both good and bad code examples\n3. **Security First**: Always include security best practices\n4. **Performance**: Add performance optimization guidelines\n5. **Accessibility**: Include WCAG guidelines for frontend projects\n6. **Testing**: Specify testing requirements and patterns\n7. **Git Conventions**: Define commit message standards\n8. **AI Instructions**: Guide AI on how to generate and review code",
  "configuration": {
    "temperature": 0.3,
    "maxTokens": 8000,
    "systemPrompt": "You are a .cursorrules expert focused on creating comprehensive project-specific rules for AI-assisted development"
  },
  "githubUrl": "https://github.com/cursor-ai/cursor",
  "documentationUrl": "https://cursor.sh/docs",
  "troubleshooting": [
    {
      "issue": "Cursor AI ignores rules defined in .cursorrules file after enabling",
      "solution": "Restart Cursor IDE to reload .cursorrules from root. Verify checkbox in Settings > Cursor Settings > Rules is enabled. Limit file to 2000 tokens max."
    },
    {
      "issue": ".cursorrules file not recognized or context lost during long sessions",
      "solution": "Place .cursorrules in project root directory. Start new conversation when AI loses context. Add project-specific constraints at conversation start."
    },
    {
      "issue": "Generated rules file too large causing AI context window overflow",
      "solution": "Keep rules under 2000 tokens. Focus on critical patterns only. Split complex projects into multiple focused .cursorrules files per subdirectory."
    },
    {
      "issue": "Rules applied inconsistently across different code generations",
      "solution": "Use explicit constraints with examples. Reference rules file in first prompt: 'Follow .cursorrules exactly'. Verify Settings > Rules checkbox enabled."
    },
    {
      "issue": "Team global rules conflict with project-specific .cursorrules settings",
      "solution": "Project .cursorrules override team rules. Check Cursor dashboard for global rules. Explicitly document priority: project rules take precedence in file header."
    },
    {
      "issue": "Migration from .cursorrules to new .cursor/*.mdc system fails",
      "solution": "Create .cursor/rules directory with .mdc files (Rule Type: Always). Use .cursor/index.mdc for main rules. Set dynamic rules for context-aware activation only."
    },
    {
      "issue": "Rules exceed 500-line recommended limit causing degraded performance",
      "solution": "Refactor verbose rules into concise actionable directives. Keep under 500 lines for optimal AI performance. Prioritize specific patterns over general guidelines."
    },
    {
      "issue": "Vague cursor rules generating inconsistent or unexpected code outputs",
      "solution": "Make rules specific and actionable with explicit examples. Avoid ambiguous instructions. Use 'always use X' or 'never use Y' format with code samples."
    },
    {
      "issue": "Framework-specific rules not triggering for Next.js or React projects",
      "solution": "Specify framework at file top: 'This is a Next.js 15 project with React 19'. Include tech stack declaration. Add framework-specific patterns with examples."
    }
  ],
  "source": "community",
  "slug": "cursor-rules",
  "seoTitle": "Cursor Rules Generator for Claude"
}
