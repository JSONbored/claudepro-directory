{
  "description": "Activate Claude's extended thinking mode with multi-level planning depth from 'think' to 'ultrathink' for comprehensive strategy creation before implementation",
  "category": "commands",
  "author": "JSONbored",
  "dateAdded": "2025-10-25",
  "tags": [
    "plan-mode",
    "extended-thinking",
    "strategy",
    "architecture",
    "deep-reasoning",
    "ultrathink"
  ],
  "content": "The `/plan-mode` command activates Claude's extended thinking capabilities with progressive depth levels to create comprehensive strategies before jumping into implementation.\n\n## Features\n\n- **Multi-Level Thinking**: Progressive depth from 'think' < 'think hard' < 'think harder' < 'ultrathink'\n- **128K Token Output**: Extended thinking mode supports up to 128,000 token outputs\n- **96.5% Accuracy**: Achieves 96.5% accuracy on complex physics and coding problems\n- **Self-Reflection**: Claude evaluates alternatives before committing to solutions\n- **Architecture Planning**: Design system architecture before writing code\n- **Thought Visibility**: View Claude's reasoning process in real-time\n- **Interrupt Capability**: Press ESC to correct path during planning\n- **Research-First**: Forces research and planning before implementation\n\n## Usage\n\n```bash\n/plan-mode [task] [depth]\n```\n\n### Depth Levels\n\n- `--think` - Basic extended thinking (~30s planning)\n- `--think-hard` - Medium depth analysis (~60-90s planning)\n- `--think-harder` - Deep analysis (~2-3min planning)\n- `--ultrathink` - Maximum depth analysis (~5-10min planning)\n\n### Planning Scope\n\n- `--architecture` - System architecture and design\n- `--implementation` - Step-by-step implementation strategy\n- `--refactor` - Refactoring approach and migration path\n- `--debug` - Debugging strategy and root cause analysis\n- `--research` - Research and analysis plan\n\n### Options\n\n- `--show-thinking` - Display Claude's thought process (default: true)\n- `--no-implement` - Plan only, do NOT implement\n- `--approve-first` - Require approval before proceeding to implementation\n\n## Examples\n\n### Basic Planning (think)\n\n**Command:**\n```bash\n/plan-mode \"Add user authentication\" --think --architecture\n```\n\n**Claude's Planning:**\n```\n[Extended Thinking Mode: think]\n\nAnalyzing requirements...\n- Need secure authentication\n- Consider session management\n- Evaluate auth methods\n\nEvaluating approaches:\n1. JWT tokens (stateless, scalable)\n2. Session cookies (stateful, simple)\n3. OAuth2 (third-party, complex)\n\nSelected: JWT tokens\nReasoning: Stateless design scales better, mobile-friendly\n\nArchitecture Plan:\n\n1. Database Schema:\n   - users table (id, email, password_hash, created_at)\n   - refresh_tokens table (user_id, token, expires_at)\n\n2. API Endpoints:\n   POST /api/auth/register\n   POST /api/auth/login\n   POST /api/auth/refresh\n   POST /api/auth/logout\n\n3. Middleware:\n   - Authentication middleware (verify JWT)\n   - Rate limiting (prevent brute force)\n\n4. Security:\n   - bcrypt for password hashing (cost: 12)\n   - JWT expiry: 15min access, 7d refresh\n   - HTTPS only\n\nReady to implement? (y/n)\n```\n\n### Deep Planning (think harder)\n\n**Command:**\n```bash\n/plan-mode \"Migrate from REST to GraphQL\" --think-harder --refactor\n```\n\n**Claude's Deep Analysis:**\n```\n[Extended Thinking Mode: think harder]\n\nAnalyzing current state...\n- 45 REST endpoints across 8 resources\n- Mixed response formats (some paginated, some not)\n- Over-fetching in 12 endpoints\n- Under-fetching requiring 3+ requests in 8 workflows\n\nEvaluating migration strategies:\n\n1. Big Bang Migration:\n   Pros: Clean break, no dual maintenance\n   Cons: High risk, long freeze\n   Risk: HIGH\n\n2. Gradual Migration (selected):\n   Pros: Low risk, incremental value\n   Cons: Dual maintenance period\n   Risk: LOW\n\n3. Parallel Systems:\n   Pros: Safe rollback\n   Cons: Infrastructure cost\n   Risk: MEDIUM\n\nSelected: Gradual Migration\nReasoning: Minimize risk, maintain velocity\n\nMigration Plan (8-week timeline):\n\nWeek 1-2: Foundation\n- Install Apollo Server\n- Design GraphQL schema\n- Setup type generation\n- Create resolver boilerplate\n\nWeek 3-4: Core Resources (Priority: High)\n- Migrate User queries/mutations\n- Migrate Post queries/mutations\n- Add DataLoader for N+1 prevention\n- Write integration tests\n\nWeek 5-6: Secondary Resources\n- Migrate Comments\n- Migrate Tags\n- Migrate Categories\n- Performance benchmarking\n\nWeek 7: Optimization\n- Query complexity limiting\n- Persisted queries\n- APQ (Automatic Persisted Queries)\n- Caching strategy\n\nWeek 8: Cutover\n- Feature flag rollout (10% → 50% → 100%)\n- Monitor error rates\n- Deprecate REST endpoints\n- Documentation update\n\nDependencies:\n- GraphQL code generator\n- Apollo Server 4.x\n- DataLoader\n- GraphQL Tools\n\nRisks & Mitigation:\n1. Schema design issues\n   → Weekly schema reviews\n2. Performance regressions\n   → Load testing before each phase\n3. Breaking changes for clients\n   → Maintain REST parallel for 3 months\n\nSuccess Metrics:\n- Reduce API calls by 40%\n- Improve response times by 25%\n- Client satisfaction > 8/10\n\nReady to proceed with Week 1-2? (y/n)\n```\n\n### Maximum Depth (ultrathink)\n\n**Command:**\n```bash\n/plan-mode \"Design scalable microservices architecture\" --ultrathink --architecture\n```\n\n**Claude's Comprehensive Analysis:**\n```\n[Extended Thinking Mode: ultrathink]\n[This may take 5-10 minutes for thorough analysis]\n\nPhase 1: Requirements Analysis\n\nCurrent System:\n- Monolithic architecture (250K LOC)\n- PostgreSQL database (2TB)\n- Peak load: 10K req/s\n- Team: 20 developers\n- Deployment: Weekly releases\n\nPain Points:\n- Deployment requires full system downtime\n- Database bottleneck at peak load\n- Slow feature velocity (conflicting changes)\n- Scaling inefficient (must scale entire monolith)\n\nGoals:\n- Zero-downtime deployments\n- Independent service scaling\n- Faster feature delivery\n- Improved fault isolation\n\nPhase 2: Service Decomposition Strategy\n\nBoundary Identification:\n\n1. User Service\n   - Domain: Identity, authentication\n   - Data: 5M users, 100MB\n   - Load: 2K req/s\n   - Team: 3 developers\n\n2. Product Service\n   - Domain: Catalog, inventory\n   - Data: 1M products, 50GB\n   - Load: 5K req/s\n   - Team: 5 developers\n\n3. Order Service\n   - Domain: Transactions, fulfillment\n   - Data: 10M orders, 500GB\n   - Load: 1K req/s\n   - Team: 4 developers\n\n4. Payment Service\n   - Domain: Billing, subscriptions\n   - Data: 8M transactions, 200GB\n   - Load: 800 req/s\n   - Team: 3 developers\n\n5. Notification Service\n   - Domain: Email, SMS, push\n   - Data: Events only\n   - Load: 3K req/s\n   - Team: 2 developers\n\nPhase 3: Technology Stack\n\n```yaml\nServices:\n  user-service:\n    runtime: Node.js (Fast user queries)\n    database: PostgreSQL (ACID for users)\n    cache: Redis (Session storage)\n    \n  product-service:\n    runtime: Node.js (Heavy read workload)\n    database: PostgreSQL (Primary)\n    cache: Redis (Product catalog)\n    search: Elasticsearch (Full-text search)\n    \n  order-service:\n    runtime: Node.js (Transaction handling)\n    database: PostgreSQL (Strong consistency)\n    message-queue: RabbitMQ (Order processing)\n    \n  payment-service:\n    runtime: Node.js (PCI compliance)\n    database: PostgreSQL (Financial data)\n    encryption: At-rest and in-transit\n    \n  notification-service:\n    runtime: Node.js (I/O heavy)\n    queue: RabbitMQ (Async delivery)\n    providers: SendGrid, Twilio, FCM\n```\n\nPhase 4: Communication Patterns\n\nSynchronous (REST/GraphQL):\n- User → Product (Browse catalog)\n- Order → Payment (Process transaction)\n\nAsynchronous (Event-Driven):\n- Order Created → Notification (Send confirmation)\n- Payment Success → Order (Update status)\n- Product Updated → Search (Index update)\n\nPhase 5: Data Management\n\nDatabase Per Service:\n- User Service: users DB\n- Product Service: products DB\n- Order Service: orders DB\n- Payment Service: payments DB\n\nShared Data Access Patterns:\n1. API calls (preferred)\n2. Event sourcing (eventual consistency)\n3. CQRS (read replicas)\n\nPhase 6: Migration Strategy (12 months)\n\nQuarter 1: Foundation\n- Week 1-4: Setup Kubernetes cluster\n- Week 5-8: Implement API gateway\n- Week 9-12: Extract User Service (lowest risk)\n\nQuarter 2: Core Services\n- Week 13-18: Extract Product Service\n- Week 19-24: Extract Order Service\n\nQuarter 3: Financial Systems\n- Week 25-32: Extract Payment Service (highest risk)\n- Week 33-36: Audit and compliance\n\nQuarter 4: Supporting Services\n- Week 37-42: Extract Notification Service\n- Week 43-48: Decommission monolith\n- Week 49-52: Optimization and monitoring\n\nPhase 7: Infrastructure\n\n```yaml\nKubernetes:\n  nodes: 20 (auto-scaling 10-50)\n  namespaces: dev, staging, production\n  \nService Mesh (Istio):\n  - Traffic management\n  - Circuit breaking\n  - Mutual TLS\n  - Observability\n  \nMonitoring:\n  - Prometheus (metrics)\n  - Grafana (dashboards)\n  - Jaeger (distributed tracing)\n  - ELK Stack (logging)\n  \nCI/CD:\n  - GitHub Actions\n  - ArgoCD (GitOps)\n  - Canary deployments\n```\n\nPhase 8: Risk Assessment\n\nHigh Risk:\n1. Data consistency during migration\n   Mitigation: Dual-write pattern, verify before cutover\n   \n2. Service discovery failures\n   Mitigation: Health checks, circuit breakers\n   \n3. Distributed transaction complexity\n   Mitigation: Saga pattern, compensating transactions\n\nMedium Risk:\n1. Team skill gaps\n   Mitigation: Training program, pair programming\n   \n2. Infrastructure costs increase\n   Mitigation: Right-sizing, spot instances\n\nLow Risk:\n1. Monitoring gaps\n   Mitigation: Observability-first design\n\nPhase 9: Success Metrics\n\nTechnical:\n- Deployment frequency: 1/week → 10/day\n- Lead time: 2 weeks → 2 days\n- MTTR: 4 hours → 30 minutes\n- Service uptime: 99.5% → 99.95%\n\nBusiness:\n- Feature velocity: +200%\n- Cost per transaction: -30%\n- Customer satisfaction: +15%\n\nPhase 10: Go/No-Go Decision\n\nRecommendation: PROCEED\n\nReasoning:\n- Clear business case (velocity + uptime)\n- Manageable risk with mitigation plan\n- Team buy-in confirmed\n- Budget approved\n\nNext Steps:\n1. Form migration team (5 engineers)\n2. Setup Kubernetes cluster (Week 1)\n3. Begin User Service extraction (Week 5)\n\nEstimated Total Cost: $450K (infrastructure + developer time)\nROI Timeline: 18 months\n\nApprove architecture plan? (y/n)\n```\n\n## Thinking Levels Comparison\n\n| Level | Time | Depth | Use Case |\n|-------|------|-------|----------|\n| think | 30s | Surface analysis | Quick decisions, simple tasks |\n| think hard | 60-90s | Multiple alternatives | Feature planning, moderate complexity |\n| think harder | 2-3min | Deep analysis, risks | Refactoring, architecture changes |\n| ultrathink | 5-10min | Comprehensive strategy | System design, migrations |\n\n## When to Use Each Level\n\n### --think (Quick Planning)\n- Adding a new API endpoint\n- Fixing a known bug\n- Writing a simple feature\n- Code refactoring (small scope)\n\n### --think-hard (Moderate Planning)\n- Designing a new feature\n- Database schema changes\n- Integration with third-party service\n- Performance optimization\n\n### --think-harder (Deep Planning)\n- Large refactoring projects\n- Migration strategies\n- Architecture improvements\n- Complex debugging\n\n### --ultrathink (Maximum Planning)\n- Microservices architecture\n- System-wide migrations\n- Technology stack changes\n- Multi-month projects\n\n## Best Practices\n\n1. **Plan Before Code**: Use `/plan-mode` before implementing complex features\n2. **Interrupt When Needed**: Press ESC if Claude's plan goes off track\n3. **Approve Before Proceeding**: Use `--approve-first` for critical changes\n4. **Match Depth to Complexity**: Don't use ultrathink for simple tasks\n5. **Review Alternatives**: Extended thinking evaluates multiple approaches\n6. **Document Plans**: Plans serve as architecture documentation\n7. **Iterate on Feedback**: Refine plan based on team input\n\n## Integration with Other Commands\n\n### Plan → TDD Workflow\n```bash\n/plan-mode \"Add payment processing\" --think-hard --no-implement\n# Review plan\n/tdd-workflow \"Implement payment processing per plan\" --unit\n```\n\n### Plan → Subagents\n```bash\n/plan-mode \"Refactor auth system\" --think-harder --no-implement\n# Review plan\n/subagent-create --architect --code-reviewer --test-engineer\n# Implement with specialist subagents\n```\n\n### Plan → Checkpoints\n```bash\n/plan-mode \"Database migration\" --ultrathink\n# Create checkpoint before proceeding\n# Implement migration\n# Rewind if issues arise\n```",
  "configuration": {
    "temperature": 0.1,
    "maxTokens": 32000,
    "systemPrompt": "You are using Claude's extended thinking mode. Take time to deeply analyze the problem, evaluate multiple alternatives, and create a comprehensive strategy before implementation. Show your reasoning process."
  },
  "githubUrl": "https://github.com/anthropics/claude-code",
  "documentationUrl": "https://docs.claude.com/en/docs/claude-code/extended-thinking",
  "discoveryMetadata": {
    "researchDate": "2025-10-25",
    "trendingSources": [
      {
        "source": "anthropic_claude_4",
        "evidence": "Claude Opus 4 and Sonnet 4 introduced as hybrid models with extended thinking mode achieving 96.5% accuracy on complex physics problems and 128K token output capability",
        "url": "https://www.anthropic.com/news/claude-4",
        "relevanceScore": "high"
      },
      {
        "source": "medium_extended_thinking",
        "evidence": "Article 'Claude Code and Extended Thinking: The Hybrid Reasoning Revolution' showing Claude processes information through self-reflection before answering",
        "url": "https://medium.com/@cognidownunder/claude-code-and-extended-thinking-the-hybrid-reasoning-revolution-thats-changing-how-we-code-4c59cb714015",
        "relevanceScore": "high"
      },
      {
        "source": "anthropic_best_practices",
        "evidence": "Anthropic's official best practices documentation emphasizes 'think' trigger phrases mapping to increasing thinking budget levels for complex problem solving",
        "url": "https://www.anthropic.com/engineering/claude-code-best-practices",
        "relevanceScore": "high"
      },
      {
        "source": "simon_willison",
        "evidence": "Simon Willison's analysis of Claude 3.7 Sonnet extended thinking with 128K token output (15x previous limit) for complex coding tasks",
        "url": "https://simonw.substack.com/p/claude-37-sonnet-extended-thinking",
        "relevanceScore": "high"
      }
    ],
    "keywordResearch": {
      "primaryKeywords": [
        "Claude extended thinking",
        "plan mode",
        "ultrathink",
        "deep reasoning",
        "architecture planning"
      ],
      "searchVolume": "high",
      "competitionLevel": "low"
    },
    "gapAnalysis": {
      "existingContent": [],
      "identifiedGap": "No existing command for activating plan mode or extended thinking in Claude Code. Anthropic's best practices strongly recommend planning before implementation, yet no command enforces this workflow. Extended thinking mode achieves 96.5% accuracy and supports 128K token outputs but requires specific trigger phrases ('think', 'ultrathink') that users don't know. This is critical for complex tasks.",
      "priority": "high"
    },
    "approvalRationale": "Extended thinking is THE breakthrough reasoning capability in Claude 4 models with 96.5% accuracy on complex problems and 128K token outputs. Anthropic's official best practices emphasize planning before coding, yet NO command helps users activate this mode. The progressive depth system ('think' < 'ultrathink') is poorly documented. High value, low competition, and directly endorsed by Anthropic makes this essential content."
  },
  "troubleshooting": [
    {
      "issue": "Extended thinking mode takes too long, blocking development workflow",
      "solution": "Use lower depth levels: --think for quick analysis, reserve --ultrathink for system-wide changes. Press ESC to interrupt and skip to implementation if plan is already clear. Set time limits: /plan-mode --timeout=2m for bounded planning."
    },
    {
      "issue": "Plan recommendations differ significantly from expected approach",
      "solution": "Provide more context in prompt: specify constraints, existing patterns, team preferences. Use --show-thinking to see Claude's reasoning. Press ESC when divergence detected to correct direction. Iterate: 'consider approach X instead'."
    },
    {
      "issue": "Generated plan lacks specific implementation details, too high-level",
      "solution": "Use --implementation scope instead of --architecture. Increase depth: --think-harder or --ultrathink for detailed step-by-step plans. Request specifics: 'include file names, function signatures, database queries in plan'."
    },
    {
      "issue": "Claude jumps to implementation despite plan-mode command",
      "solution": "Use --no-implement flag to enforce planning only. Explicitly state: 'Create detailed plan but do NOT implement yet'. Verify plan-mode activated by checking for [Extended Thinking Mode] header. Use --approve-first for manual gate."
    },
    {
      "issue": "Plan exceeds token limit or gets truncated mid-strategy",
      "solution": "Extended thinking supports 128K tokens but may hit conversation limits. Break into phases: plan architecture first, then implementation details separately. Use --scope to focus: --scope=database for DB-specific planning. Save plan to file before proceeding."
    }
  ],
  "source": "community",
  "slug": "plan-mode",
  "seoTitle": "Plan Mode & Extended Thinking for Claude Code"
}
