{
  "title": "Automated Test Runner Hook",
  "description": "Automatically run relevant tests when code changes are detected, with intelligent test selection and parallel execution",
  "category": "automation",
  "author": "shadowbook",
  "dateAdded": "2025-09-16",
  "tags": ["testing", "automation", "ci-cd", "watch", "parallel"],
  "content": "The Automated Test Runner Hook intelligently executes tests based on code changes with smart test selection and performance optimization.\n\n## Features\n\n### Intelligent Test Selection\n- **Impact Analysis** - Run only tests affected by code changes\n- **Dependency Mapping** - Understand which tests depend on changed files\n- **Pattern Recognition** - Learn from test execution patterns\n- **Risk Assessment** - Prioritize critical path tests\n\n### Execution Strategies\n- **Parallel Execution** - Run tests concurrently for faster feedback\n- **Incremental Testing** - Only run necessary tests\n- **Fail-Fast Mode** - Stop on first failure for quick feedback\n- **Smart Retry** - Retry flaky tests with exponential backoff\n\n### Framework Support\n- **JavaScript/TypeScript**: Jest, Vitest, Mocha, Jasmine\n- **Python**: pytest, unittest, nose2\n- **Java**: JUnit, TestNG, Spock\n- **C#**: NUnit, xUnit, MSTest\n- **Go**: go test, Ginkgo\n- **Ruby**: RSpec, Minitest\n\n## Configuration\n\n### Basic Setup\n```json\n{\n  \"testRunner\": {\n    \"enabled\": true,\n    \"frameworks\": [\"jest\", \"pytest\"],\n    \"watchMode\": true,\n    \"parallel\": true,\n    \"maxWorkers\": 4\n  },\n  \"triggers\": {\n    \"onSave\": true,\n    \"onCommit\": true,\n    \"onPush\": false,\n    \"debounceMs\": 500\n  },\n  \"testSelection\": {\n    \"strategy\": \"affected\",\n    \"includeIntegration\": false,\n    \"includeE2E\": false,\n    \"minCoverage\": 80\n  }\n}\n```\n\n### Advanced Configuration\n```json\n{\n  \"testRunner\": {\n    \"enabled\": true,\n    \"frameworks\": {\n      \"jest\": {\n        \"configPath\": \"jest.config.js\",\n        \"args\": [\"--coverage\", \"--verbose\"],\n        \"env\": {\n          \"NODE_ENV\": \"test\"\n        }\n      },\n      \"pytest\": {\n        \"configPath\": \"pytest.ini\",\n        \"args\": [\"-v\", \"--cov=src\"],\n        \"env\": {\n          \"ENVIRONMENT\": \"test\"\n        }\n      }\n    }\n  },\n  \"performance\": {\n    \"timeout\": 30000,\n    \"maxRetries\": 3,\n    \"retryDelay\": 1000,\n    \"cacheResults\": true,\n    \"cacheExpiry\": 3600\n  },\n  \"notifications\": {\n    \"onSuccess\": false,\n    \"onFailure\": true,\n    \"onFlaky\": true,\n    \"channels\": [\"console\", \"desktop\", \"slack\"]\n  }\n}\n```\n\n## Usage Examples\n\n### File Change Detection\n```javascript\n// When editing src/utils/calculator.js\n// Automatically runs:\n// - src/utils/__tests__/calculator.test.js\n// - src/components/__tests__/Calculator.test.js\n// - Any integration tests using calculator\n\nconst changedFiles = ['src/utils/calculator.js'];\nconst affectedTests = testRunner.getAffectedTests(changedFiles);\n// Returns: [\n//   'src/utils/__tests__/calculator.test.js',\n//   'src/components/__tests__/Calculator.test.js'\n// ]\n```\n\n### Smart Test Execution\n```bash\n# Console output example\n🔄 Code change detected: src/api/users.js\n🧪 Running affected tests...\n\n┌─ Test Selection ─────────────────────────\n│ Strategy: affected\n│ Found: 8 affected tests\n│ Skipped: 142 unrelated tests\n│ Estimated time: 12s\n└─────────────────────────────────────────\n\n✅ src/api/__tests__/users.test.js (2.1s)\n✅ src/components/__tests__/UserList.test.js (1.8s)\n✅ src/services/__tests__/userService.test.js (3.2s)\n❌ src/integration/__tests__/userFlow.test.js (5.1s)\n\n┌─ Test Results ───────────────────────────\n│ ✅ Passed: 3/4 tests\n│ ❌ Failed: 1 test\n│ ⏱️  Total time: 12.2s\n│ 📊 Coverage: 89.2% (+2.1%)\n└─────────────────────────────────────────\n\n❌ FAILED: src/integration/__tests__/userFlow.test.js\n   Expected user creation to return 201, got 400\n   \n🔧 Quick Actions:\n   [r] Retry failed tests\n   [d] Debug failed test\n   [i] Ignore and continue\n   [o] Open test file\n```\n\n### Git Integration\n```bash\n# Pre-commit hook example\n#!/bin/bash\n# .git/hooks/pre-commit\n\n# Get staged files\nSTAGED_FILES=$(git diff --cached --name-only)\n\n# Run tests for affected files\necho \"Running tests for staged changes...\"\nnode scripts/test-runner.js --files=\"$STAGED_FILES\" --fail-fast\n\nif [ $? -ne 0 ]; then\n  echo \"❌ Tests failed. Commit aborted.\"\n  echo \"Fix failing tests or use 'git commit --no-verify' to skip.\"\n  exit 1\nfi\n\necho \"✅ All tests passed. Proceeding with commit.\"\n```\n\n## Test Selection Algorithms\n\n### Impact Analysis\n```javascript\nclass ImpactAnalyzer {\n  analyzeChanges(changedFiles) {\n    const impactMap = new Map();\n    \n    for (const file of changedFiles) {\n      // Direct test files\n      const directTests = this.findDirectTests(file);\n      \n      // Dependency analysis\n      const dependentFiles = this.findDependents(file);\n      const dependentTests = this.findTestsForFiles(dependentFiles);\n      \n      // Import/export analysis\n      const importedBy = this.findImporters(file);\n      const importerTests = this.findTestsForFiles(importedBy);\n      \n      impactMap.set(file, {\n        directTests,\n        dependentTests,\n        importerTests,\n        riskScore: this.calculateRiskScore(file)\n      });\n    }\n    \n    return this.prioritizeTests(impactMap);\n  }\n  \n  calculateRiskScore(file) {\n    const factors = {\n      complexity: this.getComplexity(file),\n      changeFrequency: this.getChangeFrequency(file),\n      testCoverage: this.getTestCoverage(file),\n      bugHistory: this.getBugHistory(file)\n    };\n    \n    return factors.complexity * 0.3 +\n           factors.changeFrequency * 0.2 +\n           (1 - factors.testCoverage) * 0.3 +\n           factors.bugHistory * 0.2;\n  }\n}\n```\n\n### Parallel Execution\n```javascript\nclass ParallelTestRunner {\n  async runTests(testFiles, options = {}) {\n    const { maxWorkers = os.cpus().length } = options;\n    const chunks = this.chunkTests(testFiles, maxWorkers);\n    \n    const results = await Promise.all(\n      chunks.map(chunk => this.runTestChunk(chunk))\n    );\n    \n    return this.mergeResults(results);\n  }\n  \n  chunkTests(tests, maxWorkers) {\n    // Smart chunking based on test duration history\n    const testDurations = this.getTestDurations(tests);\n    return this.balanceChunks(tests, testDurations, maxWorkers);\n  }\n  \n  async runTestChunk(tests) {\n    const worker = new Worker('./test-worker.js');\n    \n    return new Promise((resolve, reject) => {\n      worker.postMessage({ tests });\n      worker.on('message', resolve);\n      worker.on('error', reject);\n    });\n  }\n}\n```\n\n## Notifications & Reporting\n\n### Desktop Notifications\n```javascript\n// Success notification\nnotifier.notify({\n  title: '✅ Tests Passed',\n  message: '8 tests completed in 12.3s',\n  sound: false,\n  timeout: 3\n});\n\n// Failure notification\nnotifier.notify({\n  title: '❌ Tests Failed',\n  message: '3 of 8 tests failed',\n  sound: true,\n  timeout: 10,\n  actions: ['View Details', 'Retry']\n});\n```\n\n### Slack Integration\n```javascript\nconst slackMessage = {\n  channel: '#dev-notifications',\n  blocks: [\n    {\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: ':warning: *Test Failure Alert*'\n      }\n    },\n    {\n      type: 'section',\n      fields: [\n        {\n          type: 'mrkdwn',\n          text: `*Branch:* ${branchName}`\n        },\n        {\n          type: 'mrkdwn',\n          text: `*Failed Tests:* ${failedCount}`\n        }\n      ]\n    }\n  ]\n};\n```\n\n## Performance Optimization\n\n### Test Caching\n```javascript\nclass TestCache {\n  constructor() {\n    this.cache = new Map();\n    this.fileHashes = new Map();\n  }\n  \n  async getResults(testFile, dependencies) {\n    const cacheKey = this.generateCacheKey(testFile, dependencies);\n    \n    if (this.cache.has(cacheKey)) {\n      const cached = this.cache.get(cacheKey);\n      if (this.isValid(cached, dependencies)) {\n        return cached.results;\n      }\n    }\n    \n    return null;\n  }\n  \n  generateCacheKey(testFile, dependencies) {\n    const hashes = dependencies.map(dep => this.getFileHash(dep));\n    return crypto.createHash('sha256')\n      .update(testFile + hashes.join(''))\n      .digest('hex');\n  }\n}\n```\n\n## Integration Examples\n\n### VS Code Extension\n```json\n{\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"testRunner.runAffected\",\n        \"title\": \"Run Affected Tests\"\n      },\n      {\n        \"command\": \"testRunner.toggleWatch\",\n        \"title\": \"Toggle Test Watch Mode\"\n      }\n    ],\n    \"keybindings\": [\n      {\n        \"command\": \"testRunner.runAffected\",\n        \"key\": \"ctrl+shift+t\",\n        \"when\": \"editorTextFocus\"\n      }\n    ]\n  }\n}\n```",
  "configuration": {
    "temperature": 0.3,
    "maxTokens": 8000,
    "systemPrompt": "You are a test automation expert focused on intelligent test execution and developer productivity"
  },
  "githubUrl": "https://github.com/claudepro/test-runner-hook",
  "documentationUrl": "https://docs.claude.ai/hooks/test-runner"
}