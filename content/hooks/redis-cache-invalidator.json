{
  "slug": "redis-cache-invalidator",
  "description": "Automatically clears relevant Redis cache keys when data model files are modified",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-09-19",
  "tags": ["redis", "cache", "performance", "data-models", "invalidation"],
  "hookType": "PostToolUse",
  "features": [
    "Intelligent cache key invalidation",
    "Model-based cache clearing",
    "Pattern matching for cache keys",
    "Safe asynchronous cache flushing",
    "Multi-language model support",
    "Cache consistency maintenance"
  ],
  "useCases": [
    "Invalidate cache when data models are modified",
    "Maintain cache consistency in Redis",
    "Clear related cache entries automatically",
    "Prevent stale data in cache after model changes",
    "Optimize cache management workflow",
    "Handle cache invalidation for microservices",
    "Automate cache clearing for API responses",
    "Ensure data consistency across cache layers"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "postToolUse": {
          "script": "./.claude/hooks/redis-cache-invalidator.sh",
          "matchers": ["write", "edit"]
        }
      }
    },
    "scriptContent": "#!/bin/bash\n\n# Read the tool input from stdin\nINPUT=$(cat)\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"')\n\nif [ -z \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\necho \"üîÑ Redis Cache Invalidator - Analyzing file changes...\"\necho \"üìÑ File: $FILE_PATH\"\n\n# Check if this is a model or data file that should trigger cache invalidation\nif [[ \"$FILE_PATH\" == *models/*.js ]] || [[ \"$FILE_PATH\" == *models/*.py ]] || [[ \"$FILE_PATH\" == *models/*.ts ]] || [[ \"$FILE_PATH\" == *schemas/*.* ]] || [[ \"$FILE_PATH\" == *entities/*.* ]]; then\n    \n    MODEL_NAME=$(basename \"${FILE_PATH%.*}\")\n    echo \"üìä Model detected: $MODEL_NAME\"\n    \n    # Check if Redis CLI is available\n    if ! command -v redis-cli >/dev/null 2>&1; then\n        echo \"‚ö†Ô∏è redis-cli not found - please install Redis CLI tools\"\n        echo \"üí° Install with: apt-get install redis-tools (Ubuntu) or brew install redis (macOS)\"\n        exit 0\n    fi\n    \n    # Test Redis connection\n    if ! redis-cli ping >/dev/null 2>&1; then\n        echo \"‚ö†Ô∏è Redis server not accessible - skipping cache invalidation\"\n        echo \"üí° Ensure Redis server is running and accessible\"\n        exit 0\n    fi\n    \n    echo \"üîç Scanning for cache keys related to: $MODEL_NAME\"\n    \n    # Find cache keys related to this model\n    CACHE_KEYS=$(redis-cli --scan --pattern \"*${MODEL_NAME}*\" 2>/dev/null)\n    \n    if [ -n \"$CACHE_KEYS\" ]; then\n        KEY_COUNT=$(echo \"$CACHE_KEYS\" | wc -l)\n        echo \"üóëÔ∏è Found $KEY_COUNT cache keys to invalidate:\"\n        \n        # Show first few keys for confirmation\n        echo \"$CACHE_KEYS\" | head -5 | while read -r key; do\n            echo \"  ‚Ä¢ $key\"\n        done\n        \n        if [ \"$KEY_COUNT\" -gt 5 ]; then\n            echo \"  ... and $((KEY_COUNT - 5)) more keys\"\n        fi\n        \n        # Delete the keys\n        echo \"$CACHE_KEYS\" | xargs -r redis-cli DEL >/dev/null 2>&1\n        echo \"‚úÖ Invalidated $KEY_COUNT cache keys for model: $MODEL_NAME\"\n    else\n        echo \"‚ÑπÔ∏è No cache keys found for model: $MODEL_NAME\"\n    fi\n    \n    # Additional patterns to check\n    echo \"üîç Checking additional cache patterns...\"\n    \n    # Check for API route caches\n    API_KEYS=$(redis-cli --scan --pattern \"api:*${MODEL_NAME}*\" 2>/dev/null)\n    if [ -n \"$API_KEYS\" ]; then\n        API_COUNT=$(echo \"$API_KEYS\" | wc -l)\n        echo \"$API_KEYS\" | xargs -r redis-cli DEL >/dev/null 2>&1\n        echo \"‚úÖ Invalidated $API_COUNT API cache keys\"\n    fi\n    \n    # Check for query result caches\n    QUERY_KEYS=$(redis-cli --scan --pattern \"query:*${MODEL_NAME}*\" 2>/dev/null)\n    if [ -n \"$QUERY_KEYS\" ]; then\n        QUERY_COUNT=$(echo \"$QUERY_KEYS\" | wc -l)\n        echo \"$QUERY_KEYS\" | xargs -r redis-cli DEL >/dev/null 2>&1\n        echo \"‚úÖ Invalidated $QUERY_COUNT query cache keys\"\n    fi\n    \n    # Check current Redis stats\n    echo \"\"\n    echo \"üìä Redis Cache Statistics:\"\n    TOTAL_KEYS=$(redis-cli DBSIZE 2>/dev/null || echo \"unknown\")\n    MEMORY_USAGE=$(redis-cli INFO memory 2>/dev/null | grep used_memory_human | cut -d: -f2 | tr -d '\\r' || echo \"unknown\")\n    echo \"  ‚Ä¢ Total keys: $TOTAL_KEYS\"\n    echo \"  ‚Ä¢ Memory usage: $MEMORY_USAGE\"\n    \n    echo \"\"\n    echo \"üí° Cache Invalidation Tips:\"\n    echo \"  ‚Ä¢ Use consistent cache key naming patterns\"\n    echo \"  ‚Ä¢ Consider cache TTL for automatic expiration\"\n    echo \"  ‚Ä¢ Monitor cache hit/miss ratios\"\n    echo \"  ‚Ä¢ Use Redis keyspace notifications for advanced invalidation\"\n    \n    echo \"\"\n    echo \"üéØ Cache invalidation complete!\"\n    \nelif [[ \"$FILE_PATH\" == *config/*.* ]] || [[ \"$FILE_PATH\" == *.env ]]; then\n    echo \"‚öôÔ∏è Configuration file detected - consider full cache flush if needed\"\n    echo \"üí° Run 'redis-cli FLUSHDB' manually if configuration affects cached data\"\n    \nelse\n    echo \"‚ÑπÔ∏è File does not require cache invalidation: $FILE_PATH\"\nfi\n\nexit 0"
  },
  "source": "community"
}
