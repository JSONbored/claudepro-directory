{
  "slug": "python-linter-integration",
  "description": "Automatically runs pylint on Python files after editing to enforce code quality standards",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-09-19",
  "tags": ["python", "linting", "code-quality", "pylint"],
  "hookType": "PostToolUse",
  "features": [
    "Automatic pylint execution on Python file changes",
    "Code quality assessment and scoring",
    "PEP 8 compliance checking",
    "Error and warning detection",
    "Code complexity analysis",
    "Configurable linting rules"
  ],
  "useCases": [
    "Enforce Python coding standards automatically",
    "Catch potential bugs and code issues early",
    "Maintain consistent code quality across projects",
    "Provide immediate feedback on code changes",
    "Integrate linting into development workflow",
    "Monitor code complexity and maintainability",
    "Ensure PEP 8 compliance",
    "Run quality checks before commits"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "postToolUse": {
          "script": "./.claude/hooks/python-linter-integration.sh",
          "matchers": ["write", "edit"]
        }
      }
    },
    "scriptContent": "#!/bin/bash\n\n# Read the tool input from stdin\nINPUT=$(cat)\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"')\n\nif [ -z \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\n# Check if this is a Python file\nif [[ \"$FILE_PATH\" == *.py ]]; then\n    echo \"üîç Python Linter Integration - Analyzing code quality...\"\n    echo \"üìÑ File: $FILE_PATH\"\n    \n    # Check if file exists\n    if [ ! -f \"$FILE_PATH\" ]; then\n        echo \"‚ö†Ô∏è File not found: $FILE_PATH\"\n        exit 1\n    fi\n    \n    # Check if pylint is available\n    if command -v pylint >/dev/null 2>&1; then\n        echo \"üîç Running pylint analysis...\"\n        \n        # Run pylint with custom formatting\n        PYLINT_OUTPUT=$(pylint \"$FILE_PATH\" --score=yes --reports=no --msg-template=\"{line:3d},{column:2d}: {category}: {msg} ({symbol})\" 2>/dev/null)\n        PYLINT_EXIT_CODE=$?\n        \n        if [ $PYLINT_EXIT_CODE -eq 0 ]; then\n            echo \"‚úÖ Pylint analysis passed - No issues found\"\n        else\n            echo \"üìã Pylint Analysis Results:\"\n            echo \"$PYLINT_OUTPUT\" | head -20  # Limit output to first 20 lines\n            \n            # Show summary if there are many issues\n            ISSUE_COUNT=$(echo \"$PYLINT_OUTPUT\" | wc -l)\n            if [ \"$ISSUE_COUNT\" -gt 20 ]; then\n                echo \"... and $((ISSUE_COUNT - 20)) more issues\"\n            fi\n            \n            # Extract score if available\n            SCORE=$(echo \"$PYLINT_OUTPUT\" | grep \"Your code has been rated\" | grep -o '[0-9]\\+\\.[0-9]\\+' | head -1)\n            if [ -n \"$SCORE\" ]; then\n                echo \"üìä Code Quality Score: $SCORE/10\"\n            fi\n        fi\n        \n    elif command -v flake8 >/dev/null 2>&1; then\n        echo \"üîç Running flake8 analysis (fallback)...\"\n        \n        if flake8 \"$FILE_PATH\" --max-line-length=88; then\n            echo \"‚úÖ Flake8 analysis passed - No style issues found\"\n        else\n            echo \"‚ö†Ô∏è Flake8 found style issues (non-blocking)\"\n        fi\n        \n    elif command -v pycodestyle >/dev/null 2>&1; then\n        echo \"üîç Running pycodestyle analysis (fallback)...\"\n        \n        if pycodestyle \"$FILE_PATH\" --max-line-length=88; then\n            echo \"‚úÖ Pycodestyle analysis passed - No style issues found\"\n        else\n            echo \"‚ö†Ô∏è Pycodestyle found style issues (non-blocking)\"\n        fi\n        \n    else\n        echo \"‚ö†Ô∏è No Python linters found\"\n        echo \"üí° Install options:\"\n        echo \"  ‚Ä¢ pip install pylint (recommended)\"\n        echo \"  ‚Ä¢ pip install flake8 (lightweight)\"\n        echo \"  ‚Ä¢ pip install pycodestyle (basic)\"\n    fi\n    \n    # Additional code quality checks\n    echo \"\"\n    echo \"üìä Quick Code Analysis:\"\n    \n    # Count lines of code (excluding comments and empty lines)\n    LOC=$(grep -v '^[[:space:]]*#' \"$FILE_PATH\" | grep -v '^[[:space:]]*$' | wc -l)\n    echo \"  ‚Ä¢ Lines of Code: $LOC\"\n    \n    # Check for potential issues\n    if grep -q \"print(\" \"$FILE_PATH\"; then\n        echo \"  ‚Ä¢ üí° Consider using logging instead of print statements\"\n    fi\n    \n    if grep -q \"TODO\\|FIXME\\|XXX\" \"$FILE_PATH\"; then\n        echo \"  ‚Ä¢ üìù TODOs/FIXMEs found - consider addressing them\"\n    fi\n    \n    # Check function complexity (rough estimate)\n    FUNCTION_COUNT=$(grep -c \"^def \" \"$FILE_PATH\")\n    if [ \"$FUNCTION_COUNT\" -gt 0 ]; then\n        AVG_LINES_PER_FUNC=$((LOC / FUNCTION_COUNT))\n        echo \"  ‚Ä¢ Functions: $FUNCTION_COUNT (avg ~$AVG_LINES_PER_FUNC lines each)\"\n        \n        if [ \"$AVG_LINES_PER_FUNC\" -gt 20 ]; then\n            echo \"  ‚Ä¢ üí° Consider breaking down large functions\"\n        fi\n    fi\n    \n    echo \"\"\n    echo \"üí° Python Code Quality Tips:\"\n    echo \"  ‚Ä¢ Follow PEP 8 style guidelines\"\n    echo \"  ‚Ä¢ Use meaningful variable and function names\"\n    echo \"  ‚Ä¢ Add docstrings to functions and classes\"\n    echo \"  ‚Ä¢ Keep functions small and focused\"\n    echo \"  ‚Ä¢ Use type hints for better code clarity\"\n    \n    echo \"\"\n    echo \"üéØ Code quality analysis complete!\"\n    \nelse\n    echo \"‚ÑπÔ∏è File is not a Python file: $FILE_PATH\"\nfi\n\nexit 0"
  },
  "source": "community"
}
