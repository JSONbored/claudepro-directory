{
  "slug": "performance-impact-monitor",
  "description": "Monitors and alerts on performance-impacting changes in real-time",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-09-19",
  "tags": [
    "performance",
    "monitoring",
    "notification",
    "profiling",
    "alerts"
  ],
  "hookType": "Notification",
  "features": [
    "Real-time performance anti-pattern detection and alerting",
    "Bundle size impact analysis with threshold monitoring",
    "Complex algorithm and nested loop detection",
    "Memory leak pattern identification and warnings",
    "Database query performance impact assessment",
    "Asset optimization recommendations and size tracking",
    "Render blocking resource detection for web applications",
    "Performance regression risk scoring and prioritization"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "notification": {
          "script": "./.claude/hooks/performance-impact-monitor.sh"
        }
      }
    },
    "scriptContent": "#!/usr/bin/env bash\n\n# Performance Impact Monitor Hook\n# Monitors for performance-impacting changes in real-time\n\necho \"⚡ Performance Impact Monitor\" >&2\n\n# Initialize performance monitoring\nPERF_WARNINGS=0\nPERF_ERRORS=0\nPERF_INFO=0\nFILE_SIZE=0\nLINE_COUNT=0\n\n# Performance thresholds (configurable)\nLARGE_FILE_THRESHOLD=100000    # 100KB\nMASSIVE_FILE_THRESHOLD=500000  # 500KB\nLARGE_FUNCTION_LINES=50\nCOMPLEX_CYCLOMATIC=10\nLONG_TIMER_MS=5000\n\n# Function to report performance impacts\nreport_performance() {\n  local level=\"$1\"\n  local message=\"$2\"\n  local suggestion=\"$3\"\n  \n  case \"$level\" in\n    \"ERROR\")\n      echo \"🚨 CRITICAL PERFORMANCE IMPACT: $message\" >&2\n      [ -n \"$suggestion\" ] && echo \"   💡 Suggestion: $suggestion\" >&2\n      PERF_ERRORS=$((PERF_ERRORS + 1))\n      ;;\n    \"WARNING\")\n      echo \"⚠️ PERFORMANCE WARNING: $message\" >&2\n      [ -n \"$suggestion\" ] && echo \"   💡 Suggestion: $suggestion\" >&2\n      PERF_WARNINGS=$((PERF_WARNINGS + 1))\n      ;;\n    \"INFO\")\n      echo \"ℹ️ PERFORMANCE INFO: $message\" >&2\n      [ -n \"$suggestion\" ] && echo \"   💡 Tip: $suggestion\" >&2\n      PERF_INFO=$((PERF_INFO + 1))\n      ;;\n  esac\n}\n\n# Get environment variables (simulated Claude tool context)\nTOOL_NAME=\"${CLAUDE_TOOL_NAME:-unknown}\"\nFILE_PATH=\"${CLAUDE_TOOL_FILE_PATH:-}\"\n\n# If no file path provided, try to get from stdin input\nif [ -z \"$FILE_PATH\" ]; then\n  # Try to read tool input from stdin (for newer hook format)\n  INPUT=$(cat)\n  TOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name // \"unknown\"' 2>/dev/null || echo \"unknown\")\n  FILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"' 2>/dev/null || echo \"\")\nfi\n\n# Skip if no file path available\nif [ -z \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\n# Skip if file doesn't exist or is not readable\nif [ ! -f \"$FILE_PATH\" ] || [ ! -r \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\n# Only monitor for Edit/Write operations\nif [[ \"$TOOL_NAME\" != \"Edit\" ]] && [[ \"$TOOL_NAME\" != \"Write\" ]] && [[ \"$TOOL_NAME\" != \"MultiEdit\" ]]; then\n  exit 0\nfi\n\nFILE_NAME=$(basename \"$FILE_PATH\")\nFILE_EXT=\"${FILE_NAME##*.}\"\n\necho \"   📊 Analyzing performance impact of: $FILE_NAME\" >&2\n\n# 1. File Size Impact Analysis\nFILE_SIZE=$(stat -f%z \"$FILE_PATH\" 2>/dev/null || stat -c%s \"$FILE_PATH\" 2>/dev/null || echo \"0\")\nLINE_COUNT=$(wc -l < \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n\necho \"   📏 File size: $(( FILE_SIZE / 1024 ))KB, Lines: $LINE_COUNT\" >&2\n\n# File size warnings\nif [ \"$FILE_SIZE\" -gt \"$MASSIVE_FILE_THRESHOLD\" ]; then\n  report_performance \"ERROR\" \"Massive file detected ($(( FILE_SIZE / 1024 ))KB)\" \"Consider code splitting or modularization\"\nelif [ \"$FILE_SIZE\" -gt \"$LARGE_FILE_THRESHOLD\" ]; then\n  report_performance \"WARNING\" \"Large file detected ($(( FILE_SIZE / 1024 ))KB)\" \"Monitor bundle size impact and consider optimization\"\nfi\n\n# 2. Language-Specific Performance Analysis\ncase \"$FILE_EXT\" in\n  \"js\"|\"jsx\"|\"ts\"|\"tsx\")\n    echo \"   📦 JavaScript/TypeScript performance analysis...\" >&2\n    \n    # Large function detection\n    LARGE_FUNCTIONS=$(grep -n 'function\\\\|=>' \"$FILE_PATH\" | while read line; do\n      line_num=$(echo \"$line\" | cut -d: -f1)\n      # Simple heuristic: look for next function or end of file\n      next_func=$(tail -n +$((line_num + 1)) \"$FILE_PATH\" | grep -n 'function\\\\|=>' | head -1 | cut -d: -f1)\n      if [ -n \"$next_func\" ]; then\n        func_lines=$((next_func - 1))\n      else\n        func_lines=$(tail -n +$line_num \"$FILE_PATH\" | wc -l)\n      fi\n      \n      if [ \"$func_lines\" -gt \"$LARGE_FUNCTION_LINES\" ]; then\n        echo \"$line_num:$func_lines\"\n      fi\n    done)\n    \n    if [ -n \"$LARGE_FUNCTIONS\" ]; then\n      func_count=$(echo \"$LARGE_FUNCTIONS\" | wc -l)\n      report_performance \"WARNING\" \"$func_count large function(s) detected (>$LARGE_FUNCTION_LINES lines)\" \"Consider breaking down into smaller functions\"\n    fi\n    \n    # Performance anti-patterns\n    if grep -q '\\\\$(' \"$FILE_PATH\" 2>/dev/null; then\n      jquery_count=$(grep -c '\\\\$(' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      if [ \"$jquery_count\" -gt 5 ]; then\n        report_performance \"INFO\" \"Heavy jQuery usage detected ($jquery_count instances)\" \"Consider modern alternatives like vanilla JS or React\"\n      fi\n    fi\n    \n    # Long timers\n    if grep -E '(setTimeout|setInterval).*[0-9]{4,}' \"$FILE_PATH\" 2>/dev/null; then\n      report_performance \"WARNING\" \"Long timer intervals detected (>=${LONG_TIMER_MS}ms)\" \"Verify if long delays are intentional\"\n    fi\n    \n    # Nested loops\n    NESTED_LOOPS=$(grep -E 'for.*{[^}]*for.*{[^}]*for' \"$FILE_PATH\" 2>/dev/null || echo \"\")\n    if [ -n \"$NESTED_LOOPS\" ]; then\n      report_performance \"ERROR\" \"Triple nested loops detected - O(n³) complexity\" \"Consider algorithm optimization or data structure changes\"\n    elif grep -E 'for.*{[^}]*for' \"$FILE_PATH\" 2>/dev/null; then\n      nested_count=$(grep -c 'for.*{[^}]*for' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      if [ \"$nested_count\" -gt 3 ]; then\n        report_performance \"WARNING\" \"Multiple nested loops detected\" \"Review algorithmic complexity\"\n      fi\n    fi\n    \n    # Memory leak patterns\n    if grep -q 'addEventListener.*function' \"$FILE_PATH\" 2>/dev/null; then\n      if ! grep -q 'removeEventListener' \"$FILE_PATH\" 2>/dev/null; then\n        report_performance \"WARNING\" \"Event listeners without cleanup detected\" \"Add removeEventListener calls to prevent memory leaks\"\n      fi\n    fi\n    \n    # Global variable pollution\n    GLOBAL_VARS=$(grep -c '^var\\\\|^let\\\\|^const' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n    if [ \"$GLOBAL_VARS\" -gt 20 ]; then\n      report_performance \"INFO\" \"Many global variables detected ($GLOBAL_VARS)\" \"Consider using modules or namespacing\"\n    fi\n    \n    # Bundle size impact for dependencies\n    if grep -q 'import.*from' \"$FILE_PATH\" 2>/dev/null; then\n      LARGE_IMPORTS=$(grep -E 'import.*(lodash|moment|rxjs)' \"$FILE_PATH\" 2>/dev/null || echo \"\")\n      if [ -n \"$LARGE_IMPORTS\" ]; then\n        report_performance \"INFO\" \"Large library imports detected\" \"Consider tree shaking or lighter alternatives\"\n      fi\n    fi\n    ;;\n    \n  \"py\")\n    echo \"   🐍 Python performance analysis...\" >&2\n    \n    # List comprehensions vs loops\n    if grep -q 'for.*in.*:' \"$FILE_PATH\" 2>/dev/null; then\n      list_comp_count=$(grep -c '\\\\[.*for.*in.*\\\\]' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      loop_count=$(grep -c 'for.*in.*:' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      \n      if [ \"$loop_count\" -gt 0 ] && [ \"$list_comp_count\" -eq 0 ]; then\n        report_performance \"INFO\" \"Consider using list comprehensions for better performance\" \"List comprehensions are often faster than explicit loops\"\n      fi\n    fi\n    \n    # Global imports inside functions\n    if grep -A 5 'def ' \"$FILE_PATH\" | grep -q 'import' 2>/dev/null; then\n      report_performance \"WARNING\" \"Imports inside functions detected\" \"Move imports to module level for better performance\"\n    fi\n    \n    # String concatenation\n    if grep -q '+.*+.*+' \"$FILE_PATH\" 2>/dev/null; then\n      report_performance \"INFO\" \"String concatenation chains detected\" \"Consider using f-strings or join() for better performance\"\n    fi\n    ;;\n    \n  \"sql\")\n    echo \"   🗄️ SQL performance analysis...\" >&2\n    \n    # Missing indexes (basic heuristics)\n    if grep -qi 'where.*=' \"$FILE_PATH\" 2>/dev/null; then\n      if ! grep -qi 'index' \"$FILE_PATH\" 2>/dev/null; then\n        report_performance \"WARNING\" \"WHERE clauses without visible indexes\" \"Ensure proper indexing for query performance\"\n      fi\n    fi\n    \n    # SELECT * usage\n    if grep -qi 'select \\\\*' \"$FILE_PATH\" 2>/dev/null; then\n      select_star_count=$(grep -ci 'select \\\\*' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      report_performance \"WARNING\" \"SELECT * queries detected ($select_star_count)\" \"Specify only needed columns for better performance\"\n    fi\n    \n    # Cartesian products\n    if grep -qi 'from.*,.*where' \"$FILE_PATH\" 2>/dev/null; then\n      if ! grep -qi 'join' \"$FILE_PATH\" 2>/dev/null; then\n        report_performance \"ERROR\" \"Potential cartesian product detected\" \"Use explicit JOINs instead of comma-separated tables\"\n      fi\n    fi\n    ;;\n    \n  \"css\"|\"scss\"|\"sass\")\n    echo \"   🎨 CSS performance analysis...\" >&2\n    \n    # Complex selectors\n    COMPLEX_SELECTORS=$(grep -c '[[:space:]].*[[:space:]].*[[:space:]].*[[:space:]]' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n    if [ \"$COMPLEX_SELECTORS\" -gt 5 ]; then\n      report_performance \"WARNING\" \"Complex CSS selectors detected ($COMPLEX_SELECTORS)\" \"Simplify selectors for better rendering performance\"\n    fi\n    \n    # Expensive properties\n    if grep -q 'box-shadow.*,.*,' \"$FILE_PATH\" 2>/dev/null; then\n      report_performance \"INFO\" \"Complex box-shadow detected\" \"Consider simpler shadow effects for better performance\"\n    fi\n    \n    if grep -q '@import' \"$FILE_PATH\" 2>/dev/null; then\n      import_count=$(grep -c '@import' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      if [ \"$import_count\" -gt 3 ]; then\n        report_performance \"WARNING\" \"Multiple CSS @imports detected ($import_count)\" \"Consider bundling CSS files to reduce HTTP requests\"\n      fi\n    fi\n    ;;\n    \n  \"html\")\n    echo \"   🌐 HTML performance analysis...\" >&2\n    \n    # Inline styles\n    INLINE_STYLES=$(grep -c 'style=' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n    if [ \"$INLINE_STYLES\" -gt 10 ]; then\n      report_performance \"WARNING\" \"Many inline styles detected ($INLINE_STYLES)\" \"Move styles to CSS files for better caching\"\n    fi\n    \n    # Large images without attributes\n    if grep -q '<img' \"$FILE_PATH\" 2>/dev/null; then\n      if ! grep -q 'width=\\\\|height=' \"$FILE_PATH\" 2>/dev/null; then\n        img_count=$(grep -c '<img' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n        report_performance \"INFO\" \"Images without dimensions detected ($img_count)\" \"Add width/height attributes to prevent layout shifts\"\n      fi\n    fi\n    ;;\nesac\n\n# 3. Asset Performance Analysis\necho \"   🖼️ Asset performance analysis...\" >&2\n\n# Check for asset imports/references\nif [[ \"$FILE_EXT\" =~ ^(js|jsx|ts|tsx|css|scss|html)$ ]]; then\n  # Image references\n  IMAGE_REFS=$(grep -oE '\\\\.(jpg|jpeg|png|gif|svg|webp)' \"$FILE_PATH\" 2>/dev/null | wc -l || echo \"0\")\n  if [ \"$IMAGE_REFS\" -gt 10 ]; then\n    report_performance \"INFO\" \"Many image references detected ($IMAGE_REFS)\" \"Consider image optimization and lazy loading\"\n  fi\n  \n  # Large base64 data\n  if grep -q 'data:image' \"$FILE_PATH\" 2>/dev/null; then\n    BASE64_COUNT=$(grep -c 'data:image' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n    report_performance \"WARNING\" \"Base64 encoded images detected ($BASE64_COUNT)\" \"Consider using separate image files for better caching\"\n  fi\nfi\n\n# 4. Database Query Analysis\nif grep -qi 'select\\\\|insert\\\\|update\\\\|delete' \"$FILE_PATH\" 2>/dev/null; then\n  echo \"   🗄️ Database query analysis...\" >&2\n  \n  # N+1 query patterns\n  if grep -q 'for.*in' \"$FILE_PATH\" 2>/dev/null && grep -q 'select\\\\|query' \"$FILE_PATH\" 2>/dev/null; then\n    report_performance \"WARNING\" \"Potential N+1 query pattern detected\" \"Consider using joins or batch queries\"\n  fi\n  \n  # Missing LIMIT clauses\n  if grep -qi 'select.*from' \"$FILE_PATH\" 2>/dev/null; then\n    if ! grep -qi 'limit\\\\|top\\\\|rownum' \"$FILE_PATH\" 2>/dev/null; then\n      unlimited_queries=$(grep -ci 'select.*from' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      if [ \"$unlimited_queries\" -gt 2 ]; then\n        report_performance \"WARNING\" \"Queries without LIMIT detected ($unlimited_queries)\" \"Add LIMIT clauses to prevent large result sets\"\n      fi\n    fi\n  fi\nfi\n\n# 5. Framework-Specific Analysis\nif [[ \"$FILE_EXT\" =~ ^(jsx|tsx)$ ]]; then\n  echo \"   ⚛️ React performance analysis...\" >&2\n  \n  # Component re-render patterns\n  if grep -q 'useState\\\\|useEffect' \"$FILE_PATH\" 2>/dev/null; then\n    if ! grep -q 'useMemo\\\\|useCallback\\\\|React.memo' \"$FILE_PATH\" 2>/dev/null; then\n      hooks_count=$(grep -c 'useState\\\\|useEffect' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n      if [ \"$hooks_count\" -gt 5 ]; then\n        report_performance \"INFO\" \"Many React hooks without memoization\" \"Consider useMemo/useCallback for expensive operations\"\n      fi\n    fi\n  fi\n  \n  # Inline object/function creation in props\n  if grep -q '={{' \"$FILE_PATH\" 2>/dev/null; then\n    inline_objects=$(grep -c '={{' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n    if [ \"$inline_objects\" -gt 5 ]; then\n      report_performance \"WARNING\" \"Many inline objects in JSX props ($inline_objects)\" \"Extract to variables to prevent unnecessary re-renders\"\n    fi\n  fi\nfi\n\n# 6. Generate Performance Impact Summary\necho \"\" >&2\necho \"⚡ Performance Impact Summary\" >&2\necho \"============================\" >&2\necho \"   📄 File: $FILE_NAME ($(( FILE_SIZE / 1024 ))KB)\" >&2\necho \"   🚨 Critical Issues: $PERF_ERRORS\" >&2\necho \"   ⚠️ Warnings: $PERF_WARNINGS\" >&2\necho \"   ℹ️ Optimization Tips: $PERF_INFO\" >&2\n\n# Performance impact assessment\nTOTAL_ISSUES=$((PERF_ERRORS + PERF_WARNINGS))\n\nif [ \"$PERF_ERRORS\" -gt 0 ]; then\n  echo \"   🚨 Impact Level: HIGH - Critical performance issues detected\" >&2\nelif [ \"$PERF_WARNINGS\" -gt 3 ]; then\n  echo \"   ⚠️ Impact Level: MODERATE - Multiple performance concerns\" >&2\nelif [ \"$PERF_WARNINGS\" -gt 0 ]; then\n  echo \"   ⚠️ Impact Level: LOW - Minor performance considerations\" >&2\nelif [ \"$PERF_INFO\" -gt 0 ]; then\n  echo \"   ✅ Impact Level: MINIMAL - Good practices recommended\" >&2\nelse\n  echo \"   🎉 Impact Level: OPTIMAL - No performance issues detected\" >&2\nfi\n\nif [ \"$TOTAL_ISSUES\" -gt 0 ]; then\n  echo \"\" >&2\n  echo \"💡 Performance Optimization Resources:\" >&2\n  echo \"   • Web: Core Web Vitals and Lighthouse audits\" >&2\n  echo \"   • JavaScript: Profiler tools and performance monitoring\" >&2\n  echo \"   • Database: Query optimization and indexing strategies\" >&2\n  echo \"   • Bundle: Code splitting and tree shaking\" >&2\nfi\n\necho \"⚡ Performance impact monitoring complete\" >&2\nexit 0"
  },
  "useCases": [
    "Real-time development feedback with performance impact awareness",
    "Code review automation with performance-focused analysis",
    "Continuous performance monitoring during active development",
    "Team education and awareness about performance best practices",
    "Performance regression prevention with immediate alerts"
  ],
  "source": "community"
}
