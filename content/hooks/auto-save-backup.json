{
  "slug": "auto-save-backup",
  "description": "Automatically creates timestamped backups of files before modification to prevent data loss",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-09-19",
  "tags": ["backup", "safety", "file-management", "data-protection"],
  "hookType": "PreToolUse",
  "features": [
    "Automatic timestamped backups before file modification",
    "Organized backup storage in .backups directory",
    "Filename format: filename_YYYYMMDD_HHMMSS.ext",
    "Support for all file editing operations",
    "Version history maintenance",
    "Silent failure handling to prevent workflow interruption"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "preToolUse": {
          "script": "./.claude/hooks/auto-save-backup.sh",
          "matchers": ["edit", "write", "multiedit"]
        }
      }
    },
    "scriptContent": "#!/usr/bin/env bash\n\n# Read the tool input from stdin\nINPUT=$(cat)\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"')\n\nif [ -z \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\n# Check if file exists before backing up\nif [ -f \"$FILE_PATH\" ]; then\n  echo \"ðŸ’¾ Creating backup for $FILE_PATH...\" >&2\n  \n  # Create backups directory\n  mkdir -p .backups\n  \n  # Generate timestamped backup filename\n  BASENAME=$(basename \"$FILE_PATH\")\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  BACKUP_NAME=\"${BASENAME%.*}_${TIMESTAMP}.${BASENAME##*.}\"\n  \n  # Create backup\n  cp \"$FILE_PATH\" \".backups/$BACKUP_NAME\" 2>/dev/null || true\n  \n  if [ $? -eq 0 ]; then\n    echo \"âœ… Backup created: .backups/$BACKUP_NAME\" >&2\n  else\n    echo \"âš ï¸ Backup failed for $FILE_PATH\" >&2\n  fi\nelse\n  echo \"ðŸ“ Creating new file $FILE_PATH (no backup needed)\" >&2\nfi\n\nexit 0"
  },
  "useCases": [
    "Automatic version control for critical configuration files",
    "Safety net during development and debugging sessions",
    "Recovery from accidental file modifications",
    "Maintaining edit history without git commits",
    "Protection during bulk file operations"
  ],
  "troubleshooting": [
    {
      "issue": "PreToolUse hook runs but backup directory not created",
      "solution": "Verify mkdir permissions in project root. Check disk space: df -h. Ensure script runs with correct CWD: pwd >&2 in hook. Create .backups manually if needed."
    },
    {
      "issue": "Backup created but original file modification fails after",
      "solution": "PreToolUse only creates backup, doesn't block edits. Check subsequent tool execution logs. Verify hook exits with 0 (non-blocking). Review tool output for actual edit errors."
    },
    {
      "issue": "Timestamp collisions when editing same file rapidly",
      "solution": "Add milliseconds to timestamp: date +%Y%m%d_%H%M%S_%N. Or use hash suffix: ${TIMESTAMP}_$(md5sum file | cut -c1-8). Implement collision detection and retry logic."
    },
    {
      "issue": "Hook backs up new files that don't exist yet on Write",
      "solution": "Verify [ -f \"$FILE_PATH\" ] check works correctly. Check TOOL_NAME to distinguish edit vs write: if [[ \"$TOOL_NAME\" == \"edit\" ]]. Skip backup for new file creation."
    },
    {
      "issue": "Backup directory grows unbounded filling disk space",
      "solution": "Add retention policy: find .backups -mtime +30 -delete. Implement backup rotation script. Use git for versioning instead. Add size limit checks before creating backups."
    }
  ],
  "source": "community"
}
