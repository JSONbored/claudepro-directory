{
  "slug": "json-schema-validator",
  "description": "Validates JSON files against their schemas when modified to ensure data integrity",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-09-19",
  "tags": ["json", "schema", "validation", "data-integrity", "api"],
  "hookType": "PostToolUse",
  "features": [
    "Comprehensive JSON schema validation using AJV and multiple validators",
    "Intelligent schema discovery with multiple search strategies",
    "JSON syntax validation and format verification",
    "Schema version compatibility checking and migration guidance",
    "Custom validation rule support and error reporting",
    "JSON-LD and specialized format validation",
    "Performance optimization for large JSON files",
    "Detailed error location and suggestion reporting"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "postToolUse": {
          "script": "./.claude/hooks/json-schema-validator.sh",
          "matchers": ["write", "edit"]
        }
      }
    },
    "scriptContent": "#!/usr/bin/env bash\n\n# Read the tool input from stdin\nINPUT=$(cat)\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"')\n\nif [ -z \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\n# Check if this is a JSON file (exclude schema files)\nif [[ \"$FILE_PATH\" == *.json ]] && [[ \"$FILE_PATH\" != *.schema.json ]] && [[ \"$FILE_PATH\" != *schema*.json ]]; then\n  echo \"📋 JSON Schema Validation for: $(basename \"$FILE_PATH\")\" >&2\n  \n  # Initialize validation counters\n  ERRORS=0\n  WARNINGS=0\n  VALIDATIONS_PASSED=0\n  SCHEMA_FOUND=false\n  \n  # Function to report validation results\n  report_validation() {\n    local level=\"$1\"\n    local message=\"$2\"\n    \n    case \"$level\" in\n      \"ERROR\")\n        echo \"❌ ERROR: $message\" >&2\n        ERRORS=$((ERRORS + 1))\n        ;;\n      \"WARNING\")\n        echo \"⚠️ WARNING: $message\" >&2\n        WARNINGS=$((WARNINGS + 1))\n        ;;\n      \"PASS\")\n        echo \"✅ PASS: $message\" >&2\n        VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))\n        ;;\n      \"INFO\")\n        echo \"ℹ️ INFO: $message\" >&2\n        ;;\n    esac\n  }\n  \n  # Check if file exists and is readable\n  if [ ! -f \"$FILE_PATH\" ]; then\n    report_validation \"ERROR\" \"JSON file not found: $FILE_PATH\"\n    exit 1\n  fi\n  \n  if [ ! -r \"$FILE_PATH\" ]; then\n    report_validation \"ERROR\" \"JSON file is not readable: $FILE_PATH\"\n    exit 1\n  fi\n  \n  # Get file information\n  FILE_NAME=\"$(basename \"$FILE_PATH\")\"\n  FILE_DIR=\"$(dirname \"$FILE_PATH\")\"\n  JSON_NAME=\"${FILE_NAME%.json}\"\n  FILE_SIZE=$(wc -c < \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n  \n  echo \"📊 JSON file: $FILE_NAME ($(( FILE_SIZE / 1024 ))KB)\" >&2\n  \n  # 1. Basic JSON Syntax Validation\n  echo \"🔍 Checking JSON syntax...\" >&2\n  \n  if command -v jq &> /dev/null; then\n    if jq empty \"$FILE_PATH\" 2>/dev/null; then\n      report_validation \"PASS\" \"Valid JSON syntax\"\n      \n      # Get JSON structure info\n      JSON_TYPE=$(jq -r 'type' \"$FILE_PATH\" 2>/dev/null || echo \"unknown\")\n      echo \"   📊 JSON type: $JSON_TYPE\" >&2\n      \n      if [ \"$JSON_TYPE\" = \"object\" ]; then\n        KEY_COUNT=$(jq -r 'keys | length' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n        echo \"   🔑 Object keys: $KEY_COUNT\" >&2\n      elif [ \"$JSON_TYPE\" = \"array\" ]; then\n        ARRAY_LENGTH=$(jq -r 'length' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n        echo \"   📋 Array length: $ARRAY_LENGTH\" >&2\n      fi\n      \n    else\n      report_validation \"ERROR\" \"Invalid JSON syntax - file cannot be parsed\"\n      echo \"   📝 JSON parsing error details:\" >&2\n      jq empty \"$FILE_PATH\" 2>&1 | head -3 | while read line; do\n        echo \"     $line\" >&2\n      done\n      exit 1\n    fi\n  else\n    # Fallback validation using Python\n    if command -v python3 &> /dev/null; then\n      if python3 -c \"import json; json.load(open('$FILE_PATH'))\" 2>/dev/null; then\n        report_validation \"PASS\" \"Valid JSON syntax (Python validator)\"\n      else\n        report_validation \"ERROR\" \"Invalid JSON syntax detected\"\n        exit 1\n      fi\n    else\n      report_validation \"WARNING\" \"No JSON validators available (jq or python3)\"\n    fi\n  fi\n  \n  # 2. Schema Discovery\n  echo \"🔍 Searching for JSON schema...\" >&2\n  \n  SCHEMA_CANDIDATES=()\n  \n  # Strategy 1: Same directory with .schema.json suffix\n  SCHEMA_CANDIDATES+=(\"$FILE_DIR/${JSON_NAME}.schema.json\")\n  \n  # Strategy 2: Same directory with schema/ subdirectory\n  SCHEMA_CANDIDATES+=(\"$FILE_DIR/schema/${JSON_NAME}.schema.json\")\n  SCHEMA_CANDIDATES+=(\"$FILE_DIR/schemas/${JSON_NAME}.schema.json\")\n  \n  # Strategy 3: Root-level schema directories\n  SCHEMA_CANDIDATES+=(\"./schema/${JSON_NAME}.schema.json\")\n  SCHEMA_CANDIDATES+=(\"./schemas/${JSON_NAME}.schema.json\")\n  SCHEMA_CANDIDATES+=(\"./json-schemas/${JSON_NAME}.schema.json\")\n  \n  # Strategy 4: Common schema file names\n  SCHEMA_CANDIDATES+=(\"$FILE_DIR/${JSON_NAME}-schema.json\")\n  SCHEMA_CANDIDATES+=(\"$FILE_DIR/schema.json\")\n  \n  # Strategy 5: Look for $schema property in JSON\n  if command -v jq &> /dev/null; then\n    EMBEDDED_SCHEMA=$(jq -r '.\"$schema\" // empty' \"$FILE_PATH\" 2>/dev/null)\n    if [ -n \"$EMBEDDED_SCHEMA\" ]; then\n      echo \"   🔗 Found embedded schema reference: $EMBEDDED_SCHEMA\" >&2\n      # If it's a file path, add to candidates\n      if [[ \"$EMBEDDED_SCHEMA\" == ./* ]] || [[ \"$EMBEDDED_SCHEMA\" == /* ]]; then\n        SCHEMA_CANDIDATES+=(\"$EMBEDDED_SCHEMA\")\n      fi\n    fi\n  fi\n  \n  # Find the first existing schema file\n  SCHEMA_FILE=\"\"\n  for candidate in \"${SCHEMA_CANDIDATES[@]}\"; do\n    if [ -f \"$candidate\" ]; then\n      SCHEMA_FILE=\"$candidate\"\n      echo \"   📁 Schema found: $candidate\" >&2\n      SCHEMA_FOUND=true\n      break\n    fi\n  done\n  \n  if [ -z \"$SCHEMA_FILE\" ]; then\n    echo \"   ⚠️ No schema file found. Searched locations:\" >&2\n    for candidate in \"${SCHEMA_CANDIDATES[@]}\"; do\n      echo \"     - $candidate\" >&2\n    done\n    report_validation \"INFO\" \"No schema available - performing syntax-only validation\"\n  fi\n  \n  # 3. Schema Validation (if schema found)\n  if [ \"$SCHEMA_FOUND\" = true ] && [ -f \"$SCHEMA_FILE\" ]; then\n    echo \"📋 Validating against schema...\" >&2\n    \n    # Check if schema file is valid JSON\n    if ! jq empty \"$SCHEMA_FILE\" 2>/dev/null; then\n      report_validation \"ERROR\" \"Schema file is not valid JSON: $SCHEMA_FILE\"\n    else\n      echo \"   ✅ Schema file is valid JSON\" >&2\n      \n      # Get schema information\n      SCHEMA_VERSION=$(jq -r '.\"$schema\" // \"draft-07\"' \"$SCHEMA_FILE\" 2>/dev/null)\n      SCHEMA_TITLE=$(jq -r '.title // \"Untitled\"' \"$SCHEMA_FILE\" 2>/dev/null)\n      echo \"   📊 Schema: $SCHEMA_TITLE (version: $SCHEMA_VERSION)\" >&2\n      \n      # Try AJV validation first (most comprehensive)\n      if command -v npx &> /dev/null; then\n        echo \"   🔍 Running AJV validation...\" >&2\n        \n        AJV_OUTPUT_FILE=\"/tmp/ajv_output_$$\"\n        if npx ajv validate -s \"$SCHEMA_FILE\" -d \"$FILE_PATH\" > \"$AJV_OUTPUT_FILE\" 2>&1; then\n          report_validation \"PASS\" \"AJV schema validation successful\"\n        else\n          report_validation \"ERROR\" \"AJV schema validation failed\"\n          echo \"   📝 Validation errors:\" >&2\n          head -10 \"$AJV_OUTPUT_FILE\" | while read line; do\n            echo \"     $line\" >&2\n          done\n        fi\n        rm -f \"$AJV_OUTPUT_FILE\"\n        \n      # Fallback to basic schema checks\n      else\n        echo \"   ⚠️ AJV not available, performing basic schema checks...\" >&2\n        \n        # Check if required properties exist (simplified)\n        if command -v jq &> /dev/null; then\n          REQUIRED_PROPS=$(jq -r '.required[]? // empty' \"$SCHEMA_FILE\" 2>/dev/null)\n          if [ -n \"$REQUIRED_PROPS\" ]; then\n            echo \"   🔑 Checking required properties...\" >&2\n            MISSING_PROPS=0\n            \n            while read -r prop; do\n              if [ -n \"$prop\" ]; then\n                if jq -e \".\\\"$prop\\\"\" \"$FILE_PATH\" > /dev/null 2>&1; then\n                  echo \"     ✅ Required property exists: $prop\" >&2\n                else\n                  echo \"     ❌ Missing required property: $prop\" >&2\n                  MISSING_PROPS=$((MISSING_PROPS + 1))\n                fi\n              fi\n            done <<< \"$REQUIRED_PROPS\"\n            \n            if [ \"$MISSING_PROPS\" -eq 0 ]; then\n              report_validation \"PASS\" \"All required properties present\"\n            else\n              report_validation \"ERROR\" \"$MISSING_PROPS required properties missing\"\n            fi\n          else\n            echo \"   ℹ️ No required properties defined in schema\" >&2\n          fi\n        fi\n      fi\n    fi\n  fi\n  \n  # 4. JSON Format-Specific Validation\n  echo \"🔍 Checking JSON format specifics...\" >&2\n  \n  # Check for common JSON formats\n  if command -v jq &> /dev/null; then\n    # Check for package.json format\n    if [[ \"$FILE_NAME\" == \"package.json\" ]]; then\n      echo \"   📦 Detected package.json - checking NPM format...\" >&2\n      \n      if jq -e '.name' \"$FILE_PATH\" > /dev/null 2>&1; then\n        PKG_NAME=$(jq -r '.name' \"$FILE_PATH\" 2>/dev/null)\n        PKG_VERSION=$(jq -r '.version // \"no version\"' \"$FILE_PATH\" 2>/dev/null)\n        echo \"     📋 Package: $PKG_NAME@$PKG_VERSION\" >&2\n        report_validation \"PASS\" \"Valid package.json structure\"\n      else\n        report_validation \"WARNING\" \"package.json missing required 'name' field\"\n      fi\n      \n    # Check for tsconfig.json format\n    elif [[ \"$FILE_NAME\" == \"tsconfig.json\" ]] || [[ \"$FILE_NAME\" == \"jsconfig.json\" ]]; then\n      echo \"   🔧 Detected TypeScript/JavaScript config - checking format...\" >&2\n      \n      if jq -e '.compilerOptions // .include // .exclude' \"$FILE_PATH\" > /dev/null 2>&1; then\n        report_validation \"PASS\" \"Valid TypeScript/JavaScript config structure\"\n      else\n        report_validation \"WARNING\" \"Config file may be incomplete\"\n      fi\n      \n    # Check for JSON-LD format\n    elif jq -e '.\"@context\"' \"$FILE_PATH\" > /dev/null 2>&1; then\n      echo \"   🔗 Detected JSON-LD format\" >&2\n      CONTEXT_URL=$(jq -r '.\"@context\"' \"$FILE_PATH\" 2>/dev/null)\n      echo \"     🌐 Context: $CONTEXT_URL\" >&2\n      report_validation \"PASS\" \"JSON-LD structure detected\"\n      \n    # Check for GeoJSON format\n    elif jq -e '.type' \"$FILE_PATH\" 2>/dev/null | grep -q '\"Feature\"\\|\"FeatureCollection\"\\|\"Point\"\\|\"LineString\"'; then\n      echo \"   🗺️ Detected GeoJSON format\" >&2\n      GEOM_TYPE=$(jq -r '.type' \"$FILE_PATH\" 2>/dev/null)\n      echo \"     📍 Geometry type: $GEOM_TYPE\" >&2\n      report_validation \"PASS\" \"GeoJSON structure detected\"\n    fi\n  fi\n  \n  # 5. JSON Security and Best Practices\n  echo \"🔒 Security and best practices check...\" >&2\n  \n  # Check file size (warn for very large files)\n  if [ \"$FILE_SIZE\" -gt 10485760 ]; then  # 10MB\n    report_validation \"WARNING\" \"Large JSON file ($(( FILE_SIZE / 1048576 ))MB) - consider optimization\"\n  fi\n  \n  # Check for potential security issues\n  if command -v jq &> /dev/null; then\n    # Check for potentially sensitive data patterns\n    SENSITIVE_PATTERNS=(\"password\" \"secret\" \"token\" \"key\" \"credential\")\n    SENSITIVE_FOUND=false\n    \n    for pattern in \"${SENSITIVE_PATTERNS[@]}\"; do\n      if jq -r 'paths(scalars) as $p | $p | join(\".\")' \"$FILE_PATH\" 2>/dev/null | grep -i \"$pattern\" >/dev/null; then\n        SENSITIVE_FOUND=true\n        break\n      fi\n    done\n    \n    if [ \"$SENSITIVE_FOUND\" = true ]; then\n      report_validation \"WARNING\" \"Potentially sensitive data detected in JSON structure\"\n    fi\n    \n    # Check for excessive nesting depth\n    MAX_DEPTH=$(jq '[paths | length] | max' \"$FILE_PATH\" 2>/dev/null || echo \"0\")\n    if [ \"$MAX_DEPTH\" -gt 10 ]; then\n      report_validation \"WARNING\" \"Deep nesting detected ($MAX_DEPTH levels) - consider flattening\"\n    fi\n  fi\n  \n  # 6. Generate Validation Summary\n  echo \"\" >&2\n  echo \"📋 JSON Schema Validation Summary:\" >&2\n  echo \"=================================\" >&2\n  echo \"   📄 File: $FILE_NAME\" >&2\n  echo \"   📏 Size: $(( FILE_SIZE / 1024 ))KB\" >&2\n  echo \"   📋 Schema found: $SCHEMA_FOUND\" >&2\n  [ \"$SCHEMA_FOUND\" = true ] && echo \"   📁 Schema file: $(basename \"$SCHEMA_FILE\")\" >&2\n  echo \"   ✅ Validations passed: $VALIDATIONS_PASSED\" >&2\n  echo \"   ⚠️ Warnings: $WARNINGS\" >&2\n  echo \"   ❌ Errors: $ERRORS\" >&2\n  \n  if [ \"$ERRORS\" -eq 0 ]; then\n    if [ \"$WARNINGS\" -eq 0 ]; then\n      echo \"   🎉 Status: EXCELLENT - JSON is valid and well-formed\" >&2\n    else\n      echo \"   ✅ Status: GOOD - JSON is valid with minor recommendations\" >&2\n    fi\n  else\n    echo \"   ❌ Status: ERRORS - JSON has validation issues that must be fixed\" >&2\n  fi\n  \n  echo \"\" >&2\n  echo \"💡 JSON Schema Best Practices:\" >&2\n  echo \"   • Use descriptive schema titles and descriptions\" >&2\n  echo \"   • Define required properties clearly\" >&2\n  echo \"   • Validate data types and formats\" >&2\n  echo \"   • Keep schemas versioned and documented\" >&2\n  echo \"   • Use meaningful property names\" >&2\n  echo \"   • Avoid excessive nesting\" >&2\n  \n  # Exit with error if there are critical validation issues\n  if [ \"$ERRORS\" -gt 0 ]; then\n    echo \"⚠️ JSON validation completed with errors\" >&2\n    exit 1\n  fi\n  \nelse\n  # Not a JSON file or is a schema file, exit silently\n  exit 0\nfi\n\nexit 0"
  },
  "useCases": [
    "API development with automated JSON payload validation",
    "Configuration file validation and integrity checking",
    "Data pipeline quality assurance with schema enforcement",
    "CI/CD integration with automated JSON validation",
    "Multi-environment configuration consistency validation"
  ],
  "source": "community"
}
