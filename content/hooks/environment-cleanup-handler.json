{
  "slug": "environment-cleanup-handler",
  "description": "Cleans up temporary files, caches, and resources when Claude session ends",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-09-19",
  "tags": ["cleanup", "stop-hook", "maintenance", "resources", "optimization"],
  "hookType": "Stop",
  "features": [
    "Automatic temporary file cleanup (*.tmp, *.log, .DS_Store, Thumbs.db)",
    "NPM cache verification and cleanup",
    "Python bytecode and __pycache__ directory removal",
    "Development build artifacts cleanup",
    "Disk space usage reporting and optimization",
    "Multi-platform support (macOS, Linux, Windows)",
    "Safe cleanup with error handling and logging",
    "Cache invalidation for faster future builds"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "stop": {
          "script": "./.claude/hooks/environment-cleanup-handler.sh"
        }
      }
    },
    "scriptContent": "#!/usr/bin/env bash\n\necho \"ðŸ§¹ Starting environment cleanup...\" >&2\n\n# Initialize cleanup counters\nFILES_REMOVED=0\nSPACE_FREED=0\nERRORS=0\n\n# Function to safely remove files and count them\nsafe_remove() {\n  local pattern=\"$1\"\n  local description=\"$2\"\n  \n  echo \"ðŸ“ Cleaning $description...\" >&2\n  \n  if [ \"$pattern\" = \"__pycache__\" ]; then\n    # Special handling for __pycache__ directories\n    FOUND=$(find . -type d -name \"__pycache__\" 2>/dev/null | wc -l | xargs)\n    if [ \"$FOUND\" -gt 0 ]; then\n      find . -type d -name \"__pycache__\" -exec rm -rf {} + 2>/dev/null && echo \"  âœ… Removed $FOUND __pycache__ directories\" >&2\n      FILES_REMOVED=$((FILES_REMOVED + FOUND))\n    else\n      echo \"  â„¹ï¸ No __pycache__ directories found\" >&2\n    fi\n  else\n    # Handle file patterns\n    FOUND=$(find . -name \"$pattern\" 2>/dev/null | wc -l | xargs)\n    if [ \"$FOUND\" -gt 0 ]; then\n      find . -name \"$pattern\" -delete 2>/dev/null && echo \"  âœ… Removed $FOUND $description files\" >&2\n      FILES_REMOVED=$((FILES_REMOVED + FOUND))\n    else\n      echo \"  â„¹ï¸ No $description files found\" >&2\n    fi\n  fi\n}\n\n# Clean temporary files\nsafe_remove \"*.tmp\" \"temporary\"\nsafe_remove \"*.log\" \"log\"\nsafe_remove \"*.bak\" \"backup\"\nsafe_remove \"*~\" \"editor backup\"\n\n# Clean system-specific files\ncase \"$(uname)\" in\n  Darwin)\n    safe_remove \".DS_Store\" \"macOS metadata\"\n    safe_remove \"._*\" \"macOS resource fork\"\n    ;;\n  CYGWIN*|MINGW*|MSYS*)\n    safe_remove \"Thumbs.db\" \"Windows thumbnail cache\"\n    safe_remove \"Desktop.ini\" \"Windows desktop config\"\n    ;;\n  Linux)\n    safe_remove \".directory\" \"KDE directory config\"\n    ;;\nesac\n\n# Clean Python cache files\necho \"ðŸ Cleaning Python artifacts...\" >&2\nsafe_remove \"*.pyc\" \"Python bytecode\"\nsafe_remove \"*.pyo\" \"Python optimized bytecode\"\nsafe_remove \"__pycache__\" \"Python cache directories\"\n\n# Clean Node.js related files\nif [ -f \"package.json\" ]; then\n  echo \"ðŸŸ¢ Node.js project detected - cleaning caches...\" >&2\n  \n  # Clean npm cache\n  if command -v npm &> /dev/null; then\n    echo \"  ðŸ—‘ï¸ Verifying npm cache...\" >&2\n    if npm cache verify 2>/dev/null; then\n      echo \"  âœ… npm cache verified and cleaned\" >&2\n    else\n      echo \"  âš ï¸ npm cache verification failed\" >&2\n      ERRORS=$((ERRORS + 1))\n    fi\n  fi\n  \n  # Clean node_modules/.cache if it exists\n  if [ -d \"node_modules/.cache\" ]; then\n    CACHE_SIZE=$(du -sh node_modules/.cache 2>/dev/null | cut -f1 || echo \"unknown\")\n    rm -rf node_modules/.cache 2>/dev/null && echo \"  âœ… Removed node_modules/.cache ($CACHE_SIZE)\" >&2\n  fi\nfi\n\n# Clean build artifacts\necho \"ðŸ”§ Cleaning build artifacts...\" >&2\nsafe_remove \"*.o\" \"object files\"\nsafe_remove \"*.obj\" \"Windows object files\"\nsafe_remove \"*.so\" \"shared object files\"\nsafe_remove \"*.dll\" \"Windows library files\"\nsafe_remove \"*.dylib\" \"macOS dynamic libraries\"\n\n# Clean IDE and editor files\necho \"ðŸ’» Cleaning IDE artifacts...\" >&2\nsafe_remove \".vscode/settings.json.bak\" \"VS Code backup settings\"\nif [ -d \".vscode\" ]; then\n  find .vscode -name \"*.log\" -delete 2>/dev/null || true\nfi\n\n# Clean test artifacts\necho \"ðŸ§ª Cleaning test artifacts...\" >&2\nsafe_remove \"coverage.xml\" \"coverage report\"\nsafe_remove \".coverage\" \"Python coverage data\"\nif [ -d \"coverage\" ]; then\n  rm -rf coverage 2>/dev/null && echo \"  âœ… Removed coverage directory\" >&2\nfi\nif [ -d \".nyc_output\" ]; then\n  rm -rf .nyc_output 2>/dev/null && echo \"  âœ… Removed .nyc_output directory\" >&2\nfi\n\n# Clean Docker artifacts if Docker is available\nif command -v docker &> /dev/null && docker info &> /dev/null 2>&1; then\n  echo \"ðŸ³ Docker detected - cleaning unused resources...\" >&2\n  \n  # Clean dangling images\n  DANGLING_IMAGES=$(docker images -f \"dangling=true\" -q 2>/dev/null | wc -l | xargs)\n  if [ \"$DANGLING_IMAGES\" -gt 0 ]; then\n    docker image prune -f &> /dev/null && echo \"  âœ… Removed $DANGLING_IMAGES dangling Docker images\" >&2\n  else\n    echo \"  â„¹ï¸ No dangling Docker images found\" >&2\n  fi\nfi\n\n# Calculate disk space if possible\necho \"ðŸ’¾ Calculating disk space usage...\" >&2\nif command -v du &> /dev/null; then\n  # Check cache directories\n  for cache_dir in ~/.npm ~/.cache ~/.cargo/registry; do\n    if [ -d \"$cache_dir\" ]; then\n      CACHE_SIZE=$(du -sh \"$cache_dir\" 2>/dev/null | cut -f1 || echo \"unknown\")\n      echo \"  ðŸ“Š $cache_dir: $CACHE_SIZE\" >&2\n    fi\n  done\nfi\n\n# Report cleanup summary\necho \"\" >&2\necho \"ðŸ“‹ Cleanup Summary:\" >&2\necho \"  ðŸ—‘ï¸ Files/directories removed: $FILES_REMOVED\" >&2\necho \"  âš ï¸ Errors encountered: $ERRORS\" >&2\n\nif [ \"$ERRORS\" -eq 0 ]; then\n  echo \"âœ… Environment cleanup completed successfully\" >&2\nelse\n  echo \"âš ï¸ Environment cleanup completed with $ERRORS errors\" >&2\nfi\n\necho \"\" >&2\necho \"ðŸ’¡ Cleanup Tips:\" >&2\necho \"   â€¢ Run 'docker system prune' for more aggressive Docker cleanup\" >&2\necho \"   â€¢ Use 'npm cache clean --force' for complete npm cache reset\" >&2\necho \"   â€¢ Consider 'pip cache purge' for Python package cache cleanup\" >&2\n\nexit 0"
  },
  "useCases": [
    "Automated development environment maintenance",
    "Post-session cleanup for CI/CD pipelines",
    "Disk space optimization and management",
    "Multi-language project artifact cleanup",
    "Docker container development environment cleanup"
  ],
  "faq": [
    {
      "issue": "Stop hook doesn't execute when Claude terminates unexpectedly",
      "solution": "Stop hooks only run on graceful shutdown. For crash scenarios, use OS-level cleanup via trap signals or systemd service cleanup. Add trap 'cleanup_function' EXIT SIGTERM SIGINT to shell sessions for broader coverage."
    },
    {
      "issue": "Docker cleanup fails with permission denied on daemon socket",
      "solution": "Script checks 'docker info' but may lack permissions. Ensure user in docker group: sudo usermod -aG docker $USER or skip docker cleanup gracefully: docker image prune -f 2>/dev/null || echo 'Skipping docker cleanup'."
    },
    {
      "issue": "NPM cache verify hangs indefinitely blocking hook completion",
      "solution": "Network issues can stall npm operations. Add timeout: timeout 10s npm cache verify or use npm cache verify --offline to avoid network calls. Set NPM_CONFIG_CACHE to control cache directory location."
    },
    {
      "issue": "Find commands fail with 'too many arguments' on large directories",
      "solution": "Large directory trees exceed ARG_MAX limits. Replace find ... -delete with: find . -name '*.tmp' -print0 | xargs -0 rm -f to handle arguments in batches safely using null delimiter for paths with spaces."
    },
    {
      "issue": "Cleanup removes legitimate .log files needed for debugging sessions",
      "solution": "Aggressive *.log deletion can remove important logs. Add time-based filtering: find . -name '*.log' -mtime +7 -delete to only remove week-old logs, or exclude specific directories: -not -path './important-logs/*'."
    },
    {
      "issue": "Stop hook timing varies causing incomplete cleanup on fast exits",
      "solution": "Stop hooks trigger on shutdown but process may terminate mid-execution. Use background jobs: cleanup_task & with wait to ensure completion, or add set -e and trap 'cleanup_complete_marker' EXIT for verification logging."
    },
    {
      "issue": "Safe_remove function wc output includes whitespace breaking counts",
      "solution": "Command 'wc -l | xargs' used to trim whitespace but may fail on BSD vs GNU. Use: wc -l | tr -d ' ' or awk '{print $1}' for reliable numeric extraction across platforms without xargs dependency."
    },
    {
      "issue": "Du command for cache size calculation hangs on network mounts",
      "solution": "Script checks ~/.npm and other user dirs which may be on slow filesystems. Add timeout: timeout 5s du -sh \"$cache_dir\" or skip network paths: df \"$cache_dir\" | grep -q nfs && continue to avoid stalling."
    },
    {
      "issue": "Find exec with rm -rf on __pycache__ fails to increment counter",
      "solution": "Using -exec rm -rf {} + deletes directories but count happens before deletion. Store paths first: DIRS=$(find . -type d -name '__pycache__') then loop: echo \"$DIRS\" | while read d; do rm -rf \"$d\"; done for accurate counting."
    },
    {
      "issue": "Stderr redirection to >&2 lost when hook output captured by CI/CD",
      "solution": "Stop hooks often run in contexts where stderr is redirected. Ensure both streams visible: echo messages to stdout and stderr: msg() { echo \"$1\" | tee /dev/stderr; } or use explicit log file: >>/tmp/cleanup.log."
    }
  ],
  "source": "community"
}
