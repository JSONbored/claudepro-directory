{
  "slug": "documentation-coverage-checker",
  "description": "Automated documentation coverage analysis with missing docstring detection, API documentation validation, and completeness scoring",
  "category": "hooks",
  "author": "JSONbored",
  "dateAdded": "2025-10-19",
  "tags": ["documentation", "code-quality", "analysis", "automation", "best-practices"],
  "hookType": "PostToolUse",
  "features": [
    "Automatic detection of undocumented functions and classes",
    "JSDoc, TSDoc, and Python docstring validation",
    "API endpoint documentation completeness checking",
    "Documentation coverage metrics and reporting",
    "README and changelog freshness validation",
    "Support for multiple languages and documentation formats"
  ],
  "configuration": {
    "hookConfig": {
      "hooks": {
        "postToolUse": {
          "script": "./.claude/hooks/documentation-coverage-checker.sh",
          "matchers": ["write", "edit"]
        }
      }
    },
    "scriptContent": "#!/usr/bin/env bash\n\n# Read the tool input from stdin\nINPUT=$(cat)\nTOOL_NAME=$(echo \"$INPUT\" | jq -r '.tool_name')\nFILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // .tool_input.path // \"\"')\n\nif [ -z \"$FILE_PATH\" ]; then\n  exit 0\nfi\n\n# Configuration\nREPORT_FILE=\".claude/reports/docs-coverage-$(date +%Y%m%d).txt\"\nMIN_COVERAGE=${DOC_COVERAGE_THRESHOLD:-70}\n\nmkdir -p \"$(dirname \"$REPORT_FILE\")\"\n\n# Function to check if file needs documentation review\nneeds_doc_check() {\n  local file=$1\n  \n  case \"$file\" in\n    *.js|*.jsx|*.ts|*.tsx|*.py|*.go|*.rs|*.java|*.rb)\n      return 0\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n}\n\n# Function to check JavaScript/TypeScript documentation\ncheck_js_ts_docs() {\n  local file=$1\n  \n  echo \"ðŸ“ Checking JS/TS documentation: $file\" >&2\n  \n  # Count functions\n  local total_functions=$(grep -cE \"^\\s*(export\\s+)?(async\\s+)?function\\s+\\w+|^\\s*const\\s+\\w+\\s*=\\s*(async\\s+)?\\(|^\\s*\\w+\\s*\\(.*\\)\\s*\\{\" \"$file\" 2>/dev/null || echo \"0\")\n  \n  # Count documented functions (with JSDoc /** */)\n  local documented=$(grep -B1 -cE \"^\\s*\\/\\*\\*\" \"$file\" 2>/dev/null || echo \"0\")\n  \n  if [ \"$total_functions\" -gt 0 ]; then\n    local coverage=$((documented * 100 / total_functions))\n    \n    echo \"\" >> \"$REPORT_FILE\"\n    echo \"JavaScript/TypeScript Documentation - $file\" >> \"$REPORT_FILE\"\n    echo \"Total functions: $total_functions\" >> \"$REPORT_FILE\"\n    echo \"Documented: $documented\" >> \"$REPORT_FILE\"\n    echo \"Coverage: ${coverage}%\" >> \"$REPORT_FILE\"\n    \n    if [ \"$coverage\" -lt \"$MIN_COVERAGE\" ]; then\n      echo \"âš ï¸ Documentation coverage ${coverage}% below threshold ${MIN_COVERAGE}%\" >&2\n      echo \"ðŸ’¡ Add JSDoc comments to exported functions\" >&2\n    else\n      echo \"âœ… Documentation coverage: ${coverage}%\" >&2\n    fi\n  fi\n  \n  # Check for exported items without docs\n  if grep -E \"^export (class|function|const|interface|type)\" \"$file\" >/dev/null 2>&1; then\n    echo \"ðŸ“¦ Exported items detected - ensure public API is documented\" >&2\n  fi\n}\n\n# Function to check Python documentation\ncheck_python_docs() {\n  local file=$1\n  \n  echo \"ðŸ Checking Python documentation: $file\" >&2\n  \n  # Use interrogate if available\n  if command -v interrogate &> /dev/null; then\n    echo \"\" >> \"$REPORT_FILE\"\n    echo \"Python Docstring Coverage - $file\" >> \"$REPORT_FILE\"\n    \n    local coverage_output=$(interrogate -v \"$file\" 2>/dev/null)\n    echo \"$coverage_output\" >> \"$REPORT_FILE\"\n    \n    # Extract coverage percentage\n    local coverage=$(echo \"$coverage_output\" | grep -oE '[0-9]+\\.[0-9]+%' | head -1 | tr -d '%')\n    \n    if [ -n \"$coverage\" ]; then\n      if (( $(echo \"$coverage < $MIN_COVERAGE\" | bc -l) )); then\n        echo \"âš ï¸ Docstring coverage ${coverage}% below threshold ${MIN_COVERAGE}%\" >&2\n      else\n        echo \"âœ… Docstring coverage: ${coverage}%\" >&2\n      fi\n    fi\n  else\n    # Manual check for docstrings\n    local total_defs=$(grep -cE \"^\\s*def\\s+\\w+|^\\s*class\\s+\\w+\" \"$file\" 2>/dev/null || echo \"0\")\n    local documented=$(grep -A1 -cE \"^\\s*def\\s+\\w+|^\\s*class\\s+\\w+\" \"$file\" | grep -c '\"\"\"' || echo \"0\")\n    \n    if [ \"$total_defs\" -gt 0 ]; then\n      local coverage=$((documented * 100 / total_defs))\n      echo \"âš ï¸ Estimated docstring coverage: ${coverage}%\" >&2\n      echo \"ðŸ’¡ Install interrogate for accurate analysis: pip install interrogate\" >&2\n    fi\n  fi\n}\n\n# Function to check Go documentation\ncheck_go_docs() {\n  local file=$1\n  \n  echo \"ðŸ¹ Checking Go documentation: $file\" >&2\n  \n  if command -v go &> /dev/null; then\n    # Use go doc if available\n    if go doc -all 2>/dev/null | grep -q \"$file\"; then\n      echo \"âœ… Go documentation present\" >&2\n    else\n      echo \"ðŸ’¡ Add godoc comments to exported functions/types\" >&2\n    fi\n  fi\n  \n  # Check for exported items without comments\n  local undocumented=$(grep -E \"^func [A-Z]|^type [A-Z]\" \"$file\" | \\\n    while read -r line; do\n      grep -B1 \"$line\" \"$file\" | head -1 | grep -q \"^//\" || echo \"$line\"\n    done | wc -l)\n  \n  if [ \"$undocumented\" -gt 0 ]; then\n    echo \"âš ï¸ Found $undocumented undocumented exported items\" >&2\n  fi\n}\n\n# Function to check README freshness\ncheck_readme_freshness() {\n  if [ -f \"README.md\" ]; then\n    local readme_age=$(($(date +%s) - $(stat -f%m \"README.md\" 2>/dev/null || stat -c%Y \"README.md\" 2>/dev/null || echo \"0\")))\n    local days_old=$((readme_age / 86400))\n    \n    if [ \"$days_old\" -gt 90 ]; then\n      echo \"ðŸ“‹ README.md is $days_old days old - consider updating\" >&2\n    fi\n  else\n    echo \"âš ï¸ No README.md found - create project documentation\" >&2\n  fi\n}\n\n# Function to check API documentation\ncheck_api_docs() {\n  local file=$1\n  \n  # Check for API route definitions\n  if grep -iE \"@(get|post|put|delete|patch)|router\\.(get|post|put|delete|patch)|app\\.(get|post|put|delete|patch)\" \"$file\" >/dev/null 2>&1; then\n    echo \"ðŸŒ API endpoint detected in: $file\" >&2\n    \n    # Check for OpenAPI/Swagger comments\n    if ! grep -E \"@swagger|@openapi|@api\" \"$file\" >/dev/null 2>&1; then\n      echo \"ðŸ’¡ Consider adding OpenAPI/Swagger documentation for API endpoints\" >&2\n    fi\n    \n    # Check for request/response documentation\n    if ! grep -E \"@param|@returns|@request|@response\" \"$file\" >/dev/null 2>&1; then\n      echo \"ðŸ’¡ Document request parameters and response types\" >&2\n    fi\n  fi\n}\n\n# Main execution\nif needs_doc_check \"$FILE_PATH\"; then\n  echo \"ðŸ“š Documentation check triggered: $FILE_PATH\" >&2\n  \n  # Language-specific checks\n  case \"$FILE_PATH\" in\n    *.js|*.jsx|*.ts|*.tsx)\n      check_js_ts_docs \"$FILE_PATH\"\n      check_api_docs \"$FILE_PATH\"\n      ;;\n    *.py)\n      check_python_docs \"$FILE_PATH\"\n      check_api_docs \"$FILE_PATH\"\n      ;;\n    *.go)\n      check_go_docs \"$FILE_PATH\"\n      ;;\n  esac\n  \n  # General documentation checks\n  check_readme_freshness\n  \n  # Documentation best practices\n  echo \"\" >&2\n  echo \"ðŸ“– Documentation Best Practices:\" >&2\n  echo \"   â€¢ Document all public APIs and exported functions\" >&2\n  echo \"   â€¢ Include parameter types and return values\" >&2\n  echo \"   â€¢ Add usage examples for complex functions\" >&2\n  echo \"   â€¢ Keep README.md up-to-date with recent changes\" >&2\n  echo \"   â€¢ Use consistent documentation format (JSDoc/TSDoc/etc)\" >&2\n  \n  if [ -s \"$REPORT_FILE\" ]; then\n    echo \"\" >&2\n    echo \"ðŸ“„ Documentation report: $REPORT_FILE\" >&2\n  fi\nelif [[ \"$FILE_PATH\" == *README* ]] || [[ \"$FILE_PATH\" == *CHANGELOG* ]]; then\n  echo \"ðŸ“ Documentation file updated: $(basename \"$FILE_PATH\")\" >&2\n  echo \"âœ… Keep documentation current with code changes\" >&2\nfi\n\nexit 0"
  },
  "useCases": [
    "Automated documentation quality enforcement in development",
    "API documentation completeness validation",
    "Code review preparation with documentation checks",
    "Open source project documentation standards",
    "Technical debt tracking for missing documentation"
  ],
  "troubleshooting": [
    {
      "issue": "Hook reports low coverage but functions have inline comments",
      "solution": "Hook detects structured docstrings (JSDoc/TSDoc) not inline comments. Convert // comments to /** */ JSDoc format. Use @param and @returns tags for proper documentation detection."
    },
    {
      "issue": "Python interrogate not found but installed in virtualenv",
      "solution": "Activate virtualenv before hook runs: source venv/bin/activate in shell config. Use absolute path to interrogate binary. Add virtualenv bin directory to PATH in hook script."
    },
    {
      "issue": "False positives on private/internal functions flagged as undocumented",
      "solution": "Hook checks all functions regardless of visibility. Use naming conventions (_private in Python). Configure threshold lower for internal files. Add @internal JSDoc tag to suppress warnings."
    },
    {
      "issue": "Coverage threshold environment variable not applied",
      "solution": "Export DOC_COVERAGE_THRESHOLD before hook execution. Check bash environment in hook context. Set in .clauderc or shell profile. Verify with echo $DOC_COVERAGE_THRESHOLD in hook script."
    },
    {
      "issue": "API endpoint detection triggers on test files with mock routes",
      "solution": "Hook matches route patterns without context awareness. Exclude test directories from matchers: ! [[ $FILE_PATH == *test* ]]. Add separate threshold for test documentation."
    }
  ],
  "documentationUrl": "https://jsdoc.app/",
  "source": "community"
}
