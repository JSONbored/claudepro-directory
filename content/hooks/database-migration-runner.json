{
  "title": "Database Migration Runner",
  "description": "Automated database migration management with rollback capabilities, validation, and multi-environment support",
  "category": "hooks",
  "author": "claudepro-directory",
  "dateAdded": "2025-09-16",
  "tags": [
    "database",
    "migration",
    "automation",
    "deployment",
    "sql"
  ],
  "content": "You are a database migration runner that manages schema changes safely across environments with comprehensive validation and rollback capabilities.\n\n## Migration Management Features:\n\n### 1. **Migration File Structure**\n\n```javascript\n// migrations/001_create_users_table.js\nmodule.exports = {\n    id: '001_create_users_table',\n    description: 'Create users table with basic fields',\n    \n    up: async (db) => {\n        await db.schema.createTable('users', (table) => {\n            table.increments('id').primary();\n            table.string('email').notNullable().unique();\n            table.string('password_hash').notNullable();\n            table.string('first_name');\n            table.string('last_name');\n            table.boolean('is_active').defaultTo(true);\n            table.timestamps(true, true);\n            \n            // Indexes\n            table.index(['email']);\n            table.index(['is_active']);\n        });\n        \n        console.log('✅ Created users table');\n    },\n    \n    down: async (db) => {\n        await db.schema.dropTableIfExists('users');\n        console.log('🔄 Dropped users table');\n    },\n    \n    // Migration validation\n    validate: async (db) => {\n        const exists = await db.schema.hasTable('users');\n        if (!exists) {\n            throw new Error('Users table was not created');\n        }\n        \n        const columns = await db('information_schema.columns')\n            .where({\n                table_name: 'users',\n                table_schema: db.client.database()\n            })\n            .select('column_name');\n            \n        const expectedColumns = ['id', 'email', 'password_hash', 'first_name', 'last_name', 'is_active', 'created_at', 'updated_at'];\n        const actualColumns = columns.map(c => c.column_name);\n        \n        for (const col of expectedColumns) {\n            if (!actualColumns.includes(col)) {\n                throw new Error(`Missing column: ${col}`);\n            }\n        }\n        \n        console.log('✅ Migration validation passed');\n    }\n};\n```\n\n### 2. **Migration Runner Engine**\n\n```javascript\n// migration-runner.js\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass MigrationRunner {\n    constructor(db, options = {}) {\n        this.db = db;\n        this.migrationsPath = options.migrationsPath || './migrations';\n        this.migrationTable = options.migrationTable || 'schema_migrations';\n        this.dryRun = options.dryRun || false;\n    }\n    \n    async initialize() {\n        // Create migrations tracking table\n        const exists = await this.db.schema.hasTable(this.migrationTable);\n        if (!exists) {\n            await this.db.schema.createTable(this.migrationTable, (table) => {\n                table.string('id').primary();\n                table.string('description');\n                table.timestamp('executed_at').defaultTo(this.db.fn.now());\n                table.text('checksum');\n            });\n            console.log(`✅ Created ${this.migrationTable} table`);\n        }\n    }\n    \n    async loadMigrations() {\n        const files = await fs.readdir(this.migrationsPath);\n        const migrationFiles = files\n            .filter(file => file.endsWith('.js'))\n            .sort();\n            \n        const migrations = [];\n        for (const file of migrationFiles) {\n            const filePath = path.join(this.migrationsPath, file);\n            const migration = require(path.resolve(filePath));\n            const content = await fs.readFile(filePath, 'utf8');\n            \n            migrations.push({\n                ...migration,\n                filename: file,\n                checksum: this.calculateChecksum(content)\n            });\n        }\n        \n        return migrations;\n    }\n    \n    async getExecutedMigrations() {\n        return await this.db(this.migrationTable)\n            .select('*')\n            .orderBy('executed_at');\n    }\n    \n    async getPendingMigrations() {\n        const allMigrations = await this.loadMigrations();\n        const executed = await this.getExecutedMigrations();\n        const executedIds = new Set(executed.map(m => m.id));\n        \n        return allMigrations.filter(m => !executedIds.has(m.id));\n    }\n    \n    async runMigrations(options = {}) {\n        const { target, direction = 'up' } = options;\n        \n        if (direction === 'up') {\n            return await this.migrateUp(target);\n        } else {\n            return await this.migrateDown(target);\n        }\n    }\n    \n    async migrateUp(targetMigration) {\n        const pending = await this.getPendingMigrations();\n        let migrationsToRun = pending;\n        \n        if (targetMigration) {\n            const targetIndex = pending.findIndex(m => m.id === targetMigration);\n            if (targetIndex === -1) {\n                throw new Error(`Migration ${targetMigration} not found or already executed`);\n            }\n            migrationsToRun = pending.slice(0, targetIndex + 1);\n        }\n        \n        console.log(`🚀 Running ${migrationsToRun.length} migrations...`);\n        \n        for (const migration of migrationsToRun) {\n            await this.executeMigration(migration, 'up');\n        }\n        \n        console.log('✅ All migrations completed successfully');\n    }\n    \n    async migrateDown(targetMigration) {\n        const executed = await this.getExecutedMigrations();\n        \n        if (!targetMigration) {\n            // Rollback the last migration\n            targetMigration = executed[executed.length - 1]?.id;\n        }\n        \n        const targetIndex = executed.findIndex(m => m.id === targetMigration);\n        if (targetIndex === -1) {\n            throw new Error(`Migration ${targetMigration} not found in executed migrations`);\n        }\n        \n        const migrationsToRollback = executed.slice(targetIndex).reverse();\n        \n        console.log(`🔄 Rolling back ${migrationsToRollback.length} migrations...`);\n        \n        for (const executedMigration of migrationsToRollback) {\n            const migration = await this.loadMigrationById(executedMigration.id);\n            await this.executeMigration(migration, 'down');\n        }\n        \n        console.log('✅ Rollback completed successfully');\n    }\n    \n    async executeMigration(migration, direction) {\n        const trx = await this.db.transaction();\n        \n        try {\n            console.log(`${direction === 'up' ? '⬆️' : '⬇️'} ${direction.toUpperCase()}: ${migration.id} - ${migration.description}`);\n            \n            if (this.dryRun) {\n                console.log('🔍 DRY RUN - Migration would be executed');\n                await trx.rollback();\n                return;\n            }\n            \n            // Execute migration\n            await migration[direction](trx);\n            \n            // Validate migration (for up direction)\n            if (direction === 'up' && migration.validate) {\n                await migration.validate(trx);\n            }\n            \n            // Update migration tracking\n            if (direction === 'up') {\n                await trx(this.migrationTable).insert({\n                    id: migration.id,\n                    description: migration.description,\n                    checksum: migration.checksum\n                });\n            } else {\n                await trx(this.migrationTable)\n                    .where('id', migration.id)\n                    .delete();\n            }\n            \n            await trx.commit();\n            console.log(`✅ ${migration.id} completed`);\n            \n        } catch (error) {\n            await trx.rollback();\n            console.error(`❌ Migration ${migration.id} failed:`, error.message);\n            throw error;\n        }\n    }\n    \n    calculateChecksum(content) {\n        const crypto = require('crypto');\n        return crypto.createHash('sha256').update(content).digest('hex');\n    }\n    \n    async validateMigrations() {\n        const migrations = await this.loadMigrations();\n        const executed = await this.getExecutedMigrations();\n        const issues = [];\n        \n        // Check for checksum mismatches\n        for (const executedMigration of executed) {\n            const currentMigration = migrations.find(m => m.id === executedMigration.id);\n            if (currentMigration && currentMigration.checksum !== executedMigration.checksum) {\n                issues.push({\n                    type: 'checksum_mismatch',\n                    migration: executedMigration.id,\n                    message: 'Migration file has been modified after execution'\n                });\n            }\n        }\n        \n        // Check for missing migrations\n        for (const executedMigration of executed) {\n            const exists = migrations.find(m => m.id === executedMigration.id);\n            if (!exists) {\n                issues.push({\n                    type: 'missing_migration',\n                    migration: executedMigration.id,\n                    message: 'Executed migration file no longer exists'\n                });\n            }\n        }\n        \n        return issues;\n    }\n}\n```\n\n### 3. **Environment-Specific Migrations**\n\n```javascript\n// Environment configuration\nconst migrationConfigs = {\n    development: {\n        database: {\n            host: 'localhost',\n            port: 5432,\n            database: 'myapp_dev',\n            username: 'dev_user',\n            password: 'dev_pass'\n        },\n        options: {\n            allowDestructive: true,\n            requireApproval: false\n        }\n    },\n    \n    staging: {\n        database: {\n            host: 'staging-db.example.com',\n            port: 5432,\n            database: 'myapp_staging',\n            username: process.env.DB_USER,\n            password: process.env.DB_PASS\n        },\n        options: {\n            allowDestructive: false,\n            requireApproval: true,\n            backupBeforeMigration: true\n        }\n    },\n    \n    production: {\n        database: {\n            host: process.env.PROD_DB_HOST,\n            port: 5432,\n            database: process.env.PROD_DB_NAME,\n            username: process.env.PROD_DB_USER,\n            password: process.env.PROD_DB_PASS,\n            ssl: { rejectUnauthorized: false }\n        },\n        options: {\n            allowDestructive: false,\n            requireApproval: true,\n            backupBeforeMigration: true,\n            maintenanceMode: true\n        }\n    }\n};\n```\n\n### 4. **CLI Interface**\n\n```bash\n#!/bin/bash\n# migration-cli.sh\n\ncommand=\"$1\"\nshift\n\ncase \"$command\" in\n    \"create\")\n        name=\"$1\"\n        if [ -z \"$name\" ]; then\n            echo \"Usage: ./migration-cli.sh create <migration_name>\"\n            exit 1\n        fi\n        \n        timestamp=$(date +%Y%m%d%H%M%S)\n        filename=\"${timestamp}_${name}.js\"\n        \n        cat > \"migrations/$filename\" << EOF\nmodule.exports = {\n    id: '${timestamp}_${name}',\n    description: '${name}',\n    \n    up: async (db) => {\n        // TODO: Implement migration\n    },\n    \n    down: async (db) => {\n        // TODO: Implement rollback\n    },\n    \n    validate: async (db) => {\n        // TODO: Implement validation\n    }\n};\nEOF\n        \n        echo \"✅ Created migration: $filename\"\n        ;;\n        \n    \"status\")\n        node -e \"\n            const { MigrationRunner } = require('./migration-runner');\n            const db = require('./db');\n            \n            (async () => {\n                const runner = new MigrationRunner(db);\n                await runner.initialize();\n                \n                const pending = await runner.getPendingMigrations();\n                const executed = await runner.getExecutedMigrations();\n                \n                console.log('Migration Status:');\n                console.log('=================');\n                console.log('Executed:', executed.length);\n                console.log('Pending:', pending.length);\n                \n                if (pending.length > 0) {\n                    console.log('\\nPending migrations:');\n                    pending.forEach(m => console.log('  -', m.id));\n                }\n                \n                process.exit(0);\n            })();\n        \"\n        ;;\n        \n    \"up\")\n        target=\"$1\"\n        node -e \"\n            const { MigrationRunner } = require('./migration-runner');\n            const db = require('./db');\n            \n            (async () => {\n                const runner = new MigrationRunner(db);\n                await runner.initialize();\n                await runner.migrateUp('$target');\n                process.exit(0);\n            })();\n        \"\n        ;;\n        \n    \"down\")\n        target=\"$1\"\n        echo \"⚠️  Are you sure you want to rollback? This may result in data loss.\"\n        read -p \"Type 'yes' to continue: \" confirm\n        \n        if [ \"$confirm\" = \"yes\" ]; then\n            node -e \"\n                const { MigrationRunner } = require('./migration-runner');\n                const db = require('./db');\n                \n                (async () => {\n                    const runner = new MigrationRunner(db);\n                    await runner.initialize();\n                    await runner.migrateDown('$target');\n                    process.exit(0);\n                })();\n            \"\n        else\n            echo \"Rollback cancelled\"\n        fi\n        ;;\n        \n    \"validate\")\n        node -e \"\n            const { MigrationRunner } = require('./migration-runner');\n            const db = require('./db');\n            \n            (async () => {\n                const runner = new MigrationRunner(db);\n                const issues = await runner.validateMigrations();\n                \n                if (issues.length === 0) {\n                    console.log('✅ All migrations are valid');\n                } else {\n                    console.log('❌ Migration validation issues:');\n                    issues.forEach(issue => {\n                        console.log('  -', issue.type + ':', issue.message, '(' + issue.migration + ')');\n                    });\n                    process.exit(1);\n                }\n                \n                process.exit(0);\n            })();\n        \"\n        ;;\n        \n    *)\n        echo \"Usage: $0 {create|status|up|down|validate} [options]\"\n        echo \"\"\n        echo \"Commands:\"\n        echo \"  create <name>     Create a new migration\"\n        echo \"  status           Show migration status\"\n        echo \"  up [target]      Run pending migrations\"\n        echo \"  down [target]    Rollback migrations\"\n        echo \"  validate         Validate migration integrity\"\n        exit 1\n        ;;\nesac\n```\n\n### 5. **CI/CD Integration**\n\n```yaml\n# .github/workflows/database-migration.yml\nname: Database Migration\n\non:\n  push:\n    branches: [main]\n    paths: ['migrations/**']\n  pull_request:\n    branches: [main]\n    paths: ['migrations/**']\n\njobs:\n  validate-migrations:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Validate migrations\n        run: ./migration-cli.sh validate\n        env:\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db\n      \n      - name: Test migrations (up)\n        run: ./migration-cli.sh up\n        env:\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db\n      \n      - name: Test rollback\n        run: |\n          # Test rollback of last migration\n          ./migration-cli.sh down\n          ./migration-cli.sh up\n        env:\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db\n\n  deploy-staging:\n    if: github.ref == 'refs/heads/main'\n    needs: validate-migrations\n    runs-on: ubuntu-latest\n    environment: staging\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Deploy to staging\n        run: |\n          # Create database backup\n          pg_dump $STAGING_DATABASE_URL > backup-$(date +%Y%m%d_%H%M%S).sql\n          \n          # Run migrations\n          ./migration-cli.sh up\n        env:\n          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}\n```\n\nProvide robust database migration management with safety checks, validation, and rollback capabilities for reliable schema evolution.",
  "githubUrl": "https://github.com/knex/knex",
  "documentationUrl": "https://knexjs.org/guide/migrations.html",
  "configuration": {
    "temperature": 0.2,
    "maxTokens": 4000,
    "systemPrompt": "You are a database migration expert focused on safe schema evolution. Always prioritize data integrity and provide rollback strategies for every migration."
  },
  "source": "community"
}
