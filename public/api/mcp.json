{
  "mcp": [
    {
      "title": "AWS Services MCP",
      "description": "Comprehensive AWS cloud services integration for infrastructure management, deployment, and monitoring",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "aws",
        "cloud",
        "infrastructure",
        "deployment",
        "monitoring"
      ],
      "content": "The AWS Services MCP Server provides comprehensive integration with Amazon Web Services, enabling infrastructure management, application deployment, and cloud resource monitoring directly through Claude.\n\n## Supported AWS Services\n\n### Compute Services\n- **EC2**: Instance management, security groups, key pairs\n- **Lambda**: Function deployment, invocation, monitoring\n- **ECS/Fargate**: Container orchestration and management\n- **Auto Scaling**: Scaling groups and policies\n\n### Storage Services\n- **S3**: Bucket management, object operations, lifecycle policies\n- **EBS**: Volume management and snapshots\n- **EFS**: File system management\n\n### Database Services\n- **RDS**: Database instance management and monitoring\n- **DynamoDB**: NoSQL database operations\n- **ElastiCache**: Redis and Memcached cluster management\n\n### Networking\n- **VPC**: Virtual private cloud management\n- **Route 53**: DNS management and health checks\n- **CloudFront**: CDN distribution management\n- **Load Balancers**: ALB, NLB, and Classic LB management\n\n### Security & Identity\n- **IAM**: User, role, and policy management\n- **Secrets Manager**: Secret storage and rotation\n- **Certificate Manager**: SSL/TLS certificate management\n\n### Monitoring & Logging\n- **CloudWatch**: Metrics, logs, and alarms\n- **X-Ray**: Application tracing and performance insights\n- **CloudTrail**: API activity monitoring\n\n### DevOps & Deployment\n- **CodeBuild**: Build project management\n- **CodeDeploy**: Application deployment automation\n- **CloudFormation**: Infrastructure as code\n- **Systems Manager**: Instance management and automation\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-aws\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"aws\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-aws\"],\n      \"env\": {\n        \"AWS_ACCESS_KEY_ID\": \"your-access-key\",\n        \"AWS_SECRET_ACCESS_KEY\": \"your-secret-key\",\n        \"AWS_DEFAULT_REGION\": \"us-east-1\",\n        \"AWS_SESSION_TOKEN\": \"optional-session-token\"\n      }\n    }\n  }\n}\n```\n\n## Authentication Methods\n\n### Method 1: IAM User Credentials\n```bash\n# Set environment variables\nexport AWS_ACCESS_KEY_ID=\"AKIAIOSFODNN7EXAMPLE\"\nexport AWS_SECRET_ACCESS_KEY=\"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\"\nexport AWS_DEFAULT_REGION=\"us-west-2\"\n```\n\n### Method 2: AWS Profile\n```json\n{\n  \"env\": {\n    \"AWS_PROFILE\": \"claude-integration\"\n  }\n}\n```\n\n### Method 3: IAM Roles (EC2/ECS)\n- No additional configuration needed when running on EC2 with attached IAM role\n- Automatically uses instance metadata service\n\n## Usage Examples\n\n### EC2 Instance Management\n```javascript\n// Launch new instance\nconst instance = await aws.ec2.runInstances({\n  ImageId: 'ami-0abcdef1234567890',\n  InstanceType: 't3.micro',\n  MinCount: 1,\n  MaxCount: 1,\n  KeyName: 'my-key-pair',\n  SecurityGroupIds: ['sg-12345678'],\n  SubnetId: 'subnet-12345678',\n  TagSpecifications: [{\n    ResourceType: 'instance',\n    Tags: [\n      { Key: 'Name', Value: 'WebServer-01' },\n      { Key: 'Environment', Value: 'Production' }\n    ]\n  }]\n});\n\n// List instances with filters\nconst instances = await aws.ec2.describeInstances({\n  Filters: [\n    { Name: 'instance-state-name', Values: ['running'] },\n    { Name: 'tag:Environment', Values: ['Production'] }\n  ]\n});\n```\n\n### S3 Bucket Operations\n```javascript\n// Create bucket with versioning\nconst bucket = await aws.s3.createBucket({\n  Bucket: 'my-app-assets-2025',\n  CreateBucketConfiguration: {\n    LocationConstraint: 'us-west-2'\n  }\n});\n\n// Enable versioning\nconst versioning = await aws.s3.putBucketVersioning({\n  Bucket: 'my-app-assets-2025',\n  VersioningConfiguration: {\n    Status: 'Enabled'\n  }\n});\n\n// Upload file with metadata\nconst upload = await aws.s3.putObject({\n  Bucket: 'my-app-assets-2025',\n  Key: 'assets/app.js',\n  Body: fileContent,\n  ContentType: 'application/javascript',\n  Metadata: {\n    'uploaded-by': 'claude-mcp',\n    'build-version': '1.2.3'\n  }\n});\n```\n\n### Lambda Function Deployment\n```javascript\n// Create function\nconst func = await aws.lambda.createFunction({\n  FunctionName: 'ProcessImageThumbnails',\n  Runtime: 'nodejs18.x',\n  Role: 'arn:aws:iam::123456789012:role/lambda-execution-role',\n  Handler: 'index.handler',\n  Code: {\n    ZipFile: functionZipBuffer\n  },\n  Environment: {\n    Variables: {\n      'S3_BUCKET': 'image-processing-bucket',\n      'THUMBNAIL_SIZE': '150'\n    }\n  },\n  Timeout: 30,\n  MemorySize: 256\n});\n\n// Invoke function\nconst result = await aws.lambda.invoke({\n  FunctionName: 'ProcessImageThumbnails',\n  Payload: JSON.stringify({\n    imageKey: 'uploads/photo.jpg',\n    sizes: [150, 300, 600]\n  })\n});\n```\n\n### RDS Database Management\n```javascript\n// Create database instance\nconst db = await aws.rds.createDBInstance({\n  DBInstanceIdentifier: 'production-db',\n  DBInstanceClass: 'db.t3.micro',\n  Engine: 'postgres',\n  EngineVersion: '14.9',\n  MasterUsername: 'dbadmin',\n  MasterUserPassword: 'secure-password-123',\n  AllocatedStorage: 20,\n  VpcSecurityGroupIds: ['sg-database-access'],\n  DBSubnetGroupName: 'default-vpc-subnet-group',\n  BackupRetentionPeriod: 7,\n  MultiAZ: false,\n  StorageEncrypted: true\n});\n\n// Create read replica\nconst replica = await aws.rds.createDBInstanceReadReplica({\n  DBInstanceIdentifier: 'production-db-replica',\n  SourceDBInstanceIdentifier: 'production-db',\n  DBInstanceClass: 'db.t3.micro'\n});\n```\n\n### CloudWatch Monitoring\n```javascript\n// Create custom metric\nconst metric = await aws.cloudwatch.putMetricData({\n  Namespace: 'MyApp/Performance',\n  MetricData: [{\n    MetricName: 'ResponseTime',\n    Value: 245.5,\n    Unit: 'Milliseconds',\n    Dimensions: [\n      { Name: 'Environment', Value: 'Production' },\n      { Name: 'Endpoint', Value: '/api/users' }\n    ],\n    Timestamp: new Date()\n  }]\n});\n\n// Create alarm\nconst alarm = await aws.cloudwatch.putMetricAlarm({\n  AlarmName: 'HighResponseTime',\n  ComparisonOperator: 'GreaterThanThreshold',\n  EvaluationPeriods: 2,\n  MetricName: 'ResponseTime',\n  Namespace: 'MyApp/Performance',\n  Period: 300,\n  Statistic: 'Average',\n  Threshold: 500.0,\n  ActionsEnabled: true,\n  AlarmActions: [\n    'arn:aws:sns:us-west-2:123456789012:high-response-time'\n  ],\n  AlarmDescription: 'Alert when response time exceeds 500ms'\n});\n```\n\n## CloudFormation Templates\n\n### Web Application Stack\n```yaml\n# Generated CloudFormation template\nAWSTemplateFormatVersion: '2010-09-09'\nDescription: 'Complete web application infrastructure'\n\nParameters:\n  Environment:\n    Type: String\n    Default: 'staging'\n    AllowedValues: ['staging', 'production']\n\nResources:\n  # VPC and Networking\n  VPC:\n    Type: AWS::EC2::VPC\n    Properties:\n      CidrBlock: '10.0.0.0/16'\n      EnableDnsHostnames: true\n      EnableDnsSupport: true\n      Tags:\n        - Key: Name\n          Value: !Sub '${Environment}-vpc'\n\n  # Application Load Balancer\n  LoadBalancer:\n    Type: AWS::ElasticLoadBalancingV2::LoadBalancer\n    Properties:\n      Type: application\n      Scheme: internet-facing\n      SecurityGroups: [!Ref ALBSecurityGroup]\n      Subnets: [!Ref PublicSubnet1, !Ref PublicSubnet2]\n\n  # Auto Scaling Group\n  AutoScalingGroup:\n    Type: AWS::AutoScaling::AutoScalingGroup\n    Properties:\n      VPCZoneIdentifier: [!Ref PrivateSubnet1, !Ref PrivateSubnet2]\n      LaunchTemplate:\n        LaunchTemplateId: !Ref LaunchTemplate\n        Version: !GetAtt LaunchTemplate.LatestVersionNumber\n      MinSize: 2\n      MaxSize: 10\n      DesiredCapacity: 2\n      TargetGroupARNs: [!Ref TargetGroup]\n\nOutputs:\n  LoadBalancerDNS:\n    Description: 'DNS name of the load balancer'\n    Value: !GetAtt LoadBalancer.DNSName\n```\n\n## Security Best Practices\n\n### IAM Policy Example\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ec2:DescribeInstances\",\n        \"ec2:DescribeImages\",\n        \"ec2:DescribeSecurityGroups\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\"\n      ],\n      \"Resource\": \"arn:aws:s3:::my-app-bucket/*\"\n    }\n  ]\n}\n```\n\n### Least Privilege Access\n- Use specific resource ARNs when possible\n- Implement condition-based policies\n- Regular access review and cleanup\n- Enable CloudTrail for audit logging\n\n## Cost Optimization\n\n### Resource Tagging Strategy\n```javascript\n// Consistent tagging across resources\nconst standardTags = {\n  Environment: 'production',\n  Project: 'web-app',\n  Owner: 'development-team',\n  CostCenter: 'engineering',\n  AutoShutdown: 'true'\n};\n```\n\n### Automated Cost Controls\n- Instance scheduling based on tags\n- Unused resource identification\n- Cost alerts and budgets\n- Right-sizing recommendations",
      "configuration": {
        "requiresAuth": true,
        "authType": "api_key",
        "permissions": [
          "ec2:*",
          "s3:*",
          "lambda:*",
          "rds:*",
          "cloudwatch:*"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-aws",
      "documentationUrl": "https://docs.claude.ai/mcp/aws",
      "source": "community",
      "slug": "aws-services",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/aws-services"
    },
    {
      "title": "Discord Integration MCP",
      "description": "Complete Discord bot integration for community management, moderation, and interactive features",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "discord",
        "bot",
        "community",
        "moderation",
        "gaming",
        "social"
      ],
      "content": "The Discord Integration MCP Server enables comprehensive Discord bot functionality, community management, and interactive features for engaging with Discord servers and users.\n\n## Core Capabilities\n\n### Bot Management\n- Bot presence and status management\n- Activity tracking and updates\n- Permission handling and validation\n- Multi-server bot deployment\n- Command registration and handling\n\n### Message & Channel Operations\n- Send messages with rich embeds\n- Message editing and deletion\n- Reaction management and tracking\n- Thread creation and management\n- Channel creation and configuration\n- Voice channel operations\n\n### User & Guild Management\n- Member management and moderation\n- Role assignment and permissions\n- User verification and onboarding\n- Guild information and settings\n- Invite management\n\n### Advanced Features\n- Slash commands and interactions\n- Modal forms and components\n- Webhook management\n- Event handling and logging\n- Integration with external APIs\n- Database integration for persistence\n\n### Moderation Tools\n- Automated content filtering\n- Warning and punishment systems\n- Anti-spam protection\n- Raid detection and prevention\n- Audit log monitoring\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-discord\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"discord\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-discord\"],\n      \"env\": {\n        \"DISCORD_TOKEN\": \"your-bot-token\",\n        \"DISCORD_CLIENT_ID\": \"your-application-id\",\n        \"DISCORD_GUILD_ID\": \"your-server-id\",\n        \"DISCORD_PREFIX\": \"!\",\n        \"DISCORD_OWNER_ID\": \"your-user-id\"\n      }\n    }\n  }\n}\n```\n\n## Bot Setup Instructions\n\n1. **Create Discord Application**\n   - Go to https://discord.com/developers/applications\n   - Click \"New Application\" and name your bot\n   - Go to \"Bot\" section and create a bot\n   - Copy the bot token\n\n2. **Configure Bot Permissions**\n   ```\n   Required Bot Permissions:\n   - Send Messages\n   - Embed Links\n   - Attach Files\n   - Read Message History\n   - Use Slash Commands\n   - Manage Messages\n   - Manage Roles\n   - Manage Channels\n   - View Channels\n   ```\n\n3. **Invite Bot to Server**\n   ```\n   https://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=8&scope=bot%20applications.commands\n   ```\n\n## Usage Examples\n\n### Basic Message Operations\n```javascript\n// Send simple message\nconst message = await discord.sendMessage({\n  channelId: '123456789012345678',\n  content: 'Hello, Discord! 👋'\n});\n\n// Send rich embed\nconst embed = await discord.sendEmbed({\n  channelId: '123456789012345678',\n  embed: {\n    title: 'Server Statistics',\n    description: 'Current server information',\n    color: 0x00ff00,\n    fields: [\n      {\n        name: 'Total Members',\n        value: '1,247',\n        inline: true\n      },\n      {\n        name: 'Online Members',\n        value: '382',\n        inline: true\n      },\n      {\n        name: 'Active Channels',\n        value: '15',\n        inline: true\n      }\n    ],\n    thumbnail: {\n      url: 'https://example.com/server-icon.png'\n    },\n    timestamp: new Date().toISOString(),\n    footer: {\n      text: 'Last updated',\n      icon_url: 'https://example.com/bot-avatar.png'\n    }\n  }\n});\n\n// Send message with components\nconst interactive = await discord.sendMessage({\n  channelId: '123456789012345678',\n  content: 'Choose an option:',\n  components: [\n    {\n      type: 1, // Action Row\n      components: [\n        {\n          type: 2, // Button\n          style: 1, // Primary\n          label: 'Accept',\n          custom_id: 'accept_button',\n          emoji: { name: '✅' }\n        },\n        {\n          type: 2, // Button\n          style: 4, // Danger\n          label: 'Decline',\n          custom_id: 'decline_button',\n          emoji: { name: '❌' }\n        }\n      ]\n    }\n  ]\n});\n```\n\n### Slash Commands\n```javascript\n// Register slash commands\nconst commands = [\n  {\n    name: 'ping',\n    description: 'Replies with Pong!',\n    options: []\n  },\n  {\n    name: 'userinfo',\n    description: 'Get information about a user',\n    options: [\n      {\n        name: 'user',\n        description: 'The user to get info about',\n        type: 6, // USER type\n        required: true\n      }\n    ]\n  },\n  {\n    name: 'ban',\n    description: 'Ban a user from the server',\n    default_member_permissions: '4', // BAN_MEMBERS permission\n    options: [\n      {\n        name: 'user',\n        description: 'User to ban',\n        type: 6,\n        required: true\n      },\n      {\n        name: 'reason',\n        description: 'Reason for the ban',\n        type: 3, // STRING type\n        required: false\n      },\n      {\n        name: 'delete_days',\n        description: 'Days of messages to delete (0-7)',\n        type: 4, // INTEGER type\n        required: false,\n        min_value: 0,\n        max_value: 7\n      }\n    ]\n  }\n];\n\nconst registerCommands = await discord.registerSlashCommands(commands);\n\n// Handle slash command interactions\ndiscord.on('interactionCreate', async (interaction) => {\n  if (!interaction.isChatInputCommand()) return;\n  \n  switch (interaction.commandName) {\n    case 'ping':\n      await interaction.reply({\n        content: `Pong! Latency: ${discord.ws.ping}ms`,\n        ephemeral: true\n      });\n      break;\n      \n    case 'userinfo':\n      const user = interaction.options.getUser('user');\n      const member = await interaction.guild.members.fetch(user.id);\n      \n      const userEmbed = {\n        title: `User Info: ${user.tag}`,\n        thumbnail: { url: user.displayAvatarURL() },\n        fields: [\n          { name: 'ID', value: user.id, inline: true },\n          { name: 'Created', value: `<t:${Math.floor(user.createdTimestamp / 1000)}:F>`, inline: true },\n          { name: 'Joined', value: `<t:${Math.floor(member.joinedTimestamp / 1000)}:F>`, inline: true },\n          { name: 'Roles', value: member.roles.cache.map(r => r.toString()).join(' '), inline: false }\n        ],\n        color: member.displayHexColor\n      };\n      \n      await interaction.reply({ embeds: [userEmbed] });\n      break;\n      \n    case 'ban':\n      const targetUser = interaction.options.getUser('user');\n      const reason = interaction.options.getString('reason') || 'No reason provided';\n      const deleteDays = interaction.options.getInteger('delete_days') || 0;\n      \n      try {\n        await interaction.guild.members.ban(targetUser, {\n          reason: `${reason} | Banned by ${interaction.user.tag}`,\n          deleteMessageDays: deleteDays\n        });\n        \n        await interaction.reply({\n          content: `Successfully banned ${targetUser.tag} for: ${reason}`,\n          ephemeral: true\n        });\n      } catch (error) {\n        await interaction.reply({\n          content: `Failed to ban user: ${error.message}`,\n          ephemeral: true\n        });\n      }\n      break;\n  }\n});\n```\n\n### Advanced Moderation System\n```javascript\n// Auto-moderation configuration\nconst autoMod = {\n  spamDetection: {\n    enabled: true,\n    maxMessages: 5,\n    timeWindow: 10000, // 10 seconds\n    punishment: 'timeout', // timeout, kick, ban\n    duration: 300000 // 5 minutes timeout\n  },\n  wordFilter: {\n    enabled: true,\n    blockedWords: ['spam', 'scam', 'inappropriate'],\n    action: 'delete',\n    warnUser: true\n  },\n  linkFilter: {\n    enabled: true,\n    allowedDomains: ['youtube.com', 'github.com'],\n    blockInvites: true\n  }\n};\n\n// Message monitoring\ndiscord.on('messageCreate', async (message) => {\n  if (message.author.bot) return;\n  \n  // Spam detection\n  if (autoMod.spamDetection.enabled) {\n    const userMessages = recentMessages.get(message.author.id) || [];\n    userMessages.push(Date.now());\n    \n    // Remove old messages outside time window\n    const validMessages = userMessages.filter(\n      timestamp => Date.now() - timestamp < autoMod.spamDetection.timeWindow\n    );\n    \n    if (validMessages.length > autoMod.spamDetection.maxMessages) {\n      await handleSpam(message, autoMod.spamDetection.punishment);\n      return;\n    }\n    \n    recentMessages.set(message.author.id, validMessages);\n  }\n  \n  // Word filter\n  if (autoMod.wordFilter.enabled) {\n    const hasBlockedWord = autoMod.wordFilter.blockedWords.some(\n      word => message.content.toLowerCase().includes(word.toLowerCase())\n    );\n    \n    if (hasBlockedWord) {\n      await message.delete();\n      if (autoMod.wordFilter.warnUser) {\n        await message.author.send({\n          embeds: [{\n            title: 'Message Removed',\n            description: 'Your message was removed for containing inappropriate content.',\n            color: 0xff0000\n          }]\n        });\n      }\n      return;\n    }\n  }\n  \n  // Link filter\n  if (autoMod.linkFilter.enabled) {\n    const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n    const urls = message.content.match(urlRegex) || [];\n    \n    for (const url of urls) {\n      const domain = new URL(url).hostname;\n      \n      if (autoMod.linkFilter.blockInvites && url.includes('discord.gg')) {\n        await message.delete();\n        await warnUser(message.author, 'Posted unauthorized invite link');\n        return;\n      }\n      \n      if (!autoMod.linkFilter.allowedDomains.includes(domain)) {\n        await message.delete();\n        await warnUser(message.author, 'Posted unauthorized link');\n        return;\n      }\n    }\n  }\n});\n\n// Warning system\nconst warnUser = async (user, reason) => {\n  const warnings = await database.getUserWarnings(user.id);\n  \n  await database.addWarning({\n    userId: user.id,\n    reason: reason,\n    timestamp: Date.now(),\n    moderator: 'AutoMod'\n  });\n  \n  const warningCount = warnings.length + 1;\n  \n  // Escalation system\n  if (warningCount >= 5) {\n    await user.ban({ reason: 'Exceeded warning limit (5 warnings)' });\n  } else if (warningCount >= 3) {\n    await user.timeout(86400000, 'Multiple warnings (24 hour timeout)'); // 24 hours\n  } else if (warningCount >= 2) {\n    await user.timeout(3600000, 'Multiple warnings (1 hour timeout)'); // 1 hour\n  }\n  \n  // Notify user\n  try {\n    await user.send({\n      embeds: [{\n        title: 'Warning Received',\n        description: `You have been warned for: ${reason}`,\n        fields: [\n          { name: 'Warning Count', value: `${warningCount}/5`, inline: true },\n          { name: 'Next Punishment', value: getNextPunishment(warningCount), inline: true }\n        ],\n        color: 0xffa500\n      }]\n    });\n  } catch (error) {\n    console.log('Could not DM user about warning');\n  }\n};\n```\n\n### Server Management Features\n```javascript\n// Welcome system\ndiscord.on('guildMemberAdd', async (member) => {\n  const welcomeChannel = member.guild.channels.cache.get(WELCOME_CHANNEL_ID);\n  \n  // Send welcome message\n  const welcomeEmbed = {\n    title: 'Welcome to the Server! 🎉',\n    description: `Hey ${member.user}, welcome to **${member.guild.name}**!`,\n    thumbnail: { url: member.user.displayAvatarURL() },\n    fields: [\n      {\n        name: 'Getting Started',\n        value: '• Read <#rules-channel>\\n• Get roles in <#role-selection>\\n• Say hi in <#general>',\n        inline: false\n      },\n      {\n        name: 'Member Count',\n        value: `You're member #${member.guild.memberCount}!`,\n        inline: true\n      }\n    ],\n    color: 0x00ff00,\n    footer: {\n      text: 'Enjoy your stay!',\n      icon_url: member.guild.iconURL()\n    }\n  };\n  \n  await welcomeChannel.send({\n    content: `${member.user}`,\n    embeds: [welcomeEmbed]\n  });\n  \n  // Auto-assign roles\n  const defaultRole = member.guild.roles.cache.get(DEFAULT_ROLE_ID);\n  if (defaultRole) {\n    await member.roles.add(defaultRole);\n  }\n  \n  // Send DM with server info\n  try {\n    await member.send({\n      embeds: [{\n        title: `Welcome to ${member.guild.name}!`,\n        description: 'Here\\'s what you need to know:',\n        fields: [\n          { name: 'Rules', value: 'Please read our server rules to get started.' },\n          { name: 'Support', value: 'Need help? Ask in our support channel or DM a moderator.' }\n        ]\n      }]\n    });\n  } catch (error) {\n    console.log('Could not send welcome DM');\n  }\n});\n\n// Role management\nconst roleCommands = {\n  async assignRole(interaction) {\n    const user = interaction.options.getUser('user');\n    const roleName = interaction.options.getString('role');\n    const member = await interaction.guild.members.fetch(user.id);\n    const role = interaction.guild.roles.cache.find(r => r.name === roleName);\n    \n    if (!role) {\n      return interaction.reply({ content: 'Role not found!', ephemeral: true });\n    }\n    \n    await member.roles.add(role);\n    await interaction.reply({\n      content: `Successfully assigned **${role.name}** to ${user.tag}`,\n      ephemeral: true\n    });\n  },\n  \n  async createRole(interaction) {\n    const name = interaction.options.getString('name');\n    const color = interaction.options.getString('color') || '#99aab5';\n    const permissions = interaction.options.getString('permissions') || '0';\n    \n    const role = await interaction.guild.roles.create({\n      name: name,\n      color: color,\n      permissions: permissions,\n      reason: `Role created by ${interaction.user.tag}`\n    });\n    \n    await interaction.reply({\n      content: `Created role **${role.name}** with color ${color}`,\n      ephemeral: true\n    });\n  }\n};\n\n// Voice channel management\nconst voiceEvents = {\n  async onVoiceStateUpdate(oldState, newState) {\n    // Auto-create temporary voice channels\n    if (newState.channelId === TEMP_VOICE_CREATOR_ID) {\n      const tempChannel = await newState.guild.channels.create({\n        name: `${newState.member.displayName}'s Channel`,\n        type: 2, // Voice channel\n        parent: TEMP_VOICE_CATEGORY_ID,\n        userLimit: 10\n      });\n      \n      await newState.member.voice.setChannel(tempChannel);\n      \n      // Store temp channel info\n      tempChannels.set(tempChannel.id, {\n        ownerId: newState.member.id,\n        createdAt: Date.now()\n      });\n    }\n    \n    // Delete empty temporary channels\n    if (oldState.channel && tempChannels.has(oldState.channelId)) {\n      if (oldState.channel.members.size === 0) {\n        await oldState.channel.delete();\n        tempChannels.delete(oldState.channelId);\n      }\n    }\n  }\n};\n```\n\n### Event Logging and Analytics\n```javascript\n// Comprehensive logging system\nconst logEvents = {\n  async logMessage(type, data) {\n    const logChannel = discord.channels.cache.get(LOG_CHANNEL_ID);\n    \n    const logEmbed = {\n      title: `${type.toUpperCase()} Event`,\n      timestamp: new Date().toISOString(),\n      color: getLogColor(type)\n    };\n    \n    switch (type) {\n      case 'message_delete':\n        logEmbed.description = `Message deleted in ${data.channel}`,\n        logEmbed.fields = [\n          { name: 'Author', value: data.author.tag, inline: true },\n          { name: 'Content', value: data.content || '*No content*', inline: false }\n        ];\n        break;\n        \n      case 'member_ban':\n        logEmbed.description = `Member banned from server`;\n        logEmbed.fields = [\n          { name: 'User', value: data.user.tag, inline: true },\n          { name: 'Moderator', value: data.moderator?.tag || 'Unknown', inline: true },\n          { name: 'Reason', value: data.reason || 'No reason provided', inline: false }\n        ];\n        break;\n        \n      case 'role_update':\n        logEmbed.description = `Role ${data.role.name} was updated`;\n        logEmbed.fields = [\n          { name: 'Changes', value: data.changes.join('\\n'), inline: false }\n        ];\n        break;\n    }\n    \n    await logChannel.send({ embeds: [logEmbed] });\n  },\n  \n  async generateReport(period = 'week') {\n    const stats = await database.getServerStats(period);\n    \n    const reportEmbed = {\n      title: `Server Report - Last ${period}`,\n      fields: [\n        { name: 'New Members', value: stats.newMembers.toString(), inline: true },\n        { name: 'Messages Sent', value: stats.messages.toString(), inline: true },\n        { name: 'Active Users', value: stats.activeUsers.toString(), inline: true },\n        { name: 'Moderation Actions', value: stats.moderationActions.toString(), inline: true },\n        { name: 'Top Channel', value: stats.topChannel.name, inline: true },\n        { name: 'Growth Rate', value: `+${stats.growthPercentage}%`, inline: true }\n      ],\n      color: 0x0099ff,\n      timestamp: new Date().toISOString()\n    };\n    \n    return reportEmbed;\n  }\n};\n```\n\n## Integration Patterns\n\n### GitHub Integration\n```javascript\n// GitHub webhook handler\napp.post('/github-webhook', async (req, res) => {\n  const { action, repository, sender } = req.body;\n  \n  if (action === 'opened' && req.body.pull_request) {\n    const pr = req.body.pull_request;\n    \n    await discord.sendEmbed({\n      channelId: GITHUB_CHANNEL_ID,\n      embed: {\n        title: 'New Pull Request',\n        url: pr.html_url,\n        description: pr.title,\n        author: {\n          name: sender.login,\n          icon_url: sender.avatar_url,\n          url: sender.html_url\n        },\n        fields: [\n          { name: 'Repository', value: repository.full_name, inline: true },\n          { name: 'Changes', value: `+${pr.additions} -${pr.deletions}`, inline: true }\n        ],\n        color: 0x28a745\n      }\n    });\n  }\n});\n```\n\n### CI/CD Integration\n```javascript\n// Deployment notifications\nconst notifyDeployment = async (status, environment, version) => {\n  const color = status === 'success' ? 0x28a745 : 0xdc3545;\n  const emoji = status === 'success' ? '✅' : '❌';\n  \n  await discord.sendEmbed({\n    channelId: DEPLOYMENTS_CHANNEL_ID,\n    embed: {\n      title: `${emoji} Deployment ${status}`,\n      description: `Version ${version} to ${environment}`,\n      color: color,\n      timestamp: new Date().toISOString()\n    }\n  });\n};\n```",
      "configuration": {
        "requiresAuth": true,
        "authType": "bot_token",
        "permissions": [
          "send_messages",
          "manage_messages",
          "manage_roles",
          "ban_members"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-discord",
      "documentationUrl": "https://docs.claude.ai/mcp/discord",
      "source": "community",
      "slug": "discord-integration",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/discord-integration"
    },
    {
      "title": "Docker MCP Server",
      "description": "Manage Docker containers, images, and services directly through Claude with comprehensive Docker API integration",
      "category": "mcp",
      "author": "JSONbored",
      "dateAdded": "2025-09-16",
      "tags": [
        "docker",
        "containers",
        "devops",
        "orchestration",
        "deployment"
      ],
      "content": "The Docker MCP Server provides Claude with complete Docker management capabilities. Features include:\n\n## Core Capabilities\n\n### Container Management\n- List, start, stop, and restart containers\n- Create containers from images with custom configurations\n- Execute commands inside running containers\n- Stream container logs in real-time\n- Monitor container resource usage (CPU, memory, network)\n- Manage container networks and volumes\n\n### Image Operations\n- Pull, build, and push Docker images\n- List and inspect image details\n- Tag and remove images\n- Build images from Dockerfiles\n- Multi-stage build support\n- Image layer analysis and optimization\n\n### Docker Compose Integration\n- Manage multi-container applications\n- Start, stop, and restart compose services\n- Scale services up or down\n- View service logs and status\n- Update service configurations\n- Handle environment-specific overrides\n\n### Volume & Network Management\n- Create, list, and remove volumes\n- Mount volumes to containers\n- Backup and restore volume data\n- Create custom networks\n- Connect containers to networks\n- Inspect network configurations\n\n### Registry Operations\n- Push and pull from Docker registries\n- Manage registry authentication\n- Search for images in registries\n- Handle private registry operations\n- Image vulnerability scanning\n\n## Installation\n\n```bash\nnpm install @docker/mcp-server\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"docker\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@docker/mcp-server\"],\n      \"env\": {\n        \"DOCKER_HOST\": \"unix:///var/run/docker.sock\",\n        \"DOCKER_API_VERSION\": \"1.43\"\n      }\n    }\n  }\n}\n```\n\n## Environment Variables\n\n```bash\n# Docker daemon connection\nDOCKER_HOST=unix:///var/run/docker.sock\n# For remote Docker\nDOCKER_HOST=tcp://remote-docker:2376\nDOCKER_TLS_VERIFY=1\nDOCKER_CERT_PATH=/path/to/certs\n\n# API version\nDOCKER_API_VERSION=1.43\n\n# Registry credentials\nDOCKER_REGISTRY_USER=myuser\nDOCKER_REGISTRY_PASSWORD=mypass\n```\n\n## Security Features\n- Secure Docker daemon communication\n- TLS certificate validation\n- Registry authentication management\n- Container security scanning\n- Resource limit enforcement\n- Network isolation controls\n\n## Usage Examples\n\n### Container Operations\n```bash\n# Run a new container\ndocker run -d --name web-server -p 8080:80 nginx:latest\n\n# Execute command in container\ndocker exec -it web-server bash\n\n# View container logs\ndocker logs -f web-server\n```\n\n### Image Building\n```dockerfile\n# Multi-stage Dockerfile example\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nFROM node:18-alpine AS runtime\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY . .\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\n```\n\n### Docker Compose\n```yaml\nversion: '3.8'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n    depends_on:\n      - db\n  \n  db:\n    image: postgres:15\n    environment:\n      - POSTGRES_DB=myapp\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=pass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n```\n\n## Monitoring & Debugging\n- Real-time container metrics\n- Log aggregation and analysis\n- Health check monitoring\n- Performance profiling\n- Resource usage alerts\n- Container lifecycle events\n\n## Advanced Features\n- Docker Swarm service management\n- Multi-architecture image building\n- BuildKit advanced features\n- Container scanning and compliance\n- Automated cleanup and optimization\n- Integration with CI/CD pipelines",
      "configuration": {
        "requiresAuth": false,
        "permissions": [
          "containers",
          "images",
          "volumes",
          "networks"
        ],
        "dockerVersion": ">=20.10.0"
      },
      "githubUrl": "https://github.com/docker/docker-mcp",
      "documentationUrl": "https://docs.docker.com/engine/api/",
      "source": "community",
      "slug": "docker-mcp",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/docker-mcp"
    },
    {
      "title": "Filesystem MCP Server",
      "description": "Provides secure file system operations allowing Claude to read, write, and manage files with proper permissions",
      "category": "mcp",
      "author": "anthropic",
      "dateAdded": "2025-09-15",
      "tags": [
        "filesystem",
        "files",
        "directories",
        "io",
        "storage"
      ],
      "content": "The Filesystem MCP Server enables Claude to interact with your local file system securely.\n\n## Features\n\n### File Operations\n- **Read Files**: Read text and binary files\n- **Write Files**: Create and update files\n- **Delete Files**: Remove files safely\n- **Move/Rename**: Relocate or rename files\n- **Copy Files**: Duplicate files and directories\n\n### Directory Management\n- **List Contents**: Browse directory structures\n- **Create Directories**: Make new folders\n- **Remove Directories**: Delete empty or full directories\n- **Tree View**: Hierarchical directory listing\n\n### Advanced Features\n- **Glob Patterns**: Search files using wildcards\n- **File Metadata**: Get size, permissions, timestamps\n- **Symlinks**: Create and manage symbolic links\n- **Watch Files**: Monitor file changes in real-time\n\n## Installation\n\n```bash\n# Using npm\nnpm install -g @modelcontextprotocol/server-filesystem\n\n# Add to Claude Code\nclaude mcp add filesystem npx -y @modelcontextprotocol/server-filesystem /path/to/allowed/directory\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/home/user/projects\"],\n      \"env\": {\n        \"FILESYSTEM_READ_ONLY\": \"false\",\n        \"FILESYSTEM_HIDDEN_FILES\": \"true\"\n      }\n    }\n  }\n}\n```\n\n## Security Considerations\n\n- Restrict access to specific directories\n- Consider read-only mode for sensitive areas\n- Use permission rules to control operations\n- Audit file operations with hooks\n\n## Usage Examples\n\n```\n# List files\n> \"Show me all Python files in the src directory\"\n\n# Read file\n> \"Read the contents of config.json\"\n\n# Create file\n> \"Create a new README.md with project documentation\"\n\n# Search files\n> \"Find all files containing 'TODO' comments\"\n```",
      "configuration": {
        "requiresAuth": false,
        "permissions": [
          "read",
          "write",
          "delete"
        ],
        "defaultPath": "~/projects"
      },
      "githubUrl": "https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem",
      "documentationUrl": "https://docs.anthropic.com/en/docs/claude-code/mcp",
      "source": "community",
      "slug": "filesystem-mcp",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/filesystem-mcp"
    },
    {
      "title": "GitHub Integration MCP",
      "description": "Connect Claude to GitHub for repository management, issues, and pull requests",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "github",
        "git",
        "version-control",
        "integration"
      ],
      "content": "The GitHub Integration MCP Server enables Claude to interact with GitHub repositories directly. Features include:\n\n## Core Capabilities\n\n### Repository Management\n- Clone and manage repositories\n- Create branches and tags\n- View commit history and diffs\n- Manage repository settings\n\n### Issues & Projects\n- Create, update, and close issues\n- Manage project boards\n- Add labels and milestones\n- Assign team members\n\n### Pull Requests\n- Create and review pull requests\n- Add comments and reviews\n- Merge with various strategies\n- Run status checks\n\n### Workflow Automation\n- Trigger GitHub Actions\n- Monitor workflow runs\n- Manage secrets and variables\n- Configure webhooks\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-github\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-github\"],\n      \"env\": {\n        \"GITHUB_TOKEN\": \"your-github-token\"\n      }\n    }\n  }\n}\n```",
      "configuration": {
        "requiresAuth": true,
        "authType": "token",
        "permissions": [
          "repo",
          "issues",
          "pull_requests"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-github",
      "documentationUrl": "https://docs.claude.ai/mcp/github",
      "source": "community",
      "slug": "github-integration",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/github-integration"
    },
    {
      "title": "Jira Integration MCP",
      "description": "Complete Jira integration for project management, issue tracking, and agile workflow automation",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "jira",
        "project-management",
        "agile",
        "scrum",
        "kanban",
        "tracking"
      ],
      "content": "The Jira Integration MCP Server enables comprehensive project management through Atlassian Jira, supporting issue tracking, sprint management, and agile workflows.\n\n## Core Capabilities\n\n### Issue Management\n- Create, update, and delete issues\n- Manage issue types (Story, Bug, Task, Epic)\n- Set priority, status, and assignee\n- Add comments and work logs\n- Handle attachments and links\n- Bulk operations for multiple issues\n\n### Project Administration\n- Create and configure projects\n- Manage project permissions and roles\n- Configure issue types and workflows\n- Set up custom fields and screens\n- Manage project components and versions\n\n### Agile & Sprint Management\n- Create and manage sprints\n- Sprint planning and backlog grooming\n- Burndown chart generation\n- Velocity tracking and reporting\n- Epic and story point management\n\n### Advanced Workflows\n- Custom workflow transitions\n- Automated rule execution\n- Approval processes\n- Integration triggers\n- Notification management\n\n### Reporting & Analytics\n- Generate custom reports\n- Time tracking analysis\n- Sprint retrospective data\n- Team performance metrics\n- Issue resolution trends\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-jira\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"jira\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-jira\"],\n      \"env\": {\n        \"JIRA_HOST\": \"https://yourcompany.atlassian.net\",\n        \"JIRA_USERNAME\": \"your.email@company.com\",\n        \"JIRA_API_TOKEN\": \"your-api-token\",\n        \"JIRA_PROJECT_KEY\": \"PROJ\"\n      }\n    }\n  }\n}\n```\n\n## Authentication Setup\n\n### API Token (Recommended)\n1. Go to https://id.atlassian.com/manage-profile/security/api-tokens\n2. Click \"Create API token\"\n3. Copy the token and use with your email\n\n### OAuth 2.0 (Advanced)\n```json\n{\n  \"env\": {\n    \"JIRA_HOST\": \"https://yourcompany.atlassian.net\",\n    \"JIRA_CLIENT_ID\": \"your-oauth-client-id\",\n    \"JIRA_CLIENT_SECRET\": \"your-oauth-client-secret\",\n    \"JIRA_REDIRECT_URI\": \"http://localhost:8080/callback\"\n  }\n}\n```\n\n## Usage Examples\n\n### Issue Creation and Management\n```javascript\n// Create a new story\nconst story = await jira.createIssue({\n  fields: {\n    project: { key: 'PROJ' },\n    summary: 'Implement user authentication system',\n    description: {\n      type: 'doc',\n      version: 1,\n      content: [\n        {\n          type: 'paragraph',\n          content: [\n            {\n              type: 'text',\n              text: 'As a user, I want to securely log into the application so that I can access my personal data.'\n            }\n          ]\n        },\n        {\n          type: 'heading',\n          attrs: { level: 3 },\n          content: [{ type: 'text', text: 'Acceptance Criteria' }]\n        },\n        {\n          type: 'bulletList',\n          content: [\n            {\n              type: 'listItem',\n              content: [{\n                type: 'paragraph',\n                content: [{ type: 'text', text: 'Users can login with email and password' }]\n              }]\n            },\n            {\n              type: 'listItem',\n              content: [{\n                type: 'paragraph',\n                content: [{ type: 'text', text: 'Password must meet security requirements' }]\n              }]\n            },\n            {\n              type: 'listItem',\n              content: [{\n                type: 'paragraph',\n                content: [{ type: 'text', text: 'Support for two-factor authentication' }]\n              }]\n            }\n          ]\n        }\n      ]\n    },\n    issuetype: { name: 'Story' },\n    priority: { name: 'High' },\n    assignee: { emailAddress: 'developer@company.com' },\n    labels: ['authentication', 'security', 'backend'],\n    customfield_10016: 8, // Story Points\n    components: [{ name: 'Backend' }, { name: 'Security' }],\n    fixVersions: [{ name: '2.1.0' }]\n  }\n});\n\n// Update issue status\nconst transition = await jira.transitionIssue({\n  issueIdOrKey: 'PROJ-123',\n  transition: {\n    id: '31' // Transition ID for \"In Progress\"\n  },\n  fields: {\n    assignee: { emailAddress: 'developer@company.com' }\n  }\n});\n\n// Add comment with mention\nconst comment = await jira.addComment({\n  issueIdOrKey: 'PROJ-123',\n  body: {\n    type: 'doc',\n    version: 1,\n    content: [\n      {\n        type: 'paragraph',\n        content: [\n          {\n            type: 'text',\n            text: 'Started implementation. '\n          },\n          {\n            type: 'mention',\n            attrs: {\n              id: '5b10ac8d82e05b22cc7d4ef5',\n              text: '@john.doe'\n            }\n          },\n          {\n            type: 'text',\n            text: ' please review the security requirements.'\n          }\n        ]\n      }\n    ]\n  }\n});\n```\n\n### Sprint Management\n```javascript\n// Create new sprint\nconst sprint = await jira.createSprint({\n  name: 'Sprint 23 - Authentication Features',\n  startDate: '2025-09-16T09:00:00.000Z',\n  endDate: '2025-09-30T17:00:00.000Z',\n  originBoardId: 84,\n  goal: 'Complete user authentication system and security improvements'\n});\n\n// Add issues to sprint\nconst addToSprint = await jira.moveIssuesToSprint({\n  sprintId: sprint.id,\n  issues: ['PROJ-123', 'PROJ-124', 'PROJ-125']\n});\n\n// Start sprint\nconst startSprint = await jira.updateSprint({\n  sprintId: sprint.id,\n  name: sprint.name,\n  state: 'active',\n  startDate: '2025-09-16T09:00:00.000Z',\n  endDate: '2025-09-30T17:00:00.000Z'\n});\n\n// Get sprint report\nconst sprintReport = await jira.getSprintReport({\n  rapidViewId: 84,\n  sprintId: sprint.id\n});\n```\n\n### Epic and Story Hierarchy\n```javascript\n// Create epic\nconst epic = await jira.createIssue({\n  fields: {\n    project: { key: 'PROJ' },\n    summary: 'User Management System',\n    description: 'Complete user management functionality including authentication, authorization, and profile management.',\n    issuetype: { name: 'Epic' },\n    customfield_10011: 'USER-MGMT', // Epic Name\n    labels: ['user-management', 'phase-1']\n  }\n});\n\n// Link story to epic\nconst linkToEpic = await jira.updateIssue({\n  issueIdOrKey: 'PROJ-123',\n  fields: {\n    customfield_10014: epic.key // Epic Link\n  }\n});\n\n// Create subtask\nconst subtask = await jira.createIssue({\n  fields: {\n    project: { key: 'PROJ' },\n    parent: { key: 'PROJ-123' },\n    summary: 'Create login API endpoint',\n    description: 'Implement POST /api/auth/login endpoint with validation',\n    issuetype: { name: 'Sub-task' },\n    assignee: { emailAddress: 'backend.dev@company.com' }\n  }\n});\n```\n\n### Advanced Querying with JQL\n```javascript\n// Complex JQL queries\nconst searchResults = await jira.searchForIssues({\n  jql: `\n    project = PROJ AND \n    sprint in openSprints() AND \n    assignee in (currentUser(), 'developer@company.com') AND \n    status NOT IN (Done, Closed) AND \n    created >= -2w\n    ORDER BY priority DESC, created ASC\n  `,\n  maxResults: 50,\n  fields: [\n    'summary',\n    'status',\n    'assignee',\n    'priority',\n    'created',\n    'updated',\n    'customfield_10016' // Story Points\n  ]\n});\n\n// Get issues for specific epic\nconst epicIssues = await jira.searchForIssues({\n  jql: `\"Epic Link\" = PROJ-100 AND status != Done`,\n  fields: ['summary', 'status', 'assignee', 'progress']\n});\n\n// Burndown data query\nconst burndownData = await jira.searchForIssues({\n  jql: `\n    sprint = 23 AND \n    project = PROJ AND \n    type in (Story, Bug, Task)\n  `,\n  fields: ['created', 'resolutiondate', 'customfield_10016'],\n  expand: ['changelog']\n});\n```\n\n### Automation and Workflows\n```javascript\n// Create automation rule\nconst automationRule = {\n  name: 'Auto-assign based on component',\n  trigger: {\n    type: 'issue_created',\n    configuration: {\n      projects: ['PROJ']\n    }\n  },\n  conditions: [\n    {\n      type: 'component_condition',\n      configuration: {\n        components: ['Backend']\n      }\n    }\n  ],\n  actions: [\n    {\n      type: 'assign_issue',\n      configuration: {\n        assignee: 'backend.team@company.com'\n      }\n    },\n    {\n      type: 'add_label',\n      configuration: {\n        labels: ['auto-assigned']\n      }\n    }\n  ]\n};\n\n// Bulk update issues\nconst bulkUpdate = await jira.bulkUpdateIssues({\n  issueIds: ['PROJ-123', 'PROJ-124', 'PROJ-125'],\n  operations: [\n    {\n      operation: 'set',\n      path: 'fields.priority',\n      value: { name: 'High' }\n    },\n    {\n      operation: 'add',\n      path: 'fields.labels',\n      value: 'urgent'\n    }\n  ]\n});\n```\n\n### Reporting and Analytics\n```javascript\n// Generate team velocity report\nconst velocityReport = await jira.generateReport({\n  type: 'velocity',\n  rapidViewId: 84,\n  sprints: 10 // Last 10 sprints\n});\n\n// Time tracking summary\nconst timeTracking = await jira.getTimeTrackingReport({\n  projectKey: 'PROJ',\n  startDate: '2025-09-01',\n  endDate: '2025-09-30',\n  groupBy: 'assignee'\n});\n\n// Custom dashboard data\nconst dashboardData = {\n  openIssues: await jira.getIssueCount({ jql: 'project = PROJ AND status != Done' }),\n  inProgress: await jira.getIssueCount({ jql: 'project = PROJ AND status = \"In Progress\"' }),\n  blockedIssues: await jira.getIssueCount({ jql: 'project = PROJ AND status = Blocked' }),\n  avgResolutionTime: await jira.getAverageResolutionTime({ projectKey: 'PROJ', days: 30 })\n};\n```\n\n## Integration Patterns\n\n### GitHub Integration\n```javascript\n// Create issue from GitHub PR\nconst createFromPR = async (prData) => {\n  const issue = await jira.createIssue({\n    fields: {\n      project: { key: 'PROJ' },\n      summary: `Review PR: ${prData.title}`,\n      description: `GitHub PR #${prData.number}\\n${prData.html_url}\\n\\n${prData.body}`,\n      issuetype: { name: 'Task' },\n      labels: ['code-review', 'github'],\n      customfield_10037: prData.html_url // GitHub URL field\n    }\n  });\n  \n  return issue;\n};\n```\n\n### Slack Notifications\n```javascript\n// Send Jira updates to Slack\nconst notifySlack = async (issueKey, action) => {\n  const issue = await jira.getIssue({ issueIdOrKey: issueKey });\n  \n  const slackMessage = {\n    channel: '#development',\n    text: `Issue ${action}: ${issue.fields.summary}`,\n    attachments: [{\n      color: getStatusColor(issue.fields.status.name),\n      fields: [\n        { title: 'Assignee', value: issue.fields.assignee?.displayName || 'Unassigned', short: true },\n        { title: 'Priority', value: issue.fields.priority.name, short: true },\n        { title: 'Status', value: issue.fields.status.name, short: true },\n        { title: 'Story Points', value: issue.fields.customfield_10016 || 'Not estimated', short: true }\n      ],\n      actions: [{\n        type: 'button',\n        text: 'View in Jira',\n        url: `https://yourcompany.atlassian.net/browse/${issueKey}`\n      }]\n    }]\n  };\n  \n  await slack.postMessage(slackMessage);\n};\n```\n\n## Best Practices\n\n### Issue Templates\n```javascript\n// Standardized issue templates\nconst templates = {\n  bug: {\n    summary: '[BUG] {Brief description}',\n    description: `\n## Bug Description\n{Detailed description of the bug}\n\n## Steps to Reproduce\n1. {Step 1}\n2. {Step 2}\n3. {Step 3}\n\n## Expected Behavior\n{What should happen}\n\n## Actual Behavior\n{What actually happens}\n\n## Environment\n- Browser: {browser and version}\n- OS: {operating system}\n- App Version: {version}\n\n## Additional Context\n{Any additional information}\n    `,\n    issuetype: { name: 'Bug' },\n    priority: { name: 'Medium' },\n    labels: ['bug', 'needs-investigation']\n  },\n  \n  feature: {\n    summary: '[FEATURE] {Feature name}',\n    description: `\n## User Story\nAs a {type of user}, I want {goal} so that {reason}.\n\n## Acceptance Criteria\n- [ ] {Criterion 1}\n- [ ] {Criterion 2}\n- [ ] {Criterion 3}\n\n## Technical Requirements\n{Any technical constraints or requirements}\n\n## Design Notes\n{Links to designs or mockups}\n    `,\n    issuetype: { name: 'Story' },\n    priority: { name: 'Medium' },\n    labels: ['feature', 'needs-estimation']\n  }\n};\n```\n\n### Workflow Optimization\n- Use consistent naming conventions\n- Implement proper issue linking\n- Regular sprint retrospectives\n- Automated status updates\n- Clear definition of done criteria",
      "configuration": {
        "requiresAuth": true,
        "authType": "api_token",
        "permissions": [
          "read",
          "write",
          "admin"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-jira",
      "documentationUrl": "https://docs.claude.ai/mcp/jira",
      "source": "community",
      "slug": "jira-integration",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/jira-integration"
    },
    {
      "title": "Kubernetes Management MCP",
      "description": "Comprehensive Kubernetes cluster management, deployment automation, and container orchestration",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "kubernetes",
        "k8s",
        "container",
        "orchestration",
        "deployment",
        "devops"
      ],
      "content": "The Kubernetes Management MCP Server provides comprehensive cluster management capabilities, enabling deployment automation, resource monitoring, and container orchestration through Claude.\n\n## Core Capabilities\n\n### Cluster Management\n- Node status and resource monitoring\n- Namespace management and isolation\n- RBAC (Role-Based Access Control) configuration\n- Network policy management\n- Storage class and persistent volume operations\n\n### Workload Management\n- **Deployments**: Application lifecycle management\n- **StatefulSets**: Stateful application orchestration\n- **DaemonSets**: Node-level service deployment\n- **Jobs & CronJobs**: Batch processing and scheduled tasks\n- **Pods**: Direct container management\n\n### Service & Networking\n- Service discovery and load balancing\n- Ingress controller configuration\n- ConfigMap and Secret management\n- Network policy enforcement\n- Service mesh integration\n\n### Scaling & Resource Management\n- Horizontal Pod Autoscaling (HPA)\n- Vertical Pod Autoscaling (VPA)\n- Cluster autoscaling\n- Resource quotas and limits\n- Quality of Service (QoS) management\n\n### Monitoring & Observability\n- Pod and container metrics\n- Event tracking and alerting\n- Log aggregation and analysis\n- Health checks and readiness probes\n- Performance monitoring\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-kubernetes\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"kubernetes\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-kubernetes\"],\n      \"env\": {\n        \"KUBECONFIG\": \"/path/to/kubeconfig\",\n        \"K8S_CLUSTER_URL\": \"https://kubernetes.default.svc\",\n        \"K8S_NAMESPACE\": \"default\",\n        \"K8S_TOKEN\": \"your-service-account-token\"\n      }\n    }\n  }\n}\n```\n\n## Authentication Methods\n\n### Method 1: Kubeconfig File\n```json\n{\n  \"env\": {\n    \"KUBECONFIG\": \"/home/user/.kube/config\"\n  }\n}\n```\n\n### Method 2: Service Account Token\n```json\n{\n  \"env\": {\n    \"K8S_CLUSTER_URL\": \"https://my-cluster.example.com:6443\",\n    \"K8S_TOKEN\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjEyMyJ9...\",\n    \"K8S_CA_CERT\": \"/path/to/ca.crt\"\n  }\n}\n```\n\n### Method 3: In-Cluster Configuration\n```json\n{\n  \"env\": {\n    \"K8S_IN_CLUSTER\": \"true\"\n  }\n}\n```\n\n## Usage Examples\n\n### Deployment Management\n```yaml\n# Create deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-application\n  namespace: production\n  labels:\n    app: web-app\n    version: v1.2.0\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n        version: v1.2.0\n    spec:\n      containers:\n      - name: web-app\n        image: myregistry/web-app:1.2.0\n        ports:\n        - containerPort: 8080\n          name: http\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: REDIS_URL\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: redis-url\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n      imagePullSecrets:\n      - name: registry-secret\n```\n\n```javascript\n// Deploy application using JavaScript\nconst deployment = await k8s.createDeployment({\n  metadata: {\n    name: 'web-application',\n    namespace: 'production',\n    labels: {\n      app: 'web-app',\n      version: 'v1.2.0'\n    }\n  },\n  spec: {\n    replicas: 3,\n    selector: {\n      matchLabels: { app: 'web-app' }\n    },\n    template: {\n      metadata: {\n        labels: {\n          app: 'web-app',\n          version: 'v1.2.0'\n        }\n      },\n      spec: {\n        containers: [{\n          name: 'web-app',\n          image: 'myregistry/web-app:1.2.0',\n          ports: [{ containerPort: 8080, name: 'http' }],\n          env: [\n            {\n              name: 'DATABASE_URL',\n              valueFrom: {\n                secretKeyRef: {\n                  name: 'app-secrets',\n                  key: 'database-url'\n                }\n              }\n            }\n          ],\n          resources: {\n            requests: { memory: '256Mi', cpu: '250m' },\n            limits: { memory: '512Mi', cpu: '500m' }\n          },\n          livenessProbe: {\n            httpGet: { path: '/health', port: 8080 },\n            initialDelaySeconds: 30,\n            periodSeconds: 10\n          }\n        }]\n      }\n    }\n  }\n});\n\n// Update deployment (rolling update)\nconst updateDeployment = await k8s.patchDeployment('web-application', 'production', {\n  spec: {\n    template: {\n      spec: {\n        containers: [{\n          name: 'web-app',\n          image: 'myregistry/web-app:1.3.0' // New version\n        }]\n      }\n    }\n  }\n});\n\n// Scale deployment\nconst scaleDeployment = await k8s.scaleDeployment('web-application', 'production', 5);\n\n// Get deployment status\nconst deploymentStatus = await k8s.getDeployment('web-application', 'production');\nconsole.log('Ready replicas:', deploymentStatus.status.readyReplicas);\nconsole.log('Updated replicas:', deploymentStatus.status.updatedReplicas);\n```\n\n### Service and Networking\n```yaml\n# Service configuration\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-app-service\n  namespace: production\n  labels:\n    app: web-app\nspec:\n  selector:\n    app: web-app\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n  type: ClusterIP\n---\n# Ingress configuration\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-app-ingress\n  namespace: production\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n    nginx.ingress.kubernetes.io/rate-limit: \"100\"\nspec:\n  tls:\n  - hosts:\n    - api.mycompany.com\n    secretName: web-app-tls\n  rules:\n  - host: api.mycompany.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app-service\n            port:\n              number: 80\n```\n\n```javascript\n// Create service\nconst service = await k8s.createService({\n  metadata: {\n    name: 'web-app-service',\n    namespace: 'production'\n  },\n  spec: {\n    selector: { app: 'web-app' },\n    ports: [{\n      name: 'http',\n      port: 80,\n      targetPort: 8080,\n      protocol: 'TCP'\n    }],\n    type: 'ClusterIP'\n  }\n});\n\n// Create ingress\nconst ingress = await k8s.createIngress({\n  metadata: {\n    name: 'web-app-ingress',\n    namespace: 'production',\n    annotations: {\n      'nginx.ingress.kubernetes.io/rewrite-target': '/',\n      'cert-manager.io/cluster-issuer': 'letsencrypt-prod'\n    }\n  },\n  spec: {\n    tls: [{\n      hosts: ['api.mycompany.com'],\n      secretName: 'web-app-tls'\n    }],\n    rules: [{\n      host: 'api.mycompany.com',\n      http: {\n        paths: [{\n          path: '/',\n          pathType: 'Prefix',\n          backend: {\n            service: {\n              name: 'web-app-service',\n              port: { number: 80 }\n            }\n          }\n        }]\n      }\n    }]\n  }\n});\n```\n\n### ConfigMaps and Secrets\n```javascript\n// Create ConfigMap\nconst configMap = await k8s.createConfigMap({\n  metadata: {\n    name: 'app-config',\n    namespace: 'production'\n  },\n  data: {\n    'redis-url': 'redis://redis-service:6379',\n    'log-level': 'info',\n    'max-connections': '100',\n    'config.json': JSON.stringify({\n      features: {\n        enableNewUI: true,\n        enableAnalytics: true,\n        enableCaching: true\n      },\n      limits: {\n        maxFileSize: '10MB',\n        requestTimeout: 30000\n      }\n    })\n  }\n});\n\n// Create Secret\nconst secret = await k8s.createSecret({\n  metadata: {\n    name: 'app-secrets',\n    namespace: 'production'\n  },\n  type: 'Opaque',\n  data: {\n    'database-url': Buffer.from('postgresql://user:pass@db:5432/myapp').toString('base64'),\n    'api-key': Buffer.from('sk-1234567890abcdef').toString('base64'),\n    'jwt-secret': Buffer.from('super-secret-jwt-key').toString('base64')\n  }\n});\n\n// Create TLS Secret\nconst tlsSecret = await k8s.createSecret({\n  metadata: {\n    name: 'web-app-tls',\n    namespace: 'production'\n  },\n  type: 'kubernetes.io/tls',\n  data: {\n    'tls.crt': certData, // Base64 encoded certificate\n    'tls.key': keyData   // Base64 encoded private key\n  }\n});\n```\n\n### Autoscaling Configuration\n```yaml\n# Horizontal Pod Autoscaler\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: web-app-hpa\n  namespace: production\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: web-application\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n      - type: Percent\n        value: 50\n        periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 60\n      policies:\n      - type: Percent\n        value: 100\n        periodSeconds: 15\n```\n\n```javascript\n// Create HPA\nconst hpa = await k8s.createHorizontalPodAutoscaler({\n  metadata: {\n    name: 'web-app-hpa',\n    namespace: 'production'\n  },\n  spec: {\n    scaleTargetRef: {\n      apiVersion: 'apps/v1',\n      kind: 'Deployment',\n      name: 'web-application'\n    },\n    minReplicas: 3,\n    maxReplicas: 20,\n    metrics: [\n      {\n        type: 'Resource',\n        resource: {\n          name: 'cpu',\n          target: {\n            type: 'Utilization',\n            averageUtilization: 70\n          }\n        }\n      },\n      {\n        type: 'Resource',\n        resource: {\n          name: 'memory',\n          target: {\n            type: 'Utilization',\n            averageUtilization: 80\n          }\n        }\n      }\n    ]\n  }\n});\n```\n\n### StatefulSet for Databases\n```yaml\n# Redis StatefulSet\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: redis-cluster\n  namespace: production\nspec:\n  serviceName: redis-headless\n  replicas: 3\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n      - name: redis\n        image: redis:7-alpine\n        ports:\n        - containerPort: 6379\n          name: redis\n        - containerPort: 16379\n          name: cluster\n        command:\n        - redis-server\n        args:\n        - /config/redis.conf\n        volumeMounts:\n        - name: redis-config\n          mountPath: /config\n        - name: redis-data\n          mountPath: /data\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n      volumes:\n      - name: redis-config\n        configMap:\n          name: redis-config\n  volumeClaimTemplates:\n  - metadata:\n      name: redis-data\n    spec:\n      accessModes: [\"ReadWriteOnce\"]\n      storageClassName: fast-ssd\n      resources:\n        requests:\n          storage: 10Gi\n```\n\n### Job and CronJob Examples\n```javascript\n// Database migration job\nconst migrationJob = await k8s.createJob({\n  metadata: {\n    name: 'db-migration-v120',\n    namespace: 'production'\n  },\n  spec: {\n    template: {\n      spec: {\n        restartPolicy: 'Never',\n        containers: [{\n          name: 'migration',\n          image: 'myregistry/migration-tool:1.2.0',\n          env: [\n            {\n              name: 'DATABASE_URL',\n              valueFrom: {\n                secretKeyRef: {\n                  name: 'app-secrets',\n                  key: 'database-url'\n                }\n              }\n            }\n          ],\n          command: ['./migrate.sh'],\n          args: ['--version', '1.2.0']\n        }]\n      }\n    },\n    backoffLimit: 3,\n    activeDeadlineSeconds: 3600\n  }\n});\n\n// Backup CronJob\nconst backupCronJob = await k8s.createCronJob({\n  metadata: {\n    name: 'database-backup',\n    namespace: 'production'\n  },\n  spec: {\n    schedule: '0 2 * * *', // Daily at 2 AM\n    jobTemplate: {\n      spec: {\n        template: {\n          spec: {\n            restartPolicy: 'OnFailure',\n            containers: [{\n              name: 'backup',\n              image: 'myregistry/backup-tool:latest',\n              env: [\n                {\n                  name: 'DATABASE_URL',\n                  valueFrom: {\n                    secretKeyRef: {\n                      name: 'app-secrets',\n                      key: 'database-url'\n                    }\n                  }\n                },\n                {\n                  name: 'S3_BUCKET',\n                  value: 'my-backups-bucket'\n                }\n              ],\n              command: ['./backup.sh']\n            }]\n          }\n        }\n      }\n    },\n    successfulJobsHistoryLimit: 3,\n    failedJobsHistoryLimit: 1\n  }\n});\n```\n\n### Monitoring and Observability\n```javascript\n// Get cluster metrics\nconst clusterMetrics = await k8s.getClusterMetrics();\nconsole.log('Cluster CPU usage:', clusterMetrics.cpu.percentage);\nconsole.log('Cluster memory usage:', clusterMetrics.memory.percentage);\n\n// Get pod metrics\nconst podMetrics = await k8s.getPodMetrics('production');\npodMetrics.forEach(pod => {\n  console.log(`Pod ${pod.name}: CPU ${pod.cpu}, Memory ${pod.memory}`);\n});\n\n// Get events\nconst events = await k8s.getEvents('production', {\n  fieldSelector: 'involvedObject.kind=Pod',\n  timeWindow: '1h'\n});\n\n// Watch pod status changes\nconst podWatcher = k8s.watchPods('production', (event) => {\n  const { type, object: pod } = event;\n  console.log(`Pod ${pod.metadata.name} ${type}: ${pod.status.phase}`);\n  \n  if (type === 'MODIFIED' && pod.status.phase === 'Failed') {\n    // Handle failed pod\n    handlePodFailure(pod);\n  }\n});\n\n// Get logs\nconst logs = await k8s.getPodLogs('web-application-abc123', 'production', {\n  container: 'web-app',\n  tailLines: 100,\n  since: '1h'\n});\n\n// Stream logs\nconst logStream = k8s.streamPodLogs('web-application-abc123', 'production', {\n  follow: true,\n  container: 'web-app'\n});\n\nlogStream.on('data', (chunk) => {\n  console.log('Log:', chunk.toString());\n});\n```\n\n### Resource Management\n```yaml\n# Namespace with resource quotas\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: development\n  labels:\n    environment: dev\n---\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: dev-quota\n  namespace: development\nspec:\n  hard:\n    requests.cpu: \"4\"\n    requests.memory: 8Gi\n    limits.cpu: \"8\"\n    limits.memory: 16Gi\n    persistentvolumeclaims: \"10\"\n    pods: \"20\"\n    services: \"10\"\n---\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: dev-limits\n  namespace: development\nspec:\n  limits:\n  - type: Container\n    default:\n      cpu: \"500m\"\n      memory: \"512Mi\"\n    defaultRequest:\n      cpu: \"100m\"\n      memory: \"128Mi\"\n    max:\n      cpu: \"2\"\n      memory: \"2Gi\"\n    min:\n      cpu: \"50m\"\n      memory: \"64Mi\"\n```\n\n## Best Practices\n\n### Security\n```yaml\n# Pod Security Context\nsecurityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  runAsGroup: 1000\n  fsGroup: 1000\n  seccompProfile:\n    type: RuntimeDefault\ncontainers:\n- name: web-app\n  securityContext:\n    allowPrivilegeEscalation: false\n    readOnlyRootFilesystem: true\n    capabilities:\n      drop:\n      - ALL\n```\n\n### Resource Optimization\n```javascript\n// Resource recommendations\nconst getResourceRecommendations = async (deploymentName, namespace) => {\n  const metrics = await k8s.getPodMetrics(namespace, {\n    labelSelector: `app=${deploymentName}`\n  });\n  \n  const recommendations = {\n    cpu: {\n      request: Math.ceil(Math.max(...metrics.map(m => m.cpu.avg)) * 1.1) + 'm',\n      limit: Math.ceil(Math.max(...metrics.map(m => m.cpu.max)) * 1.2) + 'm'\n    },\n    memory: {\n      request: Math.ceil(Math.max(...metrics.map(m => m.memory.avg)) * 1.1) + 'Mi',\n      limit: Math.ceil(Math.max(...metrics.map(m => m.memory.max)) * 1.2) + 'Mi'\n    }\n  };\n  \n  return recommendations;\n};\n```\n\n### Deployment Strategies\n```javascript\n// Blue-Green Deployment\nconst blueGreenDeploy = async (appName, newVersion) => {\n  // Deploy green version\n  await k8s.createDeployment({\n    metadata: { name: `${appName}-green` },\n    spec: {\n      template: {\n        spec: {\n          containers: [{ image: `${appName}:${newVersion}` }]\n        }\n      }\n    }\n  });\n  \n  // Wait for readiness\n  await k8s.waitForDeploymentReady(`${appName}-green`, 'production');\n  \n  // Switch traffic\n  await k8s.patchService(`${appName}-service`, 'production', {\n    spec: {\n      selector: { app: `${appName}-green` }\n    }\n  });\n  \n  // Cleanup old version after verification\n  setTimeout(async () => {\n    await k8s.deleteDeployment(`${appName}-blue`, 'production');\n  }, 300000); // 5 minutes\n};\n```",
      "configuration": {
        "requiresAuth": true,
        "authType": "kubeconfig",
        "permissions": [
          "cluster-admin",
          "view",
          "edit"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-kubernetes",
      "documentationUrl": "https://docs.claude.ai/mcp/kubernetes",
      "source": "community",
      "slug": "kubernetes-management",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/kubernetes-management"
    },
    {
      "title": "PostgreSQL MCP Server",
      "description": "Connect Claude to PostgreSQL databases for direct query execution, schema management, and database operations",
      "category": "mcp",
      "author": "JSONbored",
      "dateAdded": "2025-09-16",
      "tags": [
        "postgresql",
        "database",
        "sql",
        "data",
        "query"
      ],
      "content": "The PostgreSQL MCP Server enables Claude to interact directly with PostgreSQL databases. Features include:\n\n## Core Capabilities\n\n### Database Connection\n- Connect to local and remote PostgreSQL instances\n- Support for connection pooling and SSL\n- Multiple database connections simultaneously\n- Connection string and environment variable configuration\n\n### Query Execution\n- Execute SELECT, INSERT, UPDATE, DELETE queries\n- Run complex queries with JOINs and subqueries\n- Support for prepared statements and parameters\n- Transaction management (BEGIN, COMMIT, ROLLBACK)\n- Query result formatting and export\n\n### Schema Management\n- View database schemas and table structures\n- Create, alter, and drop tables\n- Manage indexes, constraints, and foreign keys\n- Handle database migrations and versioning\n- Generate ERD (Entity Relationship Diagrams)\n\n### Data Analysis\n- Generate data insights and statistics\n- Create aggregation queries and reports\n- Identify data quality issues\n- Performance analysis and query optimization\n- Data export in various formats (CSV, JSON, XML)\n\n### Advanced Features\n- Support for PostgreSQL-specific features (JSONB, arrays, CTEs)\n- Full-text search capabilities\n- Spatial data operations with PostGIS\n- Time-series data analysis\n- Custom function and procedure execution\n\n## Installation\n\n```bash\nnpm install @modelcontextprotocol/server-postgres\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"postgres\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-postgres\"],\n      \"env\": {\n        \"POSTGRES_CONNECTION_STRING\": \"postgresql://username:password@localhost:5432/database\"\n      }\n    }\n  }\n}\n```\n\n## Environment Variables\n\n```bash\n# Connection string format\nPOSTGRES_CONNECTION_STRING=postgresql://user:pass@host:port/db\n\n# Or individual components\nPOSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\nPOSTGRES_DATABASE=mydb\nPOSTGRES_USER=myuser\nPOSTGRES_PASSWORD=mypass\nPOSTGRES_SSL=require\n```\n\n## Security Features\n- SSL/TLS encryption support\n- Read-only mode for safe data exploration\n- Query whitelisting and blacklisting\n- Connection timeout and rate limiting\n- Audit logging for all database operations\n\n## Usage Examples\n\n### Data Analysis\n```sql\n-- Analyze customer behavior\nSELECT \n  date_trunc('month', created_at) as month,\n  COUNT(*) as new_customers,\n  AVG(order_value) as avg_order_value\nFROM customers \nWHERE created_at >= '2024-01-01'\nGROUP BY month\nORDER BY month;\n```\n\n### Schema Exploration\n```sql\n-- Get table information\nSELECT \n  table_name,\n  column_name,\n  data_type,\n  is_nullable\nFROM information_schema.columns \nWHERE table_schema = 'public'\nORDER BY table_name, ordinal_position;\n```",
      "configuration": {
        "requiresAuth": true,
        "authType": "connection_string",
        "permissions": [
          "read",
          "write",
          "schema"
        ],
        "safeMode": true
      },
      "githubUrl": "https://github.com/modelcontextprotocol/servers",
      "documentationUrl": "https://modelcontextprotocol.io/servers/postgres",
      "source": "community",
      "slug": "postgresql-mcp",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/postgresql-mcp"
    },
    {
      "title": "Redis Database MCP",
      "description": "High-performance Redis integration for caching, session management, pub/sub messaging, and real-time data operations",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "redis",
        "cache",
        "database",
        "nosql",
        "messaging",
        "real-time"
      ],
      "content": "The Redis Database MCP Server provides comprehensive integration with Redis, the in-memory data structure store, enabling high-performance caching, real-time messaging, and advanced data operations.\n\n## Core Capabilities\n\n### Data Structures & Operations\n- **Strings**: Simple key-value operations, atomic counters\n- **Hashes**: Object storage, field-level operations\n- **Lists**: Queues, stacks, timeline data\n- **Sets**: Unique collections, set operations\n- **Sorted Sets**: Leaderboards, rankings, time-series\n- **Streams**: Event sourcing, message queues\n- **Bitmaps**: Efficient boolean operations\n- **HyperLogLog**: Cardinality estimation\n\n### Advanced Features\n- **Pub/Sub Messaging**: Real-time communication channels\n- **Lua Scripting**: Atomic multi-operation scripts\n- **Transactions**: MULTI/EXEC command batching\n- **Pipelining**: Bulk command execution\n- **Cluster Support**: Distributed Redis deployments\n- **Streams**: Advanced message queuing\n\n### Monitoring & Management\n- Real-time performance metrics\n- Memory usage analysis\n- Slow query monitoring\n- Connection pool management\n- Key expiration tracking\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-redis\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"redis\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-redis\"],\n      \"env\": {\n        \"REDIS_URL\": \"redis://localhost:6379\",\n        \"REDIS_PASSWORD\": \"your-password\",\n        \"REDIS_DB\": \"0\",\n        \"REDIS_MAX_RETRIES\": \"3\",\n        \"REDIS_RETRY_DELAY\": \"1000\"\n      }\n    }\n  }\n}\n```\n\n## Connection Configurations\n\n### Local Redis\n```json\n{\n  \"env\": {\n    \"REDIS_URL\": \"redis://localhost:6379\",\n    \"REDIS_DB\": \"0\"\n  }\n}\n```\n\n### Redis Cloud/AWS ElastiCache\n```json\n{\n  \"env\": {\n    \"REDIS_URL\": \"rediss://your-cluster.cache.amazonaws.com:6380\",\n    \"REDIS_PASSWORD\": \"your-auth-token\",\n    \"REDIS_TLS\": \"true\"\n  }\n}\n```\n\n### Redis Cluster\n```json\n{\n  \"env\": {\n    \"REDIS_CLUSTER_NODES\": \"redis-node1:7000,redis-node2:7000,redis-node3:7000\",\n    \"REDIS_CLUSTER_PASSWORD\": \"cluster-password\"\n  }\n}\n```\n\n### Connection Pool Settings\n```json\n{\n  \"env\": {\n    \"REDIS_URL\": \"redis://localhost:6379\",\n    \"REDIS_POOL_MIN\": \"5\",\n    \"REDIS_POOL_MAX\": \"50\",\n    \"REDIS_CONNECT_TIMEOUT\": \"10000\",\n    \"REDIS_COMMAND_TIMEOUT\": \"5000\"\n  }\n}\n```\n\n## Usage Examples\n\n### Basic Key-Value Operations\n```javascript\n// String operations\nconst setResult = await redis.set('user:1000:name', 'John Doe');\nconst getName = await redis.get('user:1000:name');\n\n// Set with expiration (TTL)\nconst setWithTTL = await redis.setex('session:abc123', 3600, JSON.stringify({\n  userId: 1000,\n  loginTime: Date.now(),\n  permissions: ['read', 'write']\n}));\n\n// Atomic operations\nconst increment = await redis.incr('page:views:homepage');\nconst decrement = await redis.decr('inventory:item:123');\n\n// Multiple operations\nconst multiGet = await redis.mget(['user:1000:name', 'user:1000:email', 'user:1000:status']);\nconst multiSet = await redis.mset({\n  'user:1001:name': 'Jane Smith',\n  'user:1001:email': 'jane@example.com',\n  'user:1001:status': 'active'\n});\n```\n\n### Hash Operations (Object Storage)\n```javascript\n// Store user object as hash\nconst userHash = await redis.hset('user:1000', {\n  name: 'John Doe',\n  email: 'john@example.com',\n  age: 30,\n  department: 'Engineering',\n  lastLogin: Date.now()\n});\n\n// Get specific fields\nconst userEmail = await redis.hget('user:1000', 'email');\nconst userInfo = await redis.hmget('user:1000', ['name', 'department', 'lastLogin']);\n\n// Get all fields\nconst fullUser = await redis.hgetall('user:1000');\n\n// Increment numeric field\nconst loginCount = await redis.hincrby('user:1000', 'loginCount', 1);\n\n// Check field existence\nconst hasEmail = await redis.hexists('user:1000', 'email');\n\n// Get all field names\nconst userFields = await redis.hkeys('user:1000');\n```\n\n### List Operations (Queues & Stacks)\n```javascript\n// Task queue implementation\nconst addTask = await redis.lpush('task:queue', JSON.stringify({\n  id: 'task-123',\n  type: 'send_email',\n  payload: {\n    to: 'user@example.com',\n    subject: 'Welcome!',\n    template: 'welcome'\n  },\n  createdAt: Date.now()\n}));\n\n// Process tasks (blocking pop)\nconst processTask = async () => {\n  const task = await redis.brpop('task:queue', 10); // 10 second timeout\n  if (task) {\n    const [queue, taskData] = task;\n    const taskObj = JSON.parse(taskData);\n    console.log('Processing task:', taskObj.id);\n    // Process the task...\n  }\n};\n\n// Activity timeline\nconst addActivity = await redis.lpush('user:1000:activity', JSON.stringify({\n  action: 'login',\n  timestamp: Date.now(),\n  ip: '192.168.1.100',\n  userAgent: 'Mozilla/5.0...'\n}));\n\n// Get recent activities (last 10)\nconst recentActivities = await redis.lrange('user:1000:activity', 0, 9);\n\n// Trim old activities (keep last 100)\nconst trimActivities = await redis.ltrim('user:1000:activity', 0, 99);\n```\n\n### Set Operations (Unique Collections)\n```javascript\n// Tags system\nconst addTags = await redis.sadd('article:123:tags', 'javascript', 'nodejs', 'redis', 'tutorial');\nconst getAllTags = await redis.smembers('article:123:tags');\nconst hasTag = await redis.sismember('article:123:tags', 'redis');\n\n// User interests\nconst userInterests = await redis.sadd('user:1000:interests', 'programming', 'gaming', 'photography');\n\n// Find common interests between users\nconst commonInterests = await redis.sinter('user:1000:interests', 'user:1001:interests');\n\n// Get all interests (union)\nconst allInterests = await redis.sunion('user:1000:interests', 'user:1001:interests');\n\n// Random tag selection\nconst randomTag = await redis.srandmember('article:123:tags');\nconst randomTags = await redis.srandmember('article:123:tags', 3);\n```\n\n### Sorted Sets (Rankings & Leaderboards)\n```javascript\n// Game leaderboard\nconst updateScore = await redis.zadd('game:leaderboard', {\n  'player:john': 15420,\n  'player:jane': 18750,\n  'player:bob': 12340,\n  'player:alice': 19850\n});\n\n// Get top players\nconst topPlayers = await redis.zrevrange('game:leaderboard', 0, 4, 'WITHSCORES');\n\n// Get player rank\nconst johnRank = await redis.zrevrank('game:leaderboard', 'player:john');\nconst johnScore = await redis.zscore('game:leaderboard', 'player:john');\n\n// Get players by score range\nconst highScorers = await redis.zrangebyscore('game:leaderboard', 15000, '+inf', 'WITHSCORES');\n\n// Time-based data (using timestamps as scores)\nconst addEvent = await redis.zadd('user:1000:events', {\n  'login': Date.now() - 3600000,  // 1 hour ago\n  'purchase': Date.now() - 1800000, // 30 minutes ago\n  'logout': Date.now() - 600000    // 10 minutes ago\n});\n\n// Get events in time range\nconst recentEvents = await redis.zrangebyscore(\n  'user:1000:events',\n  Date.now() - 3600000, // Last hour\n  Date.now(),\n  'WITHSCORES'\n);\n```\n\n### Pub/Sub Messaging\n```javascript\n// Publisher\nconst publishMessage = async (channel, message) => {\n  const result = await redis.publish(channel, JSON.stringify({\n    type: 'user_action',\n    userId: 1000,\n    action: 'purchase',\n    productId: 'prod-123',\n    timestamp: Date.now(),\n    metadata: {\n      amount: 99.99,\n      currency: 'USD'\n    }\n  }));\n  \n  console.log(`Message sent to ${result} subscribers`);\n};\n\n// Subscriber\nconst subscriber = redis.duplicate();\n\nsubscriber.on('message', (channel, message) => {\n  const data = JSON.parse(message);\n  console.log(`Received on ${channel}:`, data);\n  \n  // Process the message based on type\n  switch (data.type) {\n    case 'user_action':\n      handleUserAction(data);\n      break;\n    case 'system_alert':\n      handleSystemAlert(data);\n      break;\n  }\n});\n\nsubscriber.on('subscribe', (channel, count) => {\n  console.log(`Subscribed to ${channel}. Total subscriptions: ${count}`);\n});\n\n// Subscribe to channels\nconst subscribe = await subscriber.subscribe('user:events', 'system:alerts', 'notifications');\n\n// Pattern subscription\nconst patternSubscribe = await subscriber.psubscribe('user:*:events', 'system:*');\n```\n\n### Lua Scripting (Atomic Operations)\n```javascript\n// Rate limiting script\nconst rateLimitScript = `\n  local key = KEYS[1]\n  local window = tonumber(ARGV[1])\n  local limit = tonumber(ARGV[2])\n  local current_time = tonumber(ARGV[3])\n  \n  local current = redis.call('GET', key)\n  if current == false then\n    redis.call('SETEX', key, window, 1)\n    return {1, limit - 1}\n  end\n  \n  current = tonumber(current)\n  if current < limit then\n    local new_val = redis.call('INCR', key)\n    local ttl = redis.call('TTL', key)\n    return {new_val, limit - new_val}\n  else\n    local ttl = redis.call('TTL', key)\n    return {current, 0, ttl}\n  end\n`;\n\n// Execute rate limit check\nconst checkRateLimit = async (userId, windowSeconds = 60, maxRequests = 100) => {\n  const result = await redis.eval(\n    rateLimitScript,\n    1,\n    `rate_limit:${userId}`,\n    windowSeconds,\n    maxRequests,\n    Math.floor(Date.now() / 1000)\n  );\n  \n  return {\n    currentRequests: result[0],\n    remainingRequests: result[1],\n    resetTime: result[2] || windowSeconds\n  };\n};\n\n// Distributed lock script\nconst acquireLockScript = `\n  local key = KEYS[1]\n  local value = ARGV[1]\n  local ttl = tonumber(ARGV[2])\n  \n  local current = redis.call('GET', key)\n  if current == false then\n    redis.call('SETEX', key, ttl, value)\n    return 1\n  elseif current == value then\n    redis.call('EXPIRE', key, ttl)\n    return 1\n  else\n    return 0\n  end\n`;\n\nconst acquireLock = async (lockName, identifier, ttlSeconds = 30) => {\n  const result = await redis.eval(\n    acquireLockScript,\n    1,\n    `lock:${lockName}`,\n    identifier,\n    ttlSeconds\n  );\n  \n  return result === 1;\n};\n```\n\n### Redis Streams (Advanced Messaging)\n```javascript\n// Add events to stream\nconst addToStream = await redis.xadd(\n  'events:user_actions',\n  '*', // Auto-generate ID\n  'user_id', '1000',\n  'action', 'purchase',\n  'product_id', 'prod-123',\n  'amount', '99.99',\n  'timestamp', Date.now()\n);\n\n// Read from stream\nconst readStream = await redis.xread(\n  'COUNT', 10,\n  'STREAMS', 'events:user_actions', '0-0' // From beginning\n);\n\n// Consumer groups\nconst createGroup = await redis.xgroup(\n  'CREATE', 'events:user_actions', 'analytics_group', '0', 'MKSTREAM'\n);\n\n// Read as consumer\nconst readAsConsumer = await redis.xreadgroup(\n  'GROUP', 'analytics_group', 'consumer1',\n  'COUNT', 5,\n  'STREAMS', 'events:user_actions', '>'\n);\n\n// Acknowledge processed messages\nconst ackMessages = await redis.xack(\n  'events:user_actions',\n  'analytics_group',\n  '1642784400000-0', '1642784401000-0'\n);\n```\n\n### Caching Patterns\n```javascript\n// Cache-aside pattern\nconst getUserWithCache = async (userId) => {\n  const cacheKey = `user:${userId}`;\n  \n  // Try cache first\n  let user = await redis.get(cacheKey);\n  if (user) {\n    return JSON.parse(user);\n  }\n  \n  // Cache miss - fetch from database\n  user = await database.getUser(userId);\n  if (user) {\n    // Cache for 1 hour\n    await redis.setex(cacheKey, 3600, JSON.stringify(user));\n  }\n  \n  return user;\n};\n\n// Write-through cache\nconst updateUserWithCache = async (userId, userData) => {\n  const cacheKey = `user:${userId}`;\n  \n  // Update database\n  const updatedUser = await database.updateUser(userId, userData);\n  \n  // Update cache\n  await redis.setex(cacheKey, 3600, JSON.stringify(updatedUser));\n  \n  return updatedUser;\n};\n\n// Cache invalidation\nconst invalidateUserCache = async (userId) => {\n  await redis.del(`user:${userId}`);\n  // Also invalidate related caches\n  await redis.del(`user:${userId}:permissions`, `user:${userId}:preferences`);\n};\n```\n\n## Performance Optimization\n\n### Connection Pooling\n```javascript\n// Configure connection pool\nconst redisConfig = {\n  host: 'localhost',\n  port: 6379,\n  maxRetriesPerRequest: 3,\n  retryDelayOnFailover: 100,\n  enableReadyCheck: false,\n  maxLoadingTimeout: 10000,\n  lazyConnect: true,\n  family: 4,\n  keepAlive: true,\n  // Connection pool settings\n  poolSize: 20,\n  autoResubscribe: true,\n  autoResendUnfulfilledCommands: true\n};\n```\n\n### Pipeline Operations\n```javascript\n// Batch multiple commands\nconst pipeline = redis.pipeline();\n\n// Add commands to pipeline\npipeline.set('key1', 'value1');\npipeline.set('key2', 'value2');\npipeline.incr('counter');\npipeline.hset('user:1000', 'lastSeen', Date.now());\npipeline.expire('session:abc', 3600);\n\n// Execute all commands at once\nconst results = await pipeline.exec();\nresults.forEach((result, index) => {\n  const [error, value] = result;\n  if (error) {\n    console.error(`Command ${index} failed:`, error);\n  } else {\n    console.log(`Command ${index} result:`, value);\n  }\n});\n```\n\n### Memory Optimization\n```javascript\n// Memory-efficient operations\nconst memoryInfo = await redis.memory('usage', 'user:1000');\nconst memoryStats = await redis.memory('stats');\n\n// Use appropriate data types\n// For small sets, consider using lists\n// For boolean flags, use bitmaps\n// For counters, use strings with INCR\n\n// Bitmap for user flags\nconst setUserFlag = await redis.setbit('user:flags:1000', 0, 1); // Email verified\nconst getUserFlag = await redis.getbit('user:flags:1000', 0);\n\n// HyperLogLog for unique counts\nconst addUniqueVisitor = await redis.pfadd('unique:visitors:2025-09', 'user:1000', 'user:1001');\nconst getUniqueCount = await redis.pfcount('unique:visitors:2025-09');\n```\n\n## Monitoring & Debugging\n\n### Performance Monitoring\n```javascript\n// Get Redis info\nconst serverInfo = await redis.info('server');\nconst memoryInfo = await redis.info('memory');\nconst statsInfo = await redis.info('stats');\n\n// Monitor slow queries\nconst slowLog = await redis.slowlog('get', 10);\n\n// Connection monitoring\nconst clientList = await redis.client('list');\nconst clientInfo = await redis.client('info');\n\n// Key statistics\nconst dbSize = await redis.dbsize();\nconst randomKey = await redis.randomkey();\n\n// Memory usage of specific keys\nconst keyMemory = await redis.memory('usage', 'user:1000');\n```\n\n## Error Handling & Resilience\n\n```javascript\n// Connection error handling\nredis.on('error', (error) => {\n  console.error('Redis connection error:', error);\n  // Implement fallback logic\n});\n\nredis.on('reconnecting', (delay) => {\n  console.log(`Reconnecting to Redis in ${delay}ms`);\n});\n\nredis.on('connect', () => {\n  console.log('Connected to Redis');\n});\n\n// Graceful degradation\nconst safeRedisOperation = async (operation) => {\n  try {\n    return await operation();\n  } catch (error) {\n    console.error('Redis operation failed:', error);\n    // Return default value or fetch from alternative source\n    return null;\n  }\n};\n```",
      "configuration": {
        "requiresAuth": false,
        "authType": "password",
        "permissions": [
          "read",
          "write"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-redis",
      "documentationUrl": "https://docs.claude.ai/mcp/redis",
      "source": "community",
      "slug": "redis-database",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/redis-database"
    },
    {
      "title": "Slack Integration MCP",
      "description": "Connect Claude to Slack for team communication, channel management, and workflow automation",
      "category": "mcp",
      "author": "claudepro",
      "dateAdded": "2025-09-16",
      "tags": [
        "slack",
        "communication",
        "collaboration",
        "messaging",
        "teams"
      ],
      "content": "The Slack Integration MCP Server enables Claude to interact with Slack workspaces for seamless team collaboration and workflow automation.\n\n## Core Capabilities\n\n### Messaging & Communication\n- Send messages to channels and direct messages\n- Read channel history and conversations\n- React to messages with emojis\n- Pin important messages\n- Schedule messages for later delivery\n- Create and manage message threads\n\n### Channel Management\n- Create public and private channels\n- Archive and unarchive channels\n- Invite and remove users from channels\n- Set channel topics and purposes\n- Manage channel permissions\n\n### User & Workspace Management\n- Get user profiles and presence status\n- List workspace members\n- Manage user groups and permissions\n- Set user status and away messages\n\n### File & Content Sharing\n- Upload files and images to channels\n- Share snippets and code blocks\n- Create and share workflow automations\n- Generate channel summaries and reports\n\n### Workflow Automation\n- Set up automated responses and triggers\n- Create custom slash commands\n- Integrate with external services\n- Monitor channel activity and generate insights\n\n## Installation\n\n```bash\nnpm install @claudepro/mcp-slack\n```\n\n## Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"slack\": {\n      \"command\": \"npx\",\n      \"args\": [\"@claudepro/mcp-slack\"],\n      \"env\": {\n        \"SLACK_BOT_TOKEN\": \"xoxb-your-bot-token\",\n        \"SLACK_APP_TOKEN\": \"xapp-your-app-token\",\n        \"SLACK_SIGNING_SECRET\": \"your-signing-secret\"\n      }\n    }\n  }\n}\n```\n\n## Setup Instructions\n\n1. **Create Slack App**\n   - Go to https://api.slack.com/apps\n   - Click \"Create New App\" → \"From scratch\"\n   - Name your app and select workspace\n\n2. **Configure OAuth Scopes**\n   ```\n   Bot Token Scopes:\n   - channels:read\n   - channels:write\n   - chat:write\n   - files:write\n   - users:read\n   - groups:read\n   - im:read\n   - mpim:read\n   - reactions:write\n   ```\n\n3. **Install App to Workspace**\n   - Go to \"Install App\" in sidebar\n   - Click \"Install to Workspace\"\n   - Copy the Bot User OAuth Token\n\n4. **Enable Socket Mode (Optional)**\n   - Go to \"Socket Mode\" and enable it\n   - Generate App-Level Token with `connections:write` scope\n\n## Usage Examples\n\n### Send a Message\n```javascript\n// Send to channel\nconst result = await slack.sendMessage({\n  channel: '#general',\n  text: 'Hello team! 👋',\n  blocks: [\n    {\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: '*Project Update*\\nAll tests are passing! ✅'\n      }\n    }\n  ]\n});\n```\n\n### Create Channel\n```javascript\n// Create private channel\nconst channel = await slack.createChannel({\n  name: 'project-alpha',\n  is_private: true,\n  topic: 'Discussion for Project Alpha development'\n});\n```\n\n### Upload File\n```javascript\n// Upload file with context\nconst upload = await slack.uploadFile({\n  channels: '#development',\n  file: './deployment-logs.txt',\n  title: 'Deployment Logs',\n  initial_comment: 'Latest deployment results from staging environment'\n});\n```\n\n### Get Channel History\n```javascript\n// Get recent messages\nconst history = await slack.getChannelHistory({\n  channel: '#general',\n  limit: 50,\n  include_all_metadata: true\n});\n```\n\n## Advanced Features\n\n### Interactive Components\n- Create buttons and select menus\n- Handle user interactions and callbacks\n- Build modal dialogs and forms\n- Implement approval workflows\n\n### Scheduled Operations\n- Daily standup reminders\n- Weekly team reports\n- Automated status updates\n- Meeting notifications\n\n### Integration Patterns\n- GitHub notifications to Slack\n- CI/CD pipeline updates\n- Error monitoring alerts\n- Customer support ticketing\n\n### Analytics & Reporting\n- Message frequency analysis\n- User engagement metrics\n- Channel activity reports\n- Thread participation tracking",
      "configuration": {
        "requiresAuth": true,
        "authType": "oauth",
        "permissions": [
          "channels:read",
          "chat:write",
          "files:write",
          "users:read"
        ]
      },
      "githubUrl": "https://github.com/claudepro/mcp-slack",
      "documentationUrl": "https://docs.claude.ai/mcp/slack",
      "source": "community",
      "slug": "slack-integration",
      "type": "mcp",
      "url": "https://claudepro.directory/mcp/slack-integration"
    }
  ],
  "count": 10,
  "lastUpdated": "2025-09-16T23:54:05.269Z"
}